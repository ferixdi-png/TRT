"""
KIE (Knowledge Is Everything) Telegram Bot
Enhanced version with KIE AI model selection and generation
"""

from __future__ import annotations

import logging
import json
import asyncio
import concurrent.futures
import contextlib
import sys
import os
import re
import math
import uuid
import hashlib
import warnings
import time
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any, List, Set, Callable, Awaitable, TypeVar

from app.utils.logging_config import setup_logging

# Initialize unified logging as early as possible to ensure token redaction and handlers
setup_logging()

from app.observability.structured_logs import (
    build_action_path,
    get_correlation_id,
    log_critical_event,
    log_structured_event,
)
from app.observability.task_lifecycle import log_task_lifecycle
from app.observability.exception_boundary import handle_update_exception, handle_unknown_callback
from app.observability.no_silence_guard import track_outgoing_action
from app.observability.cancel_metrics import increment as increment_cancel_metric
from app.observability.trace import (
    ensure_correlation_id,
    prompt_summary,
    trace_error,
    trace_event,
)
from app.observability.error_catalog import ERROR_CATALOG
from app.observability.request_logger import log_request_event
from app.observability.update_metrics import increment_metric as increment_update_metric
from app.middleware.rate_limit import PerKeyRateLimiter, PerUserRateLimiter, TTLCache
from app.utils.early_update_buffer import EarlyUpdateBuffer
from app.session_store import get_session_store, get_session_cached
from app.generations.request_tracker import RequestTracker, build_request_key

logger = logging.getLogger(__name__)
T = TypeVar("T")
DEBUG_VERBOSE_LOGS = os.getenv("DEBUG_VERBOSE_LOGS", "0").lower() in ("1", "true", "yes")
DATABASE_AVAILABLE = True

# ==================== CALLBACK REGISTRY HELPERS ====================
KNOWN_CALLBACK_PREFIXES = (
    "category:",
    "gen_type:",
    "select_model:",
    "sel:",
    "edit_param:",
    "set_param:",
    "confirm_param:",
    "sku:",
    "sk:",
    "model:",
    "modelk:",
    "select_mode:",
    "start:",
    "example:",
    "info:",
    "type_header:",
    "m:",
    "admin_gen_nav:",
    "admin_gen_view:",
    "admin_search:",
    "admin_add:",
    "admin_payments_back",
    "payment_screenshot_nav:",
    "admin_promocodes",
    "admin_broadcast",
    "admin_create_broadcast",
    "admin_broadcast_stats",
    "admin_test_ocr",
    "admin_user_mode",
    "admin_back_to_admin",
    "admin_user_info:",
    "admin_topup_user:",
    "topup_amount:",
    "pay_sbp:",
    "pay_card:",
    "pay_stars:",
    "set_language:",
    "gen_view:",
    "gen_repeat:",
    "gen_history:",
    "tutorial_step",
    "retry_generate:",
    "retry_delivery:",
    "open_result:",
    "cancel:",
)

KNOWN_CALLBACK_EXACT = {
    "show_models",
    "show_all_models_list",
    "other_models",
    "all_models",
    "free_tools",
    "check_balance",
    "copy_bot",
    "claim_gift",
    "help_menu",
    "support_contact",
    "admin_stats",
    "admin_view_generations",
    "admin_settings",
    "admin_set_currency_rate",
    "back_to_menu",
    "back_to_confirmation",
    "topup_balance",
    "topup_custom",
    "referral_info",
    "generate_again",
    "my_generations",
    "tutorial_start",
    "tutorial_complete",
    "confirm_generate",
    "show_parameters",
    "add_image",
    "skip_image",
    "image_done",
    "add_audio",
    "skip_audio",
    "reset_wizard",
    "reset_step",
    "cancel",
    "back_to_previous_step",
    "view_payment_screenshots",
}

SKIP_PARAM_VALUE = "__skip__"

MESSAGE_RATE_LIMIT_PER_SEC = float(os.getenv("TG_RATE_LIMIT_PER_SEC", "1.5"))
MESSAGE_RATE_LIMIT_BURST = float(os.getenv("TG_RATE_LIMIT_BURST", "5"))
CALLBACK_RATE_LIMIT_PER_SEC = float(os.getenv("TG_CALLBACK_RATE_LIMIT_PER_SEC", "2.0"))
CALLBACK_RATE_LIMIT_BURST = float(os.getenv("TG_CALLBACK_RATE_LIMIT_BURST", "6"))
CALLBACK_DATA_RATE_LIMIT_PER_SEC = float(os.getenv("TG_CALLBACK_DATA_RATE_LIMIT_PER_SEC", "1.0"))
CALLBACK_DATA_RATE_LIMIT_BURST = float(os.getenv("TG_CALLBACK_DATA_RATE_LIMIT_BURST", "2"))
UPDATE_DEDUP_TTL_SECONDS = float(os.getenv("TG_UPDATE_DEDUP_TTL_SECONDS", "60"))
CALLBACK_DEDUP_TTL_SECONDS = float(os.getenv("TG_CALLBACK_DEDUP_TTL_SECONDS", "30"))
CALLBACK_CONCURRENCY_LIMIT = int(os.getenv("TG_CALLBACK_CONCURRENCY_LIMIT", "8"))
CALLBACK_CONCURRENCY_TIMEOUT_SECONDS = float(os.getenv("TG_CALLBACK_CONCURRENCY_TIMEOUT_SECONDS", "2.0"))
START_INFLIGHT_TTL_SECONDS = float(os.getenv("START_INFLIGHT_TTL_SECONDS", "12.0"))
STORAGE_IO_TIMEOUT_SECONDS = float(os.getenv("STORAGE_IO_TIMEOUT_SECONDS", "2.5"))
STORAGE_OP_TIMEOUT_SECONDS = max(0.1, float(os.getenv("STORAGE_OP_TIMEOUT_MS", "2000")) / 1000)
GEN_TYPE_MENU_TIMEOUT_SECONDS = float(os.getenv("GEN_TYPE_MENU_TIMEOUT_SECONDS", "6.0"))
JOB_TIMEOUT_SECONDS = int(os.getenv("JOB_TIMEOUT_SECONDS", "900"))
JOB_TIMEOUT_MS = JOB_TIMEOUT_SECONDS * 1000

_message_rate_limiter = PerUserRateLimiter(MESSAGE_RATE_LIMIT_PER_SEC, MESSAGE_RATE_LIMIT_BURST)
_callback_rate_limiter = PerUserRateLimiter(CALLBACK_RATE_LIMIT_PER_SEC, CALLBACK_RATE_LIMIT_BURST)
_callback_data_rate_limiter = PerKeyRateLimiter(CALLBACK_DATA_RATE_LIMIT_PER_SEC, CALLBACK_DATA_RATE_LIMIT_BURST)
_update_deduper = TTLCache(UPDATE_DEDUP_TTL_SECONDS)
_callback_deduper = TTLCache(CALLBACK_DEDUP_TTL_SECONDS)
_start_inflight_deduper = TTLCache(START_INFLIGHT_TTL_SECONDS)
_callback_semaphore = asyncio.Semaphore(CALLBACK_CONCURRENCY_LIMIT) if CALLBACK_CONCURRENCY_LIMIT > 0 else None
KIE_CREDITS_CACHE_TTL_SECONDS = float(os.getenv("KIE_CREDITS_CACHE_TTL_SECONDS", "120"))
KIE_CREDITS_TIMEOUT_SECONDS = float(os.getenv("KIE_CREDITS_TIMEOUT_SECONDS", "2.0"))
_kie_credits_cache: Dict[str, Any] = {"timestamp": 0.0, "value": None}
_background_tasks: Set[asyncio.Task] = set()


def _log_background_task_result(task: asyncio.Task, *, action: str) -> None:
    try:
        task.result()
    except asyncio.CancelledError:
        logger.info("TASK_CANCELLED action=%s", action)
    except Exception:
        logger.error("TASK_FAILED action=%s", action, exc_info=True)


def _suppress_task_exceptions(task: asyncio.Task, *, action: str = "background") -> None:
    try:
        task.result()
    except asyncio.CancelledError:
        return
    except Exception as exc:
        logger.debug("TASK_SUPPRESSED action=%s error=%s", action, exc, exc_info=True)


def _register_background_task(task: asyncio.Task, *, action: str = "background") -> None:
    _background_tasks.add(task)

    def _on_done(done_task: asyncio.Task) -> None:
        _background_tasks.discard(done_task)
        _log_background_task_result(done_task, action=action)

    task.add_done_callback(_on_done)


def _create_background_task(coro: Any, *, action: str) -> asyncio.Task:
    task = asyncio.create_task(coro)
    _register_background_task(task, action=action)
    return task


def start_delivery_reconciler(bot) -> None:
    global _delivery_reconciler_task
    if _delivery_reconciler_task and not _delivery_reconciler_task.done():
        return
    from app.storage import get_storage
    from app.integrations.kie_stub import get_kie_client_or_stub
    from app.delivery.reconciler import run_reconciler_loop
    storage_instance = get_storage()
    kie_client = get_kie_client_or_stub()
    _delivery_reconciler_task = _create_background_task(
        run_reconciler_loop(
            bot,
            storage_instance,
            kie_client,
            interval_seconds=DELIVERY_RECONCILE_INTERVAL_SECONDS,
            batch_limit=DELIVERY_RECONCILE_BATCH_LIMIT,
            pending_age_alert_seconds=DELIVERY_PENDING_AGE_ALERT_SECONDS,
            queue_tail_alert_threshold=DELIVERY_QUEUE_TAIL_ALERT_THRESHOLD,
            get_user_language=get_user_language,
        ),
        action="delivery_reconciler",
    )


def start_dedupe_reconciler(bot) -> None:
    global _dedupe_reconciler_task
    if _dedupe_reconciler_task and not _dedupe_reconciler_task.done():
        return
    from app.integrations.kie_stub import get_kie_client_or_stub
    from app.generations.dedupe_reconciler import run_dedupe_reconciler_loop

    kie_client = get_kie_client_or_stub()
    _dedupe_reconciler_task = _create_background_task(
        run_dedupe_reconciler_loop(
            bot,
            kie_client,
            resolve_task_id=_resolve_task_id_from_job,
            get_user_language=get_user_language,
            interval_seconds=DEDUPE_RECONCILE_INTERVAL_SECONDS,
            batch_limit=DEDUPE_RECONCILE_BATCH_LIMIT,
            orphan_max_age_seconds=DEDUPE_ORPHAN_MAX_AGE_SECONDS,
            orphan_alert_threshold=DEDUPE_ORPHAN_ALERT_THRESHOLD,
        ),
        action="dedupe_reconciler",
    )


async def stop_reconcilers(timeout_s: float = 5.0) -> None:
    global _delivery_reconciler_task, _dedupe_reconciler_task
    tasks: list[asyncio.Task] = []
    if _delivery_reconciler_task and not _delivery_reconciler_task.done():
        _delivery_reconciler_task.cancel()
        tasks.append(_delivery_reconciler_task)
    if _dedupe_reconciler_task and not _dedupe_reconciler_task.done():
        _dedupe_reconciler_task.cancel()
        tasks.append(_dedupe_reconciler_task)

    if not tasks:
        return
    try:
        await asyncio.wait_for(asyncio.gather(*tasks, return_exceptions=True), timeout=timeout_s)
        logger.info("RECONCILER_STOPPED count=%s timeout_s=%s", len(tasks), timeout_s)
    except asyncio.TimeoutError:
        logger.warning("RECONCILER_STOP_TIMEOUT count=%s timeout_s=%s", len(tasks), timeout_s)
        for task in tasks:
            task.cancel()
        await asyncio.gather(*tasks, return_exceptions=True)
    finally:
        _delivery_reconciler_task = None
        _dedupe_reconciler_task = None


LONG_CALLBACK_PREFIXES = (
    "gen_type:",
    "category:",
    "select_model:",
    "model:",
    "modelk:",
    "gen_view:",
    "gen_repeat:",
    "gen_history:",
    "retry_generate:",
    "retry_delivery:",
    "admin_gen_nav:",
    "admin_gen_view:",
    "payment_screenshot_nav:",
)

LONG_CALLBACK_EXACT = {
    "show_models",
    "show_all_models_list",
    "other_models",
    "all_models",
    "free_tools",
    "check_balance",
    "confirm_generate",
    "back_to_menu",
    "my_generations",
    "generate_again",
    "topup_balance",
    "topup_custom",
    "view_payment_screenshots",
}


def _get_callback_wait_text(callback_data: Optional[str], user_lang: str) -> Optional[str]:
    if not callback_data:
        return None
    if callback_data in LONG_CALLBACK_EXACT or any(
        callback_data.startswith(prefix) for prefix in LONG_CALLBACK_PREFIXES
    ):
        if user_lang == "en":
            return "‚è≥ Please wait‚Ä¶"
        return "‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶"
    return None


async def _answer_callback_early(
    query: Optional[CallbackQuery],
    *,
    user_lang: str,
    callback_data: Optional[str],
) -> None:
    if not query:
        return
    text = _get_callback_wait_text(callback_data, user_lang)
    try:
        if text:
            await query.answer(text=text, show_alert=False)
        else:
            await query.answer()
    except Exception:
        return


def is_known_callback_data(callback_data: Optional[str]) -> bool:
    """Return True if callback data matches known routing patterns."""
    if not callback_data:
        return False
    if callback_data in KNOWN_CALLBACK_EXACT:
        return True
    return any(callback_data.startswith(prefix) for prefix in KNOWN_CALLBACK_PREFIXES)


def _truncate_log_value(value: Optional[str], limit: int = 160) -> Optional[str]:
    if not value:
        return value
    value = str(value)
    if len(value) <= limit:
        return value
    return f"{value[:limit]}...<truncated>"


def _resolve_update_type(update: Update) -> str:
    if update.message:
        if update.message.text:
            return "text"
        if update.message.photo:
            return "photo"
        if update.message.audio or update.message.voice:
            return "audio"
        if update.message.document:
            return "document"
    return "unknown"


def _resolve_message_type(message: Optional[Any]) -> str:
    if not message:
        return "unknown"
    if getattr(message, "text", None):
        return "text"
    if getattr(message, "photo", None):
        return "photo"
    if getattr(message, "audio", None) or getattr(message, "voice", None):
        return "audio"
    if getattr(message, "document", None):
        return "document"
    if getattr(message, "video", None):
        return "video"
    return "unknown"


def _safe_text_preview(text: Optional[str], limit: int = 40) -> Optional[str]:
    if not text:
        return None
    cleaned = re.sub(r"\s+", " ", str(text)).strip()
    if len(cleaned) <= limit:
        return cleaned
    return f"{cleaned[:limit]}‚Ä¶"


def _compact_free_tools_summary(summary: str) -> str:
    if not summary:
        return ""
    normalized = summary.strip()
    if normalized.startswith("aspect_ratio="):
        return normalized.replace("aspect_ratio=", "AR ")
    if normalized.startswith("rendering_speed="):
        return normalized.replace("rendering_speed=", "speed=")
    return normalized


def _format_free_tools_button_label(
    *,
    emoji: str,
    model_name: str,
    summary: str,
    max_len: int = 46,
) -> str:
    summary_display = _compact_free_tools_summary(summary)
    suffix = f" ({summary_display})" if summary_display else ""
    base = f"{emoji} {model_name}"
    label = f"{base}{suffix}"
    if len(label) <= max_len:
        return label
    available = max_len - len(emoji) - 1 - len(suffix)
    if available <= 1:
        trimmed = model_name[: max(1, max_len - 2)].rstrip() + "‚Ä¶"
        return f"{emoji} {trimmed}"
    trimmed_name = model_name
    if len(model_name) > available:
        trimmed_name = model_name[: max(1, available - 1)].rstrip() + "‚Ä¶"
    return f"{emoji} {trimmed_name}{suffix}"


def _build_free_tools_keyboard(
    *,
    free_skus: list,
    models_map: dict,
    user_lang: str,
) -> tuple[InlineKeyboardMarkup, int]:
    from app.pricing.ssot_catalog import get_sku_param_summary, encode_sku_callback

    entries: list[tuple[str, str, tuple[str, str, str]]] = []
    for sku in free_skus:
        model = models_map.get(sku.model_id, {})
        if not model:
            continue
        model_name = model.get("name", sku.model_id)
        model_emoji = model.get("emoji", "üÜì")
        summary = _compact_free_tools_summary(get_sku_param_summary(sku))
        button_text = _format_free_tools_button_label(
            emoji=model_emoji,
            model_name=model_name,
            summary=summary,
        )
        callback_data = encode_sku_callback(sku.sku_id)
        sort_key = (model_name.lower(), summary, sku.sku_id)
        entries.append((button_text, callback_data, sort_key))

    entries.sort(key=lambda item: item[2])
    seen: set[tuple[str, str]] = set()
    rows: list[list[InlineKeyboardButton]] = []
    current_row: list[InlineKeyboardButton] = []
    for button_text, callback_data, _sort_key in entries:
        key = (callback_data, button_text)
        if key in seen:
            continue
        seen.add(key)
        if len(current_row) == 2:
            rows.append(current_row)
            current_row = []
        current_row.append(InlineKeyboardButton(button_text, callback_data=callback_data))
    if current_row:
        rows.append(current_row)
    rows.append([InlineKeyboardButton(t("btn_back_to_menu", lang=user_lang), callback_data="back_to_menu")])
    return InlineKeyboardMarkup(rows), len(seen)


def _safe_text_hash(text: Optional[str]) -> Optional[str]:
    if not text:
        return None
    return hashlib.sha256(text.encode("utf-8")).hexdigest()[:12]


def _log_structured_warning(**fields: Any) -> None:
    """Emit a structured warning log (JSON payload)."""
    from app.observability.context import get_context_fields
    from app.observability.trace import get_correlation_id as get_trace_correlation_id

    correlation_id = fields.get("correlation_id") or get_trace_correlation_id()
    context_fields = get_context_fields()
    payload = {
        "correlation_id": correlation_id,
        "user_id": fields.get("user_id") or context_fields.get("user_id"),
        "chat_id": fields.get("chat_id") or context_fields.get("chat_id"),
        "update_id": fields.get("update_id") or context_fields.get("update_id"),
        "update_type": fields.get("update_type") or context_fields.get("update_type"),
        "action": fields.get("action"),
        "action_path": fields.get("action_path"),
        "command": fields.get("command"),
        "callback_data": fields.get("callback_data"),
        "message_type": fields.get("message_type"),
        "text_length": fields.get("text_length"),
        "text_hash": fields.get("text_hash"),
        "text_preview": fields.get("text_preview"),
        "model_id": fields.get("model_id"),
        "gen_type": fields.get("gen_type"),
        "task_id": fields.get("task_id"),
        "job_id": fields.get("job_id"),
        "sku_id": fields.get("sku_id"),
        "price_rub": fields.get("price_rub"),
        "stage": fields.get("stage"),
        "waiting_for": fields.get("waiting_for"),
        "param": fields.get("param"),
        "outcome": fields.get("outcome"),
        "duration_ms": fields.get("duration_ms"),
        "error_id": fields.get("error_id"),
        "error_code": fields.get("error_code"),
        "fix_hint": fields.get("fix_hint"),
    }
    logger.warning("STRUCTURED_LOG %s", json.dumps(payload, ensure_ascii=False, default=str))


async def get_kie_credits_cached(*, correlation_id: Optional[str] = None) -> Dict[str, Any]:
    """Fetch KIE credits with TTL cache and strict timeout."""
    now = time.monotonic()
    cached_ts = _kie_credits_cache.get("timestamp", 0.0)
    cached_value = _kie_credits_cache.get("value")
    if cached_value and now - cached_ts < KIE_CREDITS_CACHE_TTL_SECONDS:
        return cached_value
    if kie is None:
        return {
            "ok": False,
            "credits": None,
            "status": 0,
            "error": "kie_not_initialized",
            "correlation_id": correlation_id,
        }
    get_credits = getattr(kie, "get_credits", None)
    if not callable(get_credits):
        return {
            "ok": False,
            "credits": None,
            "status": 0,
            "error": "missing_get_credits",
            "correlation_id": correlation_id,
        }
    try:
        result = await asyncio.wait_for(get_credits(), timeout=KIE_CREDITS_TIMEOUT_SECONDS)
    except Exception as exc:
        corr_id = correlation_id or uuid.uuid4().hex
        logger.warning("KIE credits request failed corr_id=%s error=%s", corr_id, exc)
        result = {
            "ok": False,
            "credits": None,
            "status": 0,
            "error": "timeout",
            "correlation_id": corr_id,
        }
    _kie_credits_cache["timestamp"] = now
    _kie_credits_cache["value"] = result
    return result


def _log_handler_latency(handler: str, start_ts: float, update: Update) -> None:
    duration_ms = int((time.monotonic() - start_ts) * 1000)
    user_id = update.effective_user.id if update and update.effective_user else None
    chat_id = update.effective_chat.id if update and update.effective_chat else None
    update_id = update.update_id if update else None
    logger.info(
        "HANDLER_LATENCY handler=%s duration_ms=%s user_id=%s chat_id=%s update_id=%s",
        handler,
        duration_ms,
        user_id,
        chat_id,
        update_id,
    )


def _extract_session_snapshot(
    context: ContextTypes.DEFAULT_TYPE,
    user_id: Optional[int],
    update_id: Optional[int],
) -> Dict[str, Any]:
    if user_id is None:
        return {}
    store = get_session_store(context)
    session = get_session_cached(context, store, user_id, update_id, default={})
    if not isinstance(session, dict):
        return {}
    price_quote = session.get("price_quote") if isinstance(session.get("price_quote"), dict) else {}
    return {
        "waiting_for": session.get("waiting_for"),
        "current_param": session.get("current_param"),
        "model_id": session.get("model_id"),
        "sku_id": session.get("sku_id"),
        "price_rub": price_quote.get("price_rub"),
    }


def _log_route_decision_once(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    waiting_for: Optional[str],
    chosen_handler: str,
    reason: str,
) -> None:
    if not update.message:
        return
    update_id = getattr(update, "update_id", None)
    log_key = update_id if update_id is not None else id(update)
    app = getattr(context, "application", None)
    if app is None:
        return
    logged = app.bot_data.setdefault("_route_decision_logged", set())
    if log_key in logged:
        return
    logged.add(log_key)
    correlation_id = ensure_correlation_id(update, context)
    update_type = _resolve_update_type(update)
    logger.info(
        "ROUTE_DECISION update_type=%s waiting_for=%s chosen_handler=%s reason=%s correlation_id=%s",
        update_type,
        waiting_for,
        chosen_handler,
        reason,
        correlation_id,
    )


async def inbound_update_logger(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log every inbound Telegram update and set contextvars for propagation."""
    from app.observability.context import set_update_context

    correlation_id = ensure_correlation_id(update, context)
    ctx = set_update_context(update, context, correlation_id=correlation_id)
    update_type = ctx.update_type or _resolve_update_type(update)

    command = None
    callback_data = None
    action_path = None
    if update.message and update.message.text and update.message.text.startswith("/"):
        command = update.message.text.split()[0]
        action_path = f"command:{command}"
    if update.callback_query:
        callback_data = update.callback_query.data
        action_path = build_action_path(callback_data)

    log_structured_event(
        correlation_id=correlation_id,
        update_id=ctx.update_id,
        user_id=ctx.user_id,
        chat_id=ctx.chat_id,
        update_type=update_type,
        action="TG_UPDATE_IN",
        action_path=action_path,
        command=_truncate_log_value(command),
        callback_data=_truncate_log_value(callback_data),
        outcome="received",
    )

    app = getattr(context, "application", None)
    if app is None:
        return
    logged = app.bot_data.setdefault("_user_action_logged", set())
    log_key = (ctx.update_id, update_type)
    if log_key in logged:
        return
    logged.add(log_key)
    session_snapshot: Dict[str, Any] = {}
    if ctx.user_id is not None:
        store = get_session_store(context)
        session = store.get(ctx.user_id, {}) if store else {}
        if isinstance(session, dict):
            price_quote = session.get("price_quote") if isinstance(session.get("price_quote"), dict) else {}
            session_snapshot = {
                "waiting_for": session.get("waiting_for"),
                "current_param": session.get("current_param"),
                "model_id": session.get("model_id"),
                "sku_id": session.get("sku_id"),
                "price_rub": price_quote.get("price_rub"),
            }
    if update_type == "callback" and update.callback_query:
        query = update.callback_query
        chat_id = query.message.chat_id if query.message else None
        log_structured_event(
            correlation_id=correlation_id,
            user_id=ctx.user_id,
            chat_id=chat_id,
            update_id=ctx.update_id,
            update_type="callback",
            action="USER_ACTION",
            action_path=build_action_path(query.data),
            callback_data=_truncate_log_value(query.data),
            message_type=None,
            model_id=session_snapshot.get("model_id"),
            waiting_for=session_snapshot.get("waiting_for"),
            sku_id=session_snapshot.get("sku_id"),
            price_rub=session_snapshot.get("price_rub"),
            stage="USER_ACTION_AUDIT",
            outcome="observed",
            param={
                "handled_by": "inbound_update_logger",
                "current_param": session_snapshot.get("current_param"),
            },
        )
    elif update_type == "message" and update.message:
        message = update.message
        message_type = _resolve_message_type(message)
        text_value = message.text or message.caption or ""
        log_structured_event(
            correlation_id=correlation_id,
            user_id=ctx.user_id,
            chat_id=ctx.chat_id,
            update_id=ctx.update_id,
            update_type="message",
            action="USER_ACTION",
            action_path=f"message_input:{message_type}",
            message_type=message_type,
            text_length=len(text_value) if text_value else 0,
            text_hash=_safe_text_hash(text_value),
            text_preview=_safe_text_preview(text_value),
            model_id=session_snapshot.get("model_id"),
            waiting_for=session_snapshot.get("waiting_for"),
            sku_id=session_snapshot.get("sku_id"),
            price_rub=session_snapshot.get("price_rub"),
            stage="USER_ACTION_AUDIT",
            outcome="observed",
            param={
                "handled_by": "inbound_update_logger",
                "current_param": session_snapshot.get("current_param"),
            },
        )


async def user_action_audit_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Audit layer for all callback queries (non-blocking)."""
    if not update.callback_query:
        return
    query = update.callback_query
    user_id = query.from_user.id if query.from_user else None
    user_lang = get_user_language(user_id) if user_id else "ru"
    await _answer_callback_early(
        query,
        user_lang=user_lang,
        callback_data=query.data,
    )
    correlation_id = ensure_correlation_id(update, context)
    chat_id = query.message.chat_id if query.message else None
    update_id = getattr(update, "update_id", None)
    session_snapshot = _extract_session_snapshot(context, user_id, update_id)
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        update_type="callback",
        action="USER_ACTION",
        action_path=build_action_path(query.data),
        callback_data=_truncate_log_value(query.data),
        message_type=None,
        model_id=session_snapshot.get("model_id"),
        waiting_for=session_snapshot.get("waiting_for"),
        sku_id=session_snapshot.get("sku_id"),
        price_rub=session_snapshot.get("price_rub"),
        stage="USER_ACTION_AUDIT",
        outcome="observed",
        param={
            "handled_by": "user_action_audit_callback",
            "current_param": session_snapshot.get("current_param"),
        },
    )


async def user_action_audit_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Audit layer for all incoming messages (non-blocking)."""
    if not update.message:
        return
    correlation_id = ensure_correlation_id(update, context)
    update_id = getattr(update, "update_id", None)
    user_id = update.effective_user.id if update.effective_user else None
    chat_id = update.effective_chat.id if update.effective_chat else None
    message = update.message
    message_type = _resolve_message_type(message)
    text_value = message.text or message.caption or ""
    session_snapshot = _extract_session_snapshot(context, user_id, update_id)
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        update_type="message",
        action="USER_ACTION",
        action_path=f"message_input:{message_type}",
        message_type=message_type,
        text_length=len(text_value) if text_value else 0,
        text_hash=_safe_text_hash(text_value),
        text_preview=_safe_text_preview(text_value),
        model_id=session_snapshot.get("model_id"),
        waiting_for=session_snapshot.get("waiting_for"),
        sku_id=session_snapshot.get("sku_id"),
        price_rub=session_snapshot.get("price_rub"),
        stage="USER_ACTION_AUDIT",
        outcome="observed",
        param={
            "handled_by": "user_action_audit_message",
            "current_param": session_snapshot.get("current_param"),
        },
    )


async def inbound_rate_limit_guard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Deduplicate updates and apply per-user rate limits before handlers."""
    from telegram.ext import ApplicationHandlerStop
    from app.observability.no_silence_guard import track_outgoing_action

    user_id = update.effective_user.id if update.effective_user else None
    if not user_id:
        return

    chat_id = update.effective_chat.id if update.effective_chat else None
    correlation_id = ensure_correlation_id(update, context)
    update_id = getattr(update, "update_id", None)

    if update_id is not None and _update_deduper.seen(update_id):
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="TG_UPDATE_IN",
            action_path="dedup:update_id",
            outcome="deduped",
            fix_hint="duplicate_update_id",
        )
        if update.callback_query:
            try:
                await update.callback_query.answer()
                track_outgoing_action(update_id, action_type="answerCallbackQuery")
            except Exception as exc:
                logger.warning("CALLBACK_THROTTLE_ANSWER_FAILED user_id=%s update_id=%s error=%s", user_id, update_id, exc, exc_info=True)
        raise ApplicationHandlerStop

    if update.callback_query and update.callback_query.id:
        callback_id = update.callback_query.id
        if _callback_deduper.seen(callback_id):
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="TG_UPDATE_IN",
                action_path="dedup:callback",
                outcome="deduped",
                fix_hint="duplicate_callback_id",
                param={"callback_id": callback_id},
            )
            try:
                await update.callback_query.answer()
                if update_id is not None:
                    track_outgoing_action(update_id, action_type="answerCallbackQuery")
            except Exception as exc:
                logger.warning("CALLBACK_DEDUP_ANSWER_FAILED user_id=%s update_id=%s callback_id=%s error=%s", user_id, update_id, callback_id, exc, exc_info=True)
            raise ApplicationHandlerStop

    if update.callback_query and update.callback_query.data and user_id is not None:
        callback_key = (user_id, update.callback_query.data)
        allowed, retry_after = _callback_data_rate_limiter.check(callback_key)
        if not allowed:
            wait_seconds = max(1, int(math.ceil(retry_after)))
            user_lang = get_user_language(user_id) if user_id else "ru"
            text = (
                f"‚è≥ <b>–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ</b>\n\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ {wait_seconds} —Å–µ–∫."
                if user_lang == "ru"
                else f"‚è≥ <b>Too many taps</b>\n\nTry again in {wait_seconds}s."
            )
            reply_markup = build_back_to_menu_keyboard(user_lang)
            try:
                await update.callback_query.answer()
                if update_id is not None:
                    track_outgoing_action(update_id, action_type="answerCallbackQuery")
            except Exception as exc:
                logger.warning("CALLBACK_RATELIMIT_ANSWER_FAILED user_id=%s update_id=%s error=%s", user_id, update_id, exc, exc_info=True)
            if chat_id:
                try:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=text,
                        parse_mode="HTML",
                        reply_markup=reply_markup,
                    )
                    if update_id is not None:
                        track_outgoing_action(update_id, action_type="send_message")
                except Exception:
                    logger.warning("Failed to send callback throttle response to user %s", user_id, exc_info=True)
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="TG_RATE_LIMIT",
                action_path="rate_limit_guard:callback_data",
                outcome="throttled",
                param={
                    "retry_after": wait_seconds,
                    "callback_data": update.callback_query.data,
                },
            )
            raise ApplicationHandlerStop

    limiter = _callback_rate_limiter if update.callback_query else _message_rate_limiter
    allowed, retry_after = limiter.check(user_id)
    if allowed:
        return

    wait_seconds = max(1, int(math.ceil(retry_after)))
    user_lang = get_user_language(user_id) if user_id else "ru"
    text = (
        f"‚è≥ <b>–°–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ</b>\n\n"
        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ {wait_seconds} —Å–µ–∫."
        if user_lang == "ru"
        else f"‚è≥ <b>Too fast</b>\n\nTry again in {wait_seconds}s."
    )
    reply_markup = build_back_to_menu_keyboard(user_lang)

    if update.callback_query:
        try:
            await update.callback_query.answer()
            if update_id is not None:
                track_outgoing_action(update_id, action_type="answerCallbackQuery")
        except Exception as exc:
            logger.warning("MESSAGE_RATELIMIT_CALLBACK_ANSWER_FAILED user_id=%s update_id=%s error=%s", user_id, update_id, exc, exc_info=True)

    if chat_id:
        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=text,
                parse_mode="HTML",
                reply_markup=reply_markup,
            )
            if update_id is not None:
                track_outgoing_action(update_id, action_type="send_message")
        except Exception:
            logger.warning("Failed to send throttle response to user %s", user_id, exc_info=True)

    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="TG_RATE_LIMIT",
        action_path="rate_limit_guard",
        outcome="throttled",
        param={"retry_after": wait_seconds, "update_type": "callback" if update.callback_query else "message"},
    )
    raise ApplicationHandlerStop

# ==================== SELF-CHECK: ENV SUMMARY AND VALIDATION ====================
def log_env_summary():
    """–õ–æ–≥–∏—Ä—É–µ—Ç summary ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –±–µ–∑ —Å–µ–∫—Ä–µ—Ç–æ–≤"""
    env_vars = {
        "PORT": os.getenv("PORT", "not set"),
        "RENDER": os.getenv("RENDER", "not set"),
        "ENV": os.getenv("ENV", "not set"),
        "BOT_MODE": os.getenv("BOT_MODE", "not set"),
        "STORAGE_MODE": os.getenv("STORAGE_MODE", "not set"),
        "TELEGRAM_BOT_TOKEN": "[SET]" if os.getenv("TELEGRAM_BOT_TOKEN") else "[NOT SET]",
        "KIE_API_KEY": "[SET]" if os.getenv("KIE_API_KEY") else "[NOT SET]",
        "KIE_API_URL": os.getenv("KIE_API_URL", "not set"),
        "TEST_MODE": os.getenv("TEST_MODE", "not set"),
        "DRY_RUN": os.getenv("DRY_RUN", "not set"),
        "ALLOW_REAL_GENERATION": os.getenv("ALLOW_REAL_GENERATION", "not set"),
        "KIE_STUB": os.getenv("KIE_STUB", "not set"),
    }
    
    logger.info("=" * 60)
    logger.info("ENVIRONMENT VARIABLES SUMMARY")
    logger.info("=" * 60)
    for key, value in sorted(env_vars.items()):
        logger.info(f"{key}={value}")
    logger.info("=" * 60)


def validate_required_env():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è"""
    errors = []
    warnings = []
    
    # TELEGRAM_BOT_TOKEN - –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –≤—Å–µ–≥–¥–∞
    if not os.getenv("TELEGRAM_BOT_TOKEN"):
        errors.append("TELEGRAM_BOT_TOKEN is required but not set")
    
    # KIE_API_KEY - –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –µ—Å–ª–∏ real generation
    allow_real = os.getenv("ALLOW_REAL_GENERATION", "1") != "0"
    test_mode = os.getenv("TEST_MODE", "0") == "1"
    kie_stub = os.getenv("KIE_STUB", "0") == "1"
    
    if allow_real and not test_mode and not kie_stub:
        if not os.getenv("KIE_API_KEY"):
            errors.append("KIE_API_KEY is required for real generation (set ALLOW_REAL_GENERATION=0 or TEST_MODE=1 to disable)")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ (warning, –Ω–µ error - –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º)
    models_yaml = Path(__file__).parent / "models" / "kie_models.yaml"
    if not models_yaml.exists():
        warnings.append(f"models/kie_models.yaml not found at {models_yaml} - model registry may not work")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º PyYAML (warning, –Ω–µ error - –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ä–µ–∂–∏–º–∞—Ö)
    try:
        import yaml
    except ImportError:
        warnings.append("PyYAML not installed - model registry from YAML will not work (install with: pip install PyYAML)")
    
    # –í—ã–≤–æ–¥–∏–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
    if warnings:
        logger.warning("=" * 60)
        logger.warning("ENVIRONMENT WARNINGS")
        logger.warning("=" * 60)
        for warning in warnings:
            logger.warning(f"‚ö†Ô∏è  {warning}")
        logger.warning("=" * 60)
    
    # –í—ã–≤–æ–¥–∏–º –æ—à–∏–±–∫–∏ –∏ –≤—ã—Ö–æ–¥–∏–º
    if errors:
        logger.error("=" * 60)
        logger.error("ENVIRONMENT VALIDATION FAILED")
        logger.error("=" * 60)
        for error in errors:
            logger.error(f"‚ùå {error}")
        logger.error("=" * 60)
        logger.error("Please fix the errors above and restart the bot")
        sys.exit(1)
    
    logger.info("‚úÖ Environment validation passed")


# –í—ã–ø–æ–ª–Ω—è–µ–º self-check –ü–ï–†–ï–î –∏–º–ø–æ—Ä—Ç–æ–º –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π
# –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —è–≤–Ω–æ –∑–∞–ø—Ä–æ—à–µ–Ω–æ —á–µ—Ä–µ–∑ RUN_ENV_CHECK=1 –∏ –Ω–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ —á–µ—Ä–µ–∑ SKIP_CONFIG_INIT=1
# –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ç–µ—Å—Ç–∞–º –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –º–æ–¥—É–ª—å –±–µ–∑ side effects
if os.getenv("RUN_ENV_CHECK", "0") == "1" and os.getenv("SKIP_CONFIG_INIT", "0") != "1":
    log_env_summary()
    validate_required_env()
elif os.getenv("SKIP_CONFIG_INIT", "0") != "1" and os.getenv("TEST_MODE", "0") != "1":
    # –í production —Ä–µ–∂–∏–º–µ –ª–æ–≥–∏—Ä—É–µ–º summary –±–µ–∑ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ (—á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞—Ç—å –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ ENV)
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –±—É–¥–µ—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –≤ main() / create_bot_application()
    log_env_summary()

# ==================== IMPORTS AFTER SELF-CHECK ====================
import httpx
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    ConversationHandler, CallbackQueryHandler, TypeHandler
)
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, CallbackQuery, BotCommand
from telegram.ext import ContextTypes
from telegram.error import BadRequest, Conflict, RetryAfter, TimedOut
from telegram.warnings import PTBUserWarning

# Suppress PTB warning about per_message handlers (we enforce correct behavior manually)
warnings.filterwarnings(
    "ignore",
    message=".*per_message=True.*",
    category=PTBUserWarning,
)

# ==================== TELEGRAM TEXT LIMITS ====================
TELEGRAM_TEXT_LIMIT = 4000
TELEGRAM_CHUNK_LIMIT = 3900

_CALLBACK_ANSWER_PATCHED = False
_CALLBACK_EDIT_TEXT_PATCHED = False
_MESSAGE_EDIT_TEXT_PATCHED = False


def _patch_callback_query_answer() -> None:
    global _CALLBACK_ANSWER_PATCHED
    if _CALLBACK_ANSWER_PATCHED:
        return

    original_answer = CallbackQuery.answer

    async def safe_answer(self, *args, **kwargs):
        try:
            return await original_answer(self, *args, **kwargs)
        except BadRequest as exc:
            message = str(exc).lower()
            if (
                "query is too old" in message
                or "response timeout expired" in message
                or "query id is invalid" in message
            ):
                logger.info(
                    "Ignoring expired callback answer: query_id=%s error=%s",
                    getattr(self, "id", None),
                    exc,
                )
                return None
            raise
        except Exception as exc:
            logger.warning(
                "Failed to answer callback query: query_id=%s error=%s",
                getattr(self, "id", None),
                exc,
            )
            return None

    CallbackQuery.answer = safe_answer
    _CALLBACK_ANSWER_PATCHED = True


_patch_callback_query_answer()


def _patch_callback_query_edit_message_text() -> None:
    """Patch CallbackQuery.edit_message_text to ignore benign 'Message is not modified' errors.

    This error is expected when a user presses the same menu button twice and the bot
    attempts to edit the message with identical content/markup.
    """

    global _CALLBACK_EDIT_TEXT_PATCHED
    if _CALLBACK_EDIT_TEXT_PATCHED:
        return

    original_edit = CallbackQuery.edit_message_text

    async def safe_edit_message_text(self, *args, **kwargs):
        try:
            return await original_edit(self, *args, **kwargs)
        except BadRequest as exc:
            message = str(exc).lower()
            if "message is not modified" in message:
                logger.info(
                    "Ignoring benign edit_message_text(no-op): query_id=%s error=%s",
                    getattr(self, "id", None),
                    exc,
                )
                # Return current message object (best-effort) to match PTB expectations.
                return getattr(self, "message", None)
            raise
        except Exception as exc:
            logger.warning(
                "Failed to edit callback message text: query_id=%s error=%s",
                getattr(self, "id", None),
                exc,
            )
            return getattr(self, "message", None)

    CallbackQuery.edit_message_text = safe_edit_message_text
    _CALLBACK_EDIT_TEXT_PATCHED = True


def _patch_message_edit_text() -> None:
    """Patch Message.edit_text to ignore benign 'Message is not modified' errors."""

    global _MESSAGE_EDIT_TEXT_PATCHED
    if _MESSAGE_EDIT_TEXT_PATCHED:
        return

    try:
        from telegram import Message
    except Exception as exc:
        logger.error("CRITICAL_IMPORT_FAILED module=telegram.Message error=%s", exc, exc_info=True)
        return

    original_edit = Message.edit_text

    async def safe_message_edit_text(self, *args, **kwargs):
        try:
            return await original_edit(self, *args, **kwargs)
        except BadRequest as exc:
            message = str(exc).lower()
            if "message is not modified" in message:
                logger.info(
                    "Ignoring benign message.edit_text(no-op): message_id=%s error=%s",
                    getattr(self, "message_id", None),
                    exc,
                )
                return self
            raise
        except Exception as exc:
            logger.warning(
                "Failed to edit message text: message_id=%s error=%s",
                getattr(self, "message_id", None),
                exc,
            )
            return self

    Message.edit_text = safe_message_edit_text
    _MESSAGE_EDIT_TEXT_PATCHED = True


_patch_callback_query_edit_message_text()
_patch_message_edit_text()

# –£–±—Ä–∞–Ω–æ: from dotenv import load_dotenv
# –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard)

# ==================== GLOBAL POLLING START CONTROL ====================
# –ñ—ë—Å—Ç–∫–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—É—Å–∫–æ–≤ polling (409 Conflict)
_POLLING_STARTED = False
_POLLING_LOCK = asyncio.Lock()
from knowledge_storage import KnowledgeStorage
from translations import t, TRANSLATIONS
from kie_client import get_client
from kie_gateway import get_kie_gateway
from config_runtime import is_dry_run, allow_real_generation, is_test_mode, get_config_summary
from helpers import (
    build_main_menu_keyboard, get_balance_info, format_balance_message,
    get_balance_keyboard, set_constants
)
from price_confirmation import show_price_confirmation, build_confirmation_text
# –ò—Å–ø–æ–ª—å–∑—É–µ–º registry –∫–∞–∫ –µ–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –º–æ–¥–µ–ª–µ–π
from app.models.registry import (
    get_generation_types,
    get_models_by_generation_type,
    get_generation_type_info,
    get_models_cached_only,
    get_models_static_only,
)
from app.models.canonical import canonicalize_model_id
from app.utils.singleton_lock import get_lock_mode, is_lock_degraded, is_lock_acquired
from app.services.free_tools_service import (
    add_referral_free_bonus,
    check_and_consume_free_generation,
    check_free_generation_available,
    consume_free_generation,
    format_free_counter_block,
    get_free_generation_status,
    get_free_counter_snapshot,
    get_free_tools_config,
    get_free_tools_model_ids,
)
from app.services.referral_service import (
    award_referral_bonus,
    build_referral_link,
    get_referral_stats,
    list_referrals_for_referrer,
    parse_referral_param,
)
from app.pricing.ssot_catalog import format_pricing_blocked_message
from app.session_store import (
    get_session_store,
    get_session_cached,
    ensure_session_cached,
    get_session_get_count,
)
from app.ux.navigation import build_back_to_menu_keyboard


def ensure_source_of_truth() -> bool:
    """Validate registry/pricing sources and log mismatches without crashing."""
    from app.models.yaml_registry import get_registry_path, load_yaml_models
    from app.kie_catalog.catalog import get_catalog_source_info, _load_yaml_catalog
    from pricing.engine import get_settings_source_info
    from app.pricing.price_ssot import list_all_models
    from app.models.registry_validator import validate_registry_consistency

    registry_path = get_registry_path()
    registry_models = load_yaml_models()
    if not registry_models:
        logger.error("REGISTRY_SOURCE_MISSING path=%s stage=registry_validation", registry_path)
        return False

    catalog_info = get_catalog_source_info()
    raw_catalog = _load_yaml_catalog()
    if not raw_catalog:
        logger.error("PRICING_CATALOG_MISSING path=%s stage=registry_validation", catalog_info["path"])
        return False

    pricing_settings_info = get_settings_source_info()
    pricing_settings = pricing_settings_info.get("settings", {})
    price_multiplier_env = os.getenv("PRICE_MULTIPLIER", "").strip()
    if not pricing_settings_info.get("path") or pricing_settings_info.get("path") == "unknown":
        if not price_multiplier_env:
            logger.error("PRICING_SETTINGS_MISSING stage=registry_validation")
            return False

    if "usd_to_rub" not in pricing_settings:
        logger.error("PRICING_SETTINGS_USD_RUB_MISSING stage=registry_validation")
        return False
    if not price_multiplier_env and "markup_multiplier" not in pricing_settings:
        logger.error("PRICING_SETTINGS_MARKUP_MISSING stage=registry_validation")
        return False

    usd_to_rub_value = float(pricing_settings.get("usd_to_rub"))
    markup_multiplier_value = float(price_multiplier_env or pricing_settings.get("markup_multiplier"))

    registry_ids = set(registry_models.keys())
    pricing_ids = {item.get("id") for item in raw_catalog if isinstance(item, dict)}
    missing_in_pricing = sorted([model_id for model_id in registry_ids if model_id not in pricing_ids])
    if missing_in_pricing:
        logger.error(
            "REGISTRY_PRICING_MISMATCH missing=%s catalog=%s stage=registry_validation",
            ", ".join(missing_in_pricing),
            catalog_info["path"],
        )
        return False

    pricing_ssot_ids = set(list_all_models())
    missing_in_ssot = sorted([model_id for model_id in registry_ids if model_id not in pricing_ssot_ids])
    if missing_in_ssot:
        logger.error(
            "REGISTRY_PRICE_SSOT_MISMATCH missing=%s stage=registry_validation",
            ", ".join(missing_in_ssot),
        )
        return False

    extra_in_ssot = sorted([model_id for model_id in pricing_ssot_ids if model_id not in registry_ids])
    if extra_in_ssot:
        logger.error(
            "PRICE_SSOT_REGISTRY_MISMATCH extra=%s stage=registry_validation",
            ", ".join(extra_in_ssot),
        )
        return False

    logger.info(
        "‚úÖ SOURCE OF TRUTH: registry=%s models=%s | pricing_catalog=%s models=%s | pricing_settings=%s "
        "| usd_to_rub=%s | price_multiplier=%s",
        registry_path,
        len(registry_models),
        catalog_info["path"],
        catalog_info["count"],
        pricing_settings_info["path"],
        usd_to_rub_value,
        markup_multiplier_value,
    )

    validate_registry_consistency()
    from app.pricing.ssot_catalog import validate_pricing_schema_consistency

    pricing_issues = validate_pricing_schema_consistency()
    if pricing_issues:
        logger.warning("PRICING_SCHEMA_ISSUES count=%s", len(pricing_issues))
        for model_id, model_issues in pricing_issues.items():
            logger.warning(
                "PRICING_SCHEMA_ISSUE model_id=%s issues=%s",
                model_id,
                "; ".join(model_issues),
            )
    return True


# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–µ–µ—Å—Ç—Ä–æ–º –º–æ–¥–µ–ª–µ–π
def get_model_by_id_from_registry(model_id: str) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞ –ø–æ ID"""
    models = get_models_sync()
    for model in models:
        if model.get('id') == model_id:
            return model
    return None


_VISIBLE_MODEL_IDS_CACHE: Optional[Set[str]] = None
_GEN_TYPE_MODELS_CACHE: Dict[str, Dict[str, Any]] = {}
GEN_TYPE_MODELS_CACHE_TTL_SECONDS = float(os.getenv("GEN_TYPE_MODELS_CACHE_TTL_SECONDS", "30"))
GEN_TYPE_MODELS_CACHE_STALE_TTL_SECONDS = float(
    os.getenv("GEN_TYPE_MODELS_CACHE_STALE_TTL_SECONDS", "180")
)
BOT_HEARTBEAT_INTERVAL_SECONDS = float(os.getenv("BOT_HEARTBEAT_INTERVAL_SECONDS", "60"))


def _normalize_heartbeat_interval(interval_seconds: float) -> float:
    """Clamp heartbeat interval to a sane range while allowing explicit disable."""
    if interval_seconds <= 0:
        return 0.0
    if interval_seconds < 15:
        return 15.0
    return interval_seconds


async def _bot_heartbeat_loop(stop_event: asyncio.Event, interval_seconds: float) -> None:
    """Emit periodic liveness logs so idle polling does not look stuck."""
    logger.info("üíì BOT_HEARTBEAT task_started interval_s=%s", interval_seconds)
    while not stop_event.is_set():
        try:
            await asyncio.wait_for(stop_event.wait(), timeout=interval_seconds)
            break
        except asyncio.TimeoutError:
            models_cached = get_models_cached_only()
            models_cached_count = len(models_cached) if models_cached is not None else 0
            logger.info(
                "üíì BOT_HEARTBEAT status=alive lock_mode=%s lock_degraded=%s lock_acquired=%s models_cached=%s gen_type_cache=%s",
                get_lock_mode(),
                is_lock_degraded(),
                is_lock_acquired(),
                models_cached_count,
                len(_GEN_TYPE_MODELS_CACHE),
            )
    logger.info("üíì BOT_HEARTBEAT task_stopped")


def _get_visible_model_ids() -> Set[str]:
    global _VISIBLE_MODEL_IDS_CACHE
    if _VISIBLE_MODEL_IDS_CACHE is None:
        # Boot warmup: use only static models, skip expensive validation
        cached_models = get_models_cached_only()
        models = cached_models if cached_models is not None else get_models_static_only()
        
        # Simple visibility check without API calls during boot
        _VISIBLE_MODEL_IDS_CACHE = {
            model_id
            for model in models
            if (model_id := model.get("id")) and _is_model_visible_static(model_id)
        }
    return _VISIBLE_MODEL_IDS_CACHE


def _is_model_visible_static(model_id: str) -> bool:
    """Fast visibility check without API calls for boot warmup."""
    # Skip expensive validation during boot
    # Assume all static models are visible initially
    return True


def filter_visible_models(models: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    visible_ids = _get_visible_model_ids()
    return [model for model in models if model.get("id") in visible_ids]


def _gen_type_to_model_type(gen_type: str) -> str:
    reverse_mapping = {
        'text-to-image': 'text_to_image',
        'text-to-video': 'text_to_video',
        'image-to-video': 'image_to_video',
        'image-to-image': 'image_to_image',
        'image-edit': 'image_edit',
        'upscale': 'image_upscale',
        'video-upscale': 'video_upscale',
        'video-edit': 'video_edit',
        'speech-to-video': 'speech_to_video',
        'text-to-speech': 'text_to_speech',
        'speech-to-text': 'speech_to_text',
        'text-to-music': 'text_to_music',
        'outpaint': 'outpaint',
        'audio-to-audio': 'audio_to_audio',
    }
    return reverse_mapping.get(gen_type, gen_type.replace("-", "_"))


def _get_visible_models_by_generation_type_raw(gen_type: str) -> List[Dict[str, Any]]:
    return filter_visible_models(get_models_by_generation_type(gen_type))


def _get_cached_gen_type_models(gen_type: str, *, allow_stale: bool) -> Optional[List[Dict[str, Any]]]:
    entry = _GEN_TYPE_MODELS_CACHE.get(gen_type)
    if not entry:
        return None
    age = time.monotonic() - entry["timestamp"]
    if age <= GEN_TYPE_MODELS_CACHE_TTL_SECONDS:
        return entry["models"]
    if allow_stale and age <= GEN_TYPE_MODELS_CACHE_STALE_TTL_SECONDS:
        return entry["models"]
    return None


def _store_gen_type_models_cache(gen_type: str, models: List[Dict[str, Any]]) -> None:
    _GEN_TYPE_MODELS_CACHE[gen_type] = {
        "timestamp": time.monotonic(),
        "models": models,
    }


def get_visible_models_by_generation_type(gen_type: str) -> List[Dict[str, Any]]:
    models, _ = get_visible_models_by_generation_type_cached(gen_type)
    return models


def get_visible_models_by_generation_type_cached(gen_type: str, *, allow_api: bool = True) -> tuple[List[Dict[str, Any]], str]:
    """Return visible models and cache status without triggering IO."""
    cached = _get_cached_gen_type_models(gen_type, allow_stale=False)
    if cached is not None:
        return cached, "hit"

    cached_models = get_models_cached_only() if allow_api else get_models_static_only()
    if cached_models is None:
        logger.warning(
            "GEN_TYPE_MODELS_CACHE_MISS gen_type=%s reason=models_cache_empty",
            gen_type,
        )
        return [], "miss"

    model_type = _gen_type_to_model_type(gen_type)
    models = filter_visible_models(
        [model for model in cached_models if model.get("model_type") == model_type]
    )
    _store_gen_type_models_cache(gen_type, models)
    return models, "miss"


GEN_TYPE_MENU_WARMUP_DEGRADED = False
GEN_TYPE_MENU_WARMUP_TIMEOUT_SECONDS = float(os.getenv("GEN_TYPE_MENU_WARMUP_TIMEOUT_SECONDS", "4.0"))
GEN_TYPE_MENU_WARMUP_CACHE_TTL_SECONDS = float(os.getenv("GEN_TYPE_MENU_WARMUP_CACHE_TTL_SECONDS", "300.0"))
GEN_TYPE_MENU_WARMUP_RETRY_ATTEMPTS = int(os.getenv("GEN_TYPE_MENU_WARMUP_RETRY_ATTEMPTS", "2"))
GEN_TYPE_MENU_WARMUP_RETRY_DELAY_SECONDS = float(os.getenv("GEN_TYPE_MENU_WARMUP_RETRY_DELAY_SECONDS", "0.3"))
GEN_TYPE_MENU_WARMUP_CACHE_PATH = os.getenv(
    "GEN_TYPE_MENU_WARMUP_CACHE_PATH",
    "data/cache/gen_type_menu_warmup.json",
)
GEN_TYPE_MENU_WARMUP_SLOW_MS = int(os.getenv("GEN_TYPE_MENU_WARMUP_SLOW_MS", "250"))
GEN_TYPE_MENU_WARMUP_CONCURRENCY = int(os.getenv("GEN_TYPE_MENU_WARMUP_CONCURRENCY", "6"))
PRICING_PREFLIGHT_TIMEOUT_SECONDS = float(os.getenv("PRICING_PREFLIGHT_TIMEOUT_SECONDS", "2.5"))
BILLING_PREFLIGHT_TIMEOUT_SECONDS = float(os.getenv("BILLING_PREFLIGHT_TIMEOUT_SECONDS", "6.0"))
MODEL_CACHE_WARMUP_TIMEOUT_SECONDS = float(os.getenv("MODEL_CACHE_WARMUP_TIMEOUT_SECONDS", "1.5"))
BOOT_WARMUP_WATCHDOG_SECONDS = float(os.getenv("BOOT_WARMUP_WATCHDOG_SECONDS", "2.0"))
BOOT_WARMUP_BUDGET_SECONDS = float(os.getenv("BOOT_WARMUP_BUDGET_SECONDS", "3.0"))

_GEN_TYPE_MENU_WARMUP_STATE: Dict[str, Any] = {
    "task": None,
    "last_success_ts": None,
    "last_counts": None,
    "last_outcome": None,
}
_BOOT_WARMUP_STATE: Dict[str, bool] = {
    "done": False,
    "cancelled": False,
    "watchdog_stopped": False,
    "budget_exceeded": False,
}


async def _load_gen_type_menu_warmup_cache() -> Optional[Dict[str, Any]]:
    cache_path = Path(GEN_TYPE_MENU_WARMUP_CACHE_PATH)

    def _load() -> Optional[Dict[str, Any]]:
        if not cache_path.exists():
            return None
        try:
            with cache_path.open("r", encoding="utf-8") as handle:
                payload = json.load(handle)
            if not isinstance(payload, dict):
                return None
            return payload
        except Exception:
            return None

    return await asyncio.to_thread(_load)


async def _persist_gen_type_menu_warmup_cache(payload: Dict[str, Any]) -> None:
    cache_path = Path(GEN_TYPE_MENU_WARMUP_CACHE_PATH)

    def _write() -> None:
        cache_path.parent.mkdir(parents=True, exist_ok=True)
        with cache_path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, ensure_ascii=False)

    await asyncio.to_thread(_write)


def _get_generation_types_cached() -> Optional[List[str]]:
    cached_models = get_models_cached_only()
    if cached_models is None:
        return None
    from app.models.registry import _model_type_to_generation_type

    model_types = sorted({model.get("model_type", "unknown") for model in cached_models if model})
    return [_model_type_to_generation_type(model_type) for model_type in model_types]


async def warm_generation_type_menu_cache(
    *,
    correlation_id: str = "BOOT",
    timeout_s: Optional[float] = None,
    warmup_fn: Optional[Callable[[], Awaitable[Dict[str, Any]]]] = None,
    retry_attempts: Optional[int] = None,
    cache_ttl_seconds: Optional[float] = None,
    force: bool = False,
) -> None:
    global GEN_TYPE_MENU_WARMUP_DEGRADED
    timeout = GEN_TYPE_MENU_WARMUP_TIMEOUT_SECONDS if timeout_s is None else timeout_s
    cache_ttl = GEN_TYPE_MENU_WARMUP_CACHE_TTL_SECONDS if cache_ttl_seconds is None else cache_ttl_seconds
    attempts = GEN_TYPE_MENU_WARMUP_RETRY_ATTEMPTS if retry_attempts is None else retry_attempts
    start = time.monotonic()
    deadline = start + timeout
    now = time.monotonic()
    current_task = asyncio.current_task()
    if (
        warmup_fn is None
        and not force
        and _GEN_TYPE_MENU_WARMUP_STATE.get("last_success_ts") is not None
        and (now - _GEN_TYPE_MENU_WARMUP_STATE["last_success_ts"]) < cache_ttl
    ):
        log_structured_event(
            correlation_id=correlation_id,
            action="GEN_TYPE_MENU_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="skip",
            param={"reason": "cache_fresh", "cache_ttl_s": cache_ttl},
        )
        return
    if warmup_fn is None and not force:
        disk_cache = await _load_gen_type_menu_warmup_cache()
        if disk_cache and isinstance(disk_cache.get("counts"), dict):
            cached_at = disk_cache.get("cached_at_ts")
            if isinstance(cached_at, (int, float)) and (now - cached_at) < cache_ttl:
                _GEN_TYPE_MENU_WARMUP_STATE["last_success_ts"] = cached_at
                _GEN_TYPE_MENU_WARMUP_STATE["last_counts"] = disk_cache.get("counts")
                _GEN_TYPE_MENU_WARMUP_STATE["last_outcome"] = "cache"
                log_structured_event(
                    correlation_id=correlation_id,
                    action="GEN_TYPE_MENU_WARMUP",
                    action_path="boot:warmup",
                    stage="BOOT",
                    outcome="skip",
                    param={"reason": "cache_disk_fresh", "cache_ttl_s": cache_ttl},
                )
                return
    in_flight = _GEN_TYPE_MENU_WARMUP_STATE.get("task")
    if warmup_fn is None and not force and in_flight and not in_flight.done():
        log_structured_event(
            correlation_id=correlation_id,
            action="GEN_TYPE_MENU_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="skip",
            param={"reason": "in_flight"},
        )
        return
    if current_task is not None:
        _GEN_TYPE_MENU_WARMUP_STATE["task"] = current_task
    log_structured_event(
        correlation_id=correlation_id,
        action="GEN_TYPE_MENU_WARMUP",
        action_path="boot:warmup",
        stage="BOOT",
        outcome="start",
        param={"timeout_s": timeout},
    )

    async def _warmup() -> Dict[str, Any]:
        if warmup_fn is not None:
            return await warmup_fn()

        cached_types = _get_generation_types_cached()
        if cached_types is None:
            return {"skipped": "models_cache_empty"}

        counts: Dict[str, Any] = {}
        per_gen_type_ms: Dict[str, int] = {}
        slow_gen_types: List[str] = []
        cache_hits = 0
        cache_misses = 0

        queue: asyncio.Queue[str] = asyncio.Queue()
        for gen_type in cached_types:
            queue.put_nowait(gen_type)

        max_workers = max(1, min(GEN_TYPE_MENU_WARMUP_CONCURRENCY, len(cached_types)))

        async def _worker() -> None:
            nonlocal cache_hits, cache_misses
            while True:
                try:
                    gen_type = queue.get_nowait()
                except asyncio.QueueEmpty:
                    return
                try:
                    if asyncio.current_task() and asyncio.current_task().cancelled():
                        return
                    start_gen = time.monotonic()
                    try:
                        logger.info("GEN_TYPE_MENU_WARMUP_START gen_type=%s correlation_id=%s", gen_type, correlation_id)
                        models, cache_status = await asyncio.to_thread(
                            get_visible_models_by_generation_type_cached,
                            gen_type,
                            allow_api=False,  # Boot warmup: NO API calls!
                        )
                        logger.info("GEN_TYPE_MENU_WARMUP_DONE gen_type=%s models=%d status=%s elapsed_ms=%d correlation_id=%s", 
                                   gen_type, len(models), cache_status, int((time.monotonic() - start_gen) * 1000), correlation_id)
                    except asyncio.CancelledError:
                        raise
                    except Exception:
                        models = []
                        cache_status = "error"
                    elapsed_ms = int((time.monotonic() - start_gen) * 1000)
                    per_gen_type_ms[gen_type] = elapsed_ms
                    if elapsed_ms >= GEN_TYPE_MENU_WARMUP_SLOW_MS:
                        slow_gen_types.append(gen_type)
                    counts[gen_type] = {"count": len(models), "cache": cache_status}
                    if cache_status == "hit":
                        cache_hits += 1
                    else:
                        cache_misses += 1
                finally:
                    queue.task_done()

        tasks = [asyncio.create_task(_worker()) for _ in range(max_workers)]
        timeout_triggered = False
        done, pending = await asyncio.wait(tasks, timeout=timeout)
        if pending:
            timeout_triggered = True
            for task in pending:
                task.cancel()
                task.add_done_callback(
                    lambda t: _suppress_task_exceptions(t, action="gen_type_menu_warmup_timeout")
                )
            # Short timeout on gather - asyncio.to_thread may not cancel instantly
            try:
                await asyncio.wait_for(
                    asyncio.gather(*pending, return_exceptions=True),
                    timeout=0.5,
                )
            except asyncio.TimeoutError:
                pass  # Don't block event loop waiting for threads
        missing = set(cached_types) - set(counts.keys())
        if missing:
            for gen_type in missing:
                counts[gen_type] = {"count": None, "cache": "timeout" if timeout_triggered else "skipped"}
                per_gen_type_ms[gen_type] = int(timeout * 1000)
        return {
            "counts": counts,
            "per_gen_type_ms": per_gen_type_ms,
            "cache_hits": cache_hits,
            "cache_misses": cache_misses,
            "slow_gen_types": slow_gen_types,
            "partial": timeout_triggered,
        }

    try:
        last_exc: Optional[BaseException] = None
        for attempt in range(1, max(1, attempts) + 1):
            remaining = deadline - time.monotonic()
            if remaining <= 0:
                elapsed_ms_real = int((time.monotonic() - start) * 1000)
                log_structured_event(
                    correlation_id=correlation_id,
                    action="GEN_TYPE_MENU_WARMUP",
                    action_path="boot:warmup",
                    stage="BOOT",
                    outcome="skipped_deadline",
                    param={"elapsed_ms": elapsed_ms_real, "timeout_s": timeout},
                )
                logger.info(
                    "GEN_TYPE_MENU_WARMUP_SKIP elapsed_ms=%s reason=deadline correlation_id=%s",
                    elapsed_ms_real,
                    correlation_id,
                )
                return
            attempt_start = time.monotonic()
            attempt_start_ms = int(time.time() * 1000)
            warmup_task = asyncio.create_task(_warmup())
            try:
                counts = await asyncio.wait_for(warmup_task, timeout=min(timeout, remaining))
                if not isinstance(counts, dict):
                    counts = {}
                if "counts" not in counts and "skipped" not in counts:
                    counts = {
                        "counts": counts,
                        "per_gen_type_ms": {},
                        "cache_hits": 0,
                        "cache_misses": 0,
                        "slow_gen_types": [],
                        "partial": False,
                    }
                elapsed_ms_real = int((time.monotonic() - attempt_start) * 1000)
                total_elapsed_ms = int((time.monotonic() - start) * 1000)
                if counts.get("skipped"):
                    log_structured_event(
                        correlation_id=correlation_id,
                        action="GEN_TYPE_MENU_WARMUP",
                        action_path="boot:warmup",
                        stage="BOOT",
                        outcome="skip",
                        param={
                            "elapsed_ms": elapsed_ms_real,
                            "elapsed_total_ms": total_elapsed_ms,
                            "reason": counts.get("skipped"),
                            "started_at_ms": attempt_start_ms,
                            "now_ms": int(time.time() * 1000),
                        },
                    )
                    logger.info(
                        "GEN_TYPE_MENU_WARMUP_SKIP elapsed_ms=%s reason=%s correlation_id=%s",
                        elapsed_ms_real,
                        counts.get("skipped"),
                        correlation_id,
                    )
                    return
                GEN_TYPE_MENU_WARMUP_DEGRADED = bool(counts.get("partial"))
                _GEN_TYPE_MENU_WARMUP_STATE["last_success_ts"] = time.monotonic()
                _GEN_TYPE_MENU_WARMUP_STATE["last_counts"] = counts.get("counts")
                _GEN_TYPE_MENU_WARMUP_STATE["last_outcome"] = "partial" if counts.get("partial") else "done"
                try:
                    await _persist_gen_type_menu_warmup_cache(
                        {
                            "cached_at_ts": _GEN_TYPE_MENU_WARMUP_STATE["last_success_ts"],
                            "counts": counts.get("counts"),
                        }
                    )
                except Exception as exc:
                    logger.debug("GEN_TYPE_MENU_WARMUP_CACHE_WRITE_FAILED error=%s", exc, exc_info=True)
                log_structured_event(
                    correlation_id=correlation_id,
                    action="GEN_TYPE_MENU_WARMUP",
                    action_path="boot:warmup",
                    stage="BOOT",
                    outcome="partial" if counts.get("partial") else "done",
                    param={
                        "elapsed_ms": elapsed_ms_real,
                        "elapsed_ms_real": elapsed_ms_real,
                        "warmup_total_ms": elapsed_ms_real,
                        "elapsed_total_ms": total_elapsed_ms,
                        "started_at_ms": attempt_start_ms,
                        "now_ms": int(time.time() * 1000),
                        "counts": counts.get("counts"),
                        "per_gen_type_ms": counts.get("per_gen_type_ms"),
                        "cache_hits": counts.get("cache_hits"),
                        "cache_misses": counts.get("cache_misses"),
                        "slow_gen_types": counts.get("slow_gen_types"),
                    },
                )
                logger.info("‚úÖ GEN_TYPE_MENU cache ready in %sms: %s", elapsed_ms_real, counts.get("counts"))
                return
            except asyncio.TimeoutError as exc:
                last_exc = exc
                warmup_task.cancel()
                warmup_task.add_done_callback(
                    lambda t: _suppress_task_exceptions(t, action="gen_type_menu_warmup_cancel")
                )
                GEN_TYPE_MENU_WARMUP_DEGRADED = True
                elapsed_ms_real = int((time.monotonic() - attempt_start) * 1000)
                total_elapsed_ms = int((time.monotonic() - start) * 1000)
                logger.info(
                    "GEN_TYPE_MENU_WARMUP_TIMEOUT elapsed_ms=%s elapsed_total_ms=%s timeout_s=%s "
                    "attempt=%s attempts_total=%s correlation_id=%s",
                    elapsed_ms_real,
                    total_elapsed_ms,
                    timeout,
                    attempt,
                    attempts,
                    correlation_id,
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    action="GEN_TYPE_MENU_WARMUP",
                    action_path="boot:warmup",
                    stage="BOOT",
                    outcome="skipped_deadline",
                    error_code="GEN_TYPE_MENU_WARMUP_TIMEOUT",
                    param={
                        "elapsed_ms": elapsed_ms_real,
                        "elapsed_ms_real": elapsed_ms_real,
                        "elapsed_total_ms": total_elapsed_ms,
                        "started_at_ms": attempt_start_ms,
                        "now_ms": int(time.time() * 1000),
                        "timeout_s": timeout,
                        "attempt": attempt,
                        "attempts_total": attempts,
                    },
                )
                return
            except Exception as exc:
                last_exc = exc
                warmup_task.cancel()
                warmup_task.add_done_callback(
                    lambda t: _suppress_task_exceptions(t, action="gen_type_menu_warmup_error")
                )
                logger.info(
                    "GEN_TYPE_MENU_WARMUP_FAILED attempt=%s error=%s correlation_id=%s",
                    attempt,
                    exc,
                    correlation_id,
                )
                if attempt >= max(1, attempts):
                    return
    except asyncio.CancelledError:
        elapsed_ms_real = int((time.monotonic() - start) * 1000)
        logger.info(
            "GEN_TYPE_MENU_WARMUP_CANCELLED elapsed_ms=%s correlation_id=%s",
            elapsed_ms_real,
            correlation_id,
        )
        log_structured_event(
            correlation_id=correlation_id,
            action="GEN_TYPE_MENU_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="cancelled",
            param={"elapsed_ms": elapsed_ms_real},
        )
        return
    finally:
        if _GEN_TYPE_MENU_WARMUP_STATE.get("task") is current_task:
            _GEN_TYPE_MENU_WARMUP_STATE["task"] = None


async def _warm_models_cache(
    *,
    correlation_id: str = "BOOT",
    timeout_s: Optional[float] = None,
) -> None:
    timeout = MODEL_CACHE_WARMUP_TIMEOUT_SECONDS if timeout_s is None else timeout_s
    start = time.monotonic()
    from app.models.registry import get_models_sync_fast, _model_source

    try:
        warmup_models = await asyncio.wait_for(asyncio.to_thread(get_models_sync_fast), timeout=timeout)
        elapsed_ms = int((time.monotonic() - start) * 1000)
        if warmup_models:
            logger.info(
                "‚úÖ Models cache warmed up: %s models loaded in %sms (source=%s) correlation_id=%s",
                len(warmup_models),
                elapsed_ms,
                _model_source,
                correlation_id,
            )
            log_structured_event(
                correlation_id=correlation_id,
                action="MODELS_CACHE_WARMUP",
                action_path="boot:warmup",
                stage="BOOT",
                outcome="done",
                param={
                    "warmup_total_ms": elapsed_ms,
                    "model_count": len(warmup_models),
                    "source": _model_source,
                },
            )
        else:
            logger.info(
                "MODELS_CACHE_WARMUP_SKIP elapsed_ms=%s reason=empty_cache correlation_id=%s",
                elapsed_ms,
                correlation_id,
            )
            log_structured_event(
                correlation_id=correlation_id,
                action="MODELS_CACHE_WARMUP",
                action_path="boot:warmup",
                stage="BOOT",
                outcome="skip",
                param={"warmup_total_ms": elapsed_ms, "reason": "empty_cache"},
            )
    except asyncio.TimeoutError:
        elapsed_ms = int((time.monotonic() - start) * 1000)
        logger.info(
            "MODELS_CACHE_WARMUP_TIMEOUT elapsed_ms=%s timeout_s=%s correlation_id=%s",
            elapsed_ms,
            timeout,
            correlation_id,
        )
        log_structured_event(
            correlation_id=correlation_id,
            action="MODELS_CACHE_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="timeout",
            error_code="MODELS_CACHE_WARMUP_TIMEOUT",
            param={"warmup_total_ms": elapsed_ms, "timeout_s": timeout},
        )
    except Exception:
        logger.info("MODELS_CACHE_WARMUP_FAILED correlation_id=%s", correlation_id, exc_info=True)
        log_structured_event(
            correlation_id=correlation_id,
            action="MODELS_CACHE_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="failed",
        )


async def _warm_user_data_caches(*, correlation_id: str = "BOOT", timeout_per_file: float = 1.0) -> None:
    """Load user data caches (languages, gifts, free generations) at boot.
    
    This prevents blocking sync calls during request handling.
    Each file load has a timeout to prevent blocking boot.
    """
    global _free_generations_cache, _free_generations_cache_time
    
    try:
        from app.storage.factory import get_storage
        storage = get_storage()
        if not storage:
            logger.info("BOOT_CACHE_SKIPPED reason=no_storage")
            return
        
        # Load user languages with timeout
        try:
            languages = await asyncio.wait_for(
                storage.read_json_file("user_languages.json", {}),
                timeout=timeout_per_file
            )
            for user_key, lang in languages.items():
                _user_language_cache[user_key] = lang
                _user_language_cache_time[user_key] = time.time()
            logger.info("BOOT_CACHE_LOADED cache=user_languages count=%d", len(languages))
        except asyncio.TimeoutError:
            logger.warning("BOOT_CACHE_TIMEOUT cache=user_languages timeout_s=%.1f", timeout_per_file)
        except Exception as e:
            logger.warning("BOOT_CACHE_FAILED cache=user_languages error=%s", e)
        
        # Load gift claimed with timeout
        try:
            claimed = await asyncio.wait_for(
                storage.read_json_file("gift_claimed.json", {}),
                timeout=timeout_per_file
            )
            for user_key, status in claimed.items():
                if status:
                    _gift_claimed_cache[user_key] = True
            logger.info("BOOT_CACHE_LOADED cache=gift_claimed count=%d", len(claimed))
        except asyncio.TimeoutError:
            logger.warning("BOOT_CACHE_TIMEOUT cache=gift_claimed timeout_s=%.1f", timeout_per_file)
        except Exception as e:
            logger.warning("BOOT_CACHE_FAILED cache=gift_claimed error=%s", e)
        
        # Load free generations with timeout
        try:
            free_gens = await asyncio.wait_for(
                storage.read_json_file("free_generations.json", {}),
                timeout=timeout_per_file
            )
            _free_generations_cache = free_gens
            _free_generations_cache_time = time.time()
            logger.info("BOOT_CACHE_LOADED cache=free_generations count=%d", len(free_gens))
        except asyncio.TimeoutError:
            logger.warning("BOOT_CACHE_TIMEOUT cache=free_generations timeout_s=%.1f", timeout_per_file)
        except Exception as e:
            logger.warning("BOOT_CACHE_FAILED cache=free_generations error=%s", e)
            
    except Exception as e:
        logger.warning("BOOT_CACHE_WARMUP_FAILED error=%s", e)


async def _run_boot_warmups(*, correlation_id: str = "BOOT") -> None:
    start = time.monotonic()
    _BOOT_WARMUP_STATE["done"] = False
    _BOOT_WARMUP_STATE["cancelled"] = False
    _BOOT_WARMUP_STATE["watchdog_stopped"] = False
    _BOOT_WARMUP_STATE["budget_exceeded"] = False
    await asyncio.sleep(0)
    log_structured_event(
        correlation_id=correlation_id,
        action="BOOT_WARMUP",
        action_path="boot:warmup",
        stage="BOOT",
        outcome="start",
        param={
            "watchdog_s": BOOT_WARMUP_WATCHDOG_SECONDS,
            "budget_s": BOOT_WARMUP_BUDGET_SECONDS,
        },
    )
    # Load user data caches first (fast, non-blocking)
    user_data_task = asyncio.create_task(_warm_user_data_caches(correlation_id=correlation_id))
    models_task = asyncio.create_task(_warm_models_cache(correlation_id=correlation_id))
    gen_type_task = asyncio.create_task(
        warm_generation_type_menu_cache(
            correlation_id=correlation_id,
            retry_attempts=1,
            cache_ttl_seconds=GEN_TYPE_MENU_WARMUP_CACHE_TTL_SECONDS,
        )
    )
    try:
        await asyncio.wait_for(
            asyncio.gather(user_data_task, models_task, gen_type_task, return_exceptions=True),
            timeout=BOOT_WARMUP_BUDGET_SECONDS,
        )
        elapsed_ms = int((time.monotonic() - start) * 1000)
        _BOOT_WARMUP_STATE["done"] = True
        log_structured_event(
            correlation_id=correlation_id,
            action="BOOT_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="done",
            param={"elapsed_ms": elapsed_ms},
        )
    except asyncio.TimeoutError:
        elapsed_ms = int((time.monotonic() - start) * 1000)
        _BOOT_WARMUP_STATE["budget_exceeded"] = True
        logger.info(
            "BOOT_WARMUP_BUDGET_EXCEEDED elapsed_ms=%s budget_s=%s correlation_id=%s",
            elapsed_ms,
            BOOT_WARMUP_BUDGET_SECONDS,
            correlation_id,
        )
        for task in (user_data_task, models_task, gen_type_task):
            if task and not task.done():
                task.cancel()
        # Don't await cancelled tasks - they may block on asyncio.to_thread
        log_structured_event(
            correlation_id=correlation_id,
            action="BOOT_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="skipped_deadline",
            param={"elapsed_ms": elapsed_ms, "budget_s": BOOT_WARMUP_BUDGET_SECONDS},
        )
    except asyncio.CancelledError:
        elapsed_ms = int((time.monotonic() - start) * 1000)
        _BOOT_WARMUP_STATE["cancelled"] = True
        logger.info("BOOT_WARMUP_CANCELLED elapsed_ms=%s correlation_id=%s", elapsed_ms, correlation_id)
        log_structured_event(
            correlation_id=correlation_id,
            action="BOOT_WARMUP",
            action_path="boot:warmup",
            stage="BOOT",
            outcome="cancelled",
            param={"elapsed_ms": elapsed_ms},
        )
        for task in (user_data_task, models_task, gen_type_task):
            if task and not task.done():
                task.cancel()
        # Don't await cancelled tasks - they may block on asyncio.to_thread


def start_boot_warmups(*, correlation_id: str = "BOOT") -> asyncio.Task:
    return _create_background_task(
        _run_boot_warmups(correlation_id=correlation_id),
        action="boot_warmups",
    )

def get_models_by_category_from_registry(category: str) -> List[Dict[str, Any]]:
    """–ü–æ–ª—É—á–∞–µ—Ç –º–æ–¥–µ–ª–∏ –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
    models = get_models_static_only()
    return filter_visible_models([m for m in models if m.get('category') == category])

def get_categories_from_registry() -> List[str]:
    """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞"""
    models = get_models_static_only()
    categories = set()
    for model in models:
        cat = model.get('category')
        if cat:
            categories.add(cat)
    return sorted(list(categories))


async def _safe_edit_or_reply(
    query: Optional[CallbackQuery],
    text: str,
    *,
    reply_markup: Optional[InlineKeyboardMarkup] = None,
    parse_mode: str = "HTML",
) -> bool:
    if not query or not query.message:
        return False
    try:
        await query.edit_message_text(
            text,
            reply_markup=reply_markup,
            parse_mode=parse_mode,
        )
        return True
    except BadRequest as exc:
        if "Message is not modified" in str(exc):
            return True
        logger.debug("Failed to edit message: %s", exc)
    except Exception as exc:
        logger.debug("Failed to edit message: %s", exc)
    try:
        await query.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode=parse_mode,
        )
        return True
    except Exception as exc:
        logger.debug("Failed to reply with message: %s", exc)
        return False


async def _load_with_timeout(
    label: str,
    *,
    correlation_id: Optional[str],
    user_id: Optional[int],
    gen_type: Optional[str],
    func: Any,
    timeout_seconds: float = GEN_TYPE_MENU_TIMEOUT_SECONDS,
) -> Any:
    start_ts = time.monotonic()
    try:
        result = await asyncio.wait_for(asyncio.to_thread(func), timeout=timeout_seconds)
        duration_ms = int((time.monotonic() - start_ts) * 1000)
        logger.info(
            "GEN_TYPE_MENU step=%s status=ok duration_ms=%s corr_id=%s user_id=%s gen_type=%s",
            label,
            duration_ms,
            correlation_id,
            user_id,
            gen_type,
        )
        return result
    except asyncio.TimeoutError:
        duration_ms = int((time.monotonic() - start_ts) * 1000)
        logger.warning(
            "GEN_TYPE_MENU step=%s status=timeout duration_ms=%s corr_id=%s user_id=%s gen_type=%s",
            label,
            duration_ms,
            correlation_id,
            user_id,
            gen_type,
        )
        raise
    except Exception as exc:
        duration_ms = int((time.monotonic() - start_ts) * 1000)
        logger.warning(
            "GEN_TYPE_MENU step=%s status=error duration_ms=%s corr_id=%s user_id=%s gen_type=%s error=%s",
            label,
            duration_ms,
            correlation_id,
            user_id,
            gen_type,
            exc,
        )
        raise


async def _render_gen_type_menu(
    *,
    query: Optional[CallbackQuery],
    user_id: Optional[int],
    gen_type: str,
    correlation_id: Optional[str],
    update_id: Optional[int],
    notice_text: Optional[str] = None,
) -> int:
    if not query or not query.message:
        return ConversationHandler.END
    user_lang = get_user_language(user_id) if user_id else "ru"
    try:
        gen_info = await _load_with_timeout(
            "get_info",
            correlation_id=correlation_id,
            user_id=user_id,
            gen_type=gen_type,
            func=lambda: get_generation_type_info(gen_type),
        )
        models_start = time.monotonic()
        models, cache_status = get_visible_models_by_generation_type_cached(gen_type)
        models_duration_ms = int((time.monotonic() - models_start) * 1000)
        logger.info(
            "GEN_TYPE_MENU step=get_models status=ok duration_ms=%s corr_id=%s user_id=%s gen_type=%s "
            "cache=%s io_detected=%s models_count=%s",
            models_duration_ms,
            correlation_id,
            user_id,
            gen_type,
            cache_status,
            False,
            len(models),
        )
    except asyncio.TimeoutError:
        error_text = (
            "‚ö†Ô∏è <b>–ú–µ–Ω—é –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –¥–æ–ª—å—à–µ –æ–±—ã—á–Ω–æ–≥–æ</b>\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –æ—Ç–∫—Ä–æ–π—Ç–µ –º–µ–Ω—é –ø–æ–∑–∂–µ."
            if user_lang == "ru"
            else "‚ö†Ô∏è <b>Menu is taking longer than usual</b>\n\nPlease try again in a moment."
        )
        reply_markup = build_back_to_menu_keyboard(user_lang, back_callback="show_models")
        await _safe_edit_or_reply(query, error_text, reply_markup=reply_markup)
        return ConversationHandler.END
    except Exception:
        error_text = (
            "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–Ω—é</b>\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."
            if user_lang == "ru"
            else "‚ùå <b>Failed to load menu</b>\n\nPlease try again or return to the main menu."
        )
        reply_markup = build_back_to_menu_keyboard(user_lang, back_callback="show_models")
        await _safe_edit_or_reply(query, error_text, reply_markup=reply_markup)
        return ConversationHandler.END

    if not models:
        error_text = t('msg_gen_type_no_models', lang=user_lang)
        reply_markup = build_back_to_menu_keyboard(user_lang, back_callback="show_models")
        await _safe_edit_or_reply(query, error_text, reply_markup=reply_markup, parse_mode="HTML")
        return ConversationHandler.END

    try:
        is_admin = await _load_with_timeout(
            "get_admin",
            correlation_id=correlation_id,
            user_id=user_id,
            gen_type=gen_type,
            func=lambda: get_is_admin(user_id),
        )
    except Exception:
        is_admin = False

    remaining_free = await get_user_free_generations_remaining(user_id)
    free_counter_line = ""
    try:
        free_counter_line = await get_free_counter_line(
            user_id,
            user_lang=user_lang,
            correlation_id=correlation_id,
            action_path="gen_type_menu",
        )
    except Exception as exc:
        logger.warning("Failed to resolve free counter line: %s", exc)

    gen_type_key = f'gen_type_{gen_type.replace("-", "_")}'
    gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', gen_type))
    gen_desc_key = f'gen_type_desc_{gen_type.replace("-", "_")}'
    gen_type_description = t(gen_desc_key, lang=user_lang, default=gen_info.get('description', ''))

    gen_type_text = (
        f"{t('msg_gen_type_title', lang=user_lang, name=gen_type_name)}\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"{t('msg_gen_type_description', lang=user_lang, description=gen_type_description)}\n\n"
    )

    if remaining_free > 0 and gen_type == "text-to-image":
        gen_type_text += (
            f"{t('msg_gen_type_free', lang=user_lang, remaining=remaining_free)}\n"
            f"üí° {t('btn_invite_friend', lang=user_lang, bonus=REFERRAL_BONUS_GENERATIONS)}\n\n"
        )

    gen_type_text += (
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"{t('msg_gen_type_models_available', lang=user_lang, count=len(models))}\n\n"
        f"{t('msg_gen_type_select_model', lang=user_lang)}"
    )
    gen_type_text = _append_free_counter_text(gen_type_text, free_counter_line)

    if notice_text:
        gen_type_text = f"{notice_text}\n\n{gen_type_text}"

    keyboard: List[List[InlineKeyboardButton]] = []
    if gen_type == "text-to-image":
        button_text = (
            f"üÜì FAST TOOLS ({remaining_free}/{FREE_GENERATIONS_PER_DAY})"
            if user_lang == "ru"
            else f"üÜì FAST TOOLS ({remaining_free}/{FREE_GENERATIONS_PER_DAY})"
        )
        keyboard.append([InlineKeyboardButton(button_text, callback_data="free_tools")])
        keyboard.append([])

    model_rows = []
    for i, model in enumerate(models):
        model_name = model.get('name', model.get('id', 'Unknown'))
        model_emoji = model.get('emoji', 'ü§ñ')
        model_id = model.get('id')

        from app.pricing.price_ssot import get_min_price
        min_price = get_min_price(model_id)

        if min_price is not None:
            price_formatted = format_rub_amount(float(min_price))
            button_text = f"{model_emoji} {model_name} ‚Ä¢ {price_formatted}"
        else:
            button_text = f"{model_emoji} {model_name}"

        if len(button_text.encode("utf-8")) > 60:
            max_name_length = 25 if min_price else 40
            truncated = model_name[:max_name_length].rstrip()
            if min_price is not None:
                button_text = f"{model_emoji} {truncated}... ‚Ä¢ {price_formatted}"
            else:
                button_text = f"{model_emoji} {truncated}..."

        callback_data = f"select_model:{model_id}"
        if len(callback_data.encode('utf-8')) > 64:
            logger.error(
                "Callback data too long for model %s: %s bytes",
                model_id,
                len(callback_data.encode('utf-8')),
            )
            callback_data = f"sel:{model_id[:50]}"

        if i % 2 == 0:
            model_rows.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
        else:
            if model_rows:
                model_rows[-1].append(InlineKeyboardButton(button_text, callback_data=callback_data))
            else:
                model_rows.append([InlineKeyboardButton(button_text, callback_data=callback_data)])

    keyboard.extend(model_rows)
    keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])

    try:
        await query.edit_message_text(
            gen_type_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML',
        )
    except BadRequest as exc:
        if "Message is not modified" in str(exc):
            await query.answer()
            return SELECTING_MODEL
        logger.error("Error editing message in gen_type: %s", exc, exc_info=True)
        try:
            await query.message.reply_text(
                gen_type_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML',
            )
        except Exception as e2:
            logger.error("Error sending new message in gen_type: %s", e2, exc_info=True)
            await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)

    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=query.message.chat_id if query and query.message else None,
        update_id=update_id,
        action="GEN_TYPE_MENU_RENDERED",
        action_path="gen_type_menu",
        gen_type=gen_type,
        outcome="success",
        param={
            "model_count": len(models),
            "is_admin": is_admin,
        },
    )
    return SELECTING_MODEL


async def _get_registry_model_entry(
    model_id: str,
    *,
    correlation_id: Optional[str],
    user_id: Optional[int],
    gen_type: Optional[str],
) -> Optional[Dict[str, Any]]:
    try:
        models = await _load_with_timeout(
            "registry_lookup",
            correlation_id=correlation_id,
            user_id=user_id,
            gen_type=gen_type,
            func=get_models_sync,
        )
    except Exception:
        return None
    return next((model for model in models if model.get("id") == model_id), None)


def _determine_primary_input(
    model_info: Dict[str, Any],
    input_params: Dict[str, Any],
) -> Optional[Dict[str, str]]:
    """Determine which input should be requested first based on model_type + schema."""
    model_type = (model_info.get("model_mode") or model_info.get("model_type") or "").lower()
    image_param = None
    if "image_input" in input_params:
        image_param = "image_input"
    elif "image_urls" in input_params:
        image_param = "image_urls"
    audio_param = None
    if "audio_input" in input_params:
        audio_param = "audio_input"
    elif "audio_url" in input_params:
        audio_param = "audio_url"
    video_param = None
    if "video_input" in input_params:
        video_param = "video_input"
    elif "video_url" in input_params:
        video_param = "video_url"
    elif "video_urls" in input_params:
        video_param = "video_urls"

    if model_type in {"image_to_video", "image_to_image", "image_edit", "outpaint", "upscale", "video_upscale"}:
        if image_param:
            return {"type": "image", "param": image_param}
        for param_name, param_info in input_params.items():
            if _get_media_kind(param_name) == "image" and param_info.get("required", False):
                return {"type": "image", "param": param_name}
    if model_type in {"speech_to_text", "audio_to_audio", "speech_to_video"}:
        if audio_param:
            return {"type": "audio", "param": audio_param}
    if model_type in {"video_editing"}:
        if video_param:
            return {"type": "video", "param": video_param}
    if model_type in {"text_to_video", "text_to_image", "text_to_speech", "text_to_audio", "text"}:
        if "prompt" in input_params:
            return {"type": "prompt", "param": "prompt"}
        if "text" in input_params:
            return {"type": "prompt", "param": "text"}

    # Fallback for unknown types: prefer required media, then prompt
    if image_param and input_params.get(image_param, {}).get("required", False):
        return {"type": "image", "param": image_param}
    if audio_param and input_params.get(audio_param, {}).get("required", False):
        return {"type": "audio", "param": audio_param}
    if video_param and input_params.get(video_param, {}).get("required", False):
        return {"type": "video", "param": video_param}
    if "prompt" in input_params:
        return {"type": "prompt", "param": "prompt"}
    if "text" in input_params:
        return {"type": "prompt", "param": "text"}

    return None


def _normalize_enum_values(param_info: Dict[str, Any]) -> List[Any]:
    enum_values = param_info.get("enum") or param_info.get("values")
    if enum_values is None:
        return []
    if isinstance(enum_values, str):
        return [enum_values]
    if isinstance(enum_values, dict):
        return list(enum_values.values())
    normalized: List[Any] = []
    for value in enum_values:
        if isinstance(value, dict):
            normalized.append(value.get("value") or value.get("id") or value.get("name"))
        else:
            normalized.append(value)
    return [value for value in normalized if value is not None]


def _get_media_kind(param_name: str) -> Optional[str]:
    name = param_name.lower()
    if any(key in name for key in ["image", "photo", "mask"]):
        return "image"
    if "video" in name:
        return "video"
    if any(key in name for key in ["audio", "voice"]):
        return "audio"
    if any(key in name for key in ["document", "file"]):
        return "document"
    return None


def _is_primary_media_input_param(param_name: str) -> bool:
    normalized = param_name.lower()
    primary_media_inputs = {
        "image_input",
        "image_urls",
        "image_url",
        "video_input",
        "video_url",
        "audio_input",
        "audio_url",
        "document_input",
        "document_url",
        "file_input",
        "file_url",
    }
    if normalized in primary_media_inputs:
        return True
    if normalized.endswith("_input") or normalized.endswith("_url") or normalized.endswith("_urls"):
        return _get_media_kind(normalized) in {"image", "video", "audio", "document"}
    return False


def _should_force_media_required(model_type: str, media_kind: str) -> bool:
    normalized = (model_type or "").lower()
    if media_kind == "image":
        return normalized in {
            "image_edit",
            "image_to_image",
            "image_to_video",
            "outpaint",
            "upscale",
            "video_upscale",
        }
    if media_kind == "video":
        return normalized in {"image_to_video", "video_upscale"}
    if media_kind == "audio":
        return normalized.startswith("audio_") or normalized in {"speech_to_text", "speech_to_video", "music"}
    if media_kind == "document":
        return normalized in {"document", "document_to_text"}
    return False


def _apply_media_required_overrides(
    model_spec: "ModelSpec",
    input_params: Dict[str, Any],
) -> tuple[Dict[str, Any], List[str], List[str]]:
    """Force media inputs to required when model type implies mandatory media."""
    import copy

    properties = copy.deepcopy(input_params or {})
    required = set(model_spec.schema_required or [])
    forced_required: List[str] = []
    model_type = (model_spec.model_type or model_spec.model_mode or "").lower()

    for param_name, param_info in properties.items():
        media_kind = _get_media_kind(param_name)
        if not media_kind or not _is_primary_media_input_param(param_name):
            continue
        if not _should_force_media_required(model_type, media_kind):
            continue
        if not param_info.get("required", False):
            param_info["required"] = True
            forced_required.append(param_name)
        required.add(param_name)

    return properties, sorted(required), forced_required


def _build_param_order(input_params: Dict[str, Any]) -> List[str]:
    media_params = []
    text_params = []
    required_params = []
    optional_params = []

    for param_name, param_info in input_params.items():
        is_required = param_info.get("required", False)
        media_kind = _get_media_kind(param_name)

        if media_kind:
            target = media_params if is_required else optional_params
            target.append(param_name)
            continue

        if param_name in {"prompt", "text"}:
            target = text_params if is_required else optional_params
            target.append(param_name)
            continue

        if is_required:
            required_params.append(param_name)
        else:
            optional_params.append(param_name)

    return media_params + text_params + required_params + optional_params


def _enum_values(param_info: Dict[str, Any]) -> List[Any]:
    enum_values = param_info.get("enum")
    if isinstance(enum_values, list):
        return enum_values
    choices = param_info.get("choices")
    if isinstance(choices, list):
        return choices
    return []


def _enum_allows(param_info: Dict[str, Any], value: Any) -> bool:
    enum_values = _enum_values(param_info)
    if not enum_values:
        return True
    candidates = [value, str(value)]
    try:
        candidates.append(int(value))
    except (TypeError, ValueError):
        pass
    return any(candidate in enum_values for candidate in candidates)


def _coerce_enum_value(param_info: Dict[str, Any], value: Any) -> Any:
    enum_values = _enum_values(param_info)
    if not enum_values:
        return value
    for candidate in (value, str(value)):
        if candidate in enum_values:
            return candidate
    try:
        int_value = int(value)
    except (TypeError, ValueError):
        int_value = None
    if int_value is not None and int_value in enum_values:
        return int_value
    return value


def _resolve_gen_type(model_spec: Optional["ModelSpec"], session_gen_type: Optional[str]) -> str:
    spec_type = ""
    if model_spec:
        spec_type = str(model_spec.model_type or model_spec.model_mode or model_spec.model_category or "")
    return (session_gen_type or spec_type or "").strip().lower()


def _is_visual_gen_type(gen_type: str) -> bool:
    normalized = (gen_type or "").lower()
    if not normalized:
        return False
    return "image" in normalized or "video" in normalized


def _resolve_unified_default(
    param_name: str,
    param_info: Dict[str, Any],
    *,
    model_spec: Optional["ModelSpec"],
    session_gen_type: Optional[str],
) -> Optional[Any]:
    required = bool(param_info.get("required"))
    gen_type = _resolve_gen_type(model_spec, session_gen_type)

    if param_name == "seed" and not required:
        # Seed –¥–æ–ª–∂–µ–Ω –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º –∏ –Ω–µ –ø–æ–¥—Å—Ç–∞–≤–ª—è—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        return None

    desired: Optional[Any] = None
    if param_name == "aspect_ratio" and _is_visual_gen_type(gen_type):
        desired = "9:16"
    elif param_name == "num_images":
        desired = 1

    if desired is not None:
        if not _enum_allows(param_info, desired):
            return param_info.get("default")
        return _coerce_enum_value(param_info, desired)

    return param_info.get("default")


def _apply_unified_param_defaults(
    input_params: Dict[str, Any],
    *,
    model_spec: Optional["ModelSpec"],
    session_gen_type: Optional[str],
) -> Dict[str, Any]:
    for param_name, param_info in input_params.items():
        if not isinstance(param_info, dict):
            continue
        default_value = _resolve_unified_default(
            param_name,
            param_info,
            model_spec=model_spec,
            session_gen_type=session_gen_type,
        )
        if default_value is None:
            continue
        if param_info.get("default") != default_value:
            param_info["default"] = default_value
    return input_params


def _is_image_only_model(properties: Dict[str, Any]) -> bool:
    if not properties:
        return False
    required_fields = [name for name, info in properties.items() if info.get("required", False)]
    if not required_fields:
        return False
    has_text = any(name in {"prompt", "text"} for name in required_fields)
    if has_text:
        return False
    return all(_get_media_kind(name) == "image" for name in required_fields)


def _first_required_media_param(properties: Dict[str, Any]) -> Optional[str]:
    for param_name, info in properties.items():
        if info.get("required", False) and _get_media_kind(param_name):
            return param_name
    return None


def _detect_ssot_conflicts(model_spec: "ModelSpec", properties_override: Optional[Dict[str, Any]] = None) -> list[str]:
    conflicts: list[str] = []
    model_type = (model_spec.model_type or "").lower()
    properties = properties_override or model_spec.schema_properties or {}
    required_media = [
        name for name, info in properties.items()
        if info.get("required", False) and _get_media_kind(name)
    ]
    if model_type in {"text_to_image", "text_to_video", "text_to_audio", "text_to_speech", "text"} and required_media:
        conflicts.append("SSOT_CONFLICT_TEXT_MODEL_REQUIRES_IMAGE")
    if model_type in {"image_edit", "image_to_image", "image_to_video", "outpaint", "upscale", "video_upscale"}:
        if not required_media:
            conflicts.append("SSOT_CONFLICT_IMAGE_MODEL_MISSING_IMAGE_INPUT")
    return conflicts


def _is_missing_media_error(error: str) -> bool:
    if not error:
        return False
    lowered = error.lower()
    if "image" in lowered or "mask" in lowered:
        return any(token in lowered for token in ["required", "missing", "must", "need"])
    return False


def _extract_missing_param(error_message: Optional[str], properties: Dict[str, Any]) -> Optional[str]:
    if not error_message or not properties:
        return None
    lowered = error_message.lower()
    for param_name in properties:
        if param_name.lower() in lowered:
            return param_name
        spaced = param_name.replace("_", " ").lower()
        if spaced and spaced in lowered:
            return param_name
    return None


def _collect_missing_required_media(session: Dict[str, Any]) -> List[str]:
    properties = session.get("properties", {})
    params = session.get("params", {})
    required = set(session.get("required", []))
    model_type = session.get("model_type") or session.get("model_mode") or session.get("gen_type") or ""
    missing: List[str] = []
    for param_name, param_info in properties.items():
        media_kind = _get_media_kind(param_name)
        if not media_kind:
            continue
        is_required = param_info.get("required", False) or param_name in required
        if (
            not is_required
            and _is_primary_media_input_param(param_name)
            and _should_force_media_required(model_type, media_kind)
        ):
            is_required = True
        if not is_required:
            continue
        value = params.get(param_name)
        if value:
            continue
        session_value = session.get(param_name)
        if not session_value:
            missing.append(param_name)
    return missing


def _kie_readiness_state() -> tuple[bool, str]:
    if is_dry_run() or not allow_real_generation():
        return True, "dry_run"
    if is_test_mode() or os.getenv("KIE_STUB", "0").lower() in ("1", "true", "yes"):
        return True, "stub"
    api_key = os.getenv("KIE_API_KEY", "").strip()
    if not api_key:
        return False, "missing_api_key"
    try:
        from app.kie.kie_client import get_kie_client

        client = get_kie_client()
    except Exception as exc:
        logger.warning("KIE_CLIENT_IMPORT_FAILED error=%s - graceful degradation to None", exc, exc_info=True)
        client = None
    if client is None:
        return False, "client_none"
    if not getattr(client, "api_key", None):
        return False, "missing_api_key"
    return True, "ready"


def _select_next_param(session: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    properties = session.get("properties", {})
    params = session.get("params", {})
    param_order = session.get("param_order") or _build_param_order(properties)
    session["param_order"] = param_order
    required_params = session.get("required", [])
    required_order = [name for name in param_order if name in required_params]
    if not required_order:
        required_order = [name for name in required_params if name in properties]
    for param_name in required_order:
        if param_name in params:
            continue
        param_info = properties.get(param_name, {})
        param_type = param_info.get("type", "string")
        enum_values = _normalize_enum_values(param_info)
        is_optional = not param_info.get("required", False)
        if param_name in required_params:
            is_optional = False
        media_kind = _get_media_kind(param_name)
        reason = "missing_required"
        if enum_values:
            reason = "enum_buttons"
        return {
            "param_name": param_name,
            "param_info": param_info,
            "param_type": param_type,
            "enum_values": enum_values,
            "is_optional": is_optional,
            "media_kind": media_kind,
            "reason": reason,
        }
    return None
import json
import aiohttp
import aiofiles
import io
from io import BytesIO
import re
import platform
import random
import traceback
import time
from asyncio import Lock
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer

# Shared HTTP client session (initialized lazily via get_http_client)
_http_client: aiohttp.ClientSession | None = None

# Ensure Python can find modules in the same directory (for Render compatibility)
sys.path.insert(0, str(Path(__file__).parent))

# –£–±—Ä–∞–Ω–æ: load_dotenv()
# –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard)
# –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

# Try to import PIL/Pillow
try:
    from PIL import Image
    PIL_AVAILABLE = True
    logger.info("‚úÖ PIL/Pillow loaded successfully")
except ImportError:
    PIL_AVAILABLE = False
    logger.info("‚ÑπÔ∏è PIL/Pillow not available. Image analysis will be limited. Install with: pip install Pillow")

# Try to import pytesseract and configure Tesseract path
try:
    import pytesseract
    OCR_AVAILABLE = True
    tesseract_found = False
    
    # Try to set Tesseract path
    # On Windows, check common installation paths
    # On Linux (Render/Timeweb), Tesseract should be in PATH
    if platform.system() == 'Windows':
        # Common Tesseract installation paths on Windows
        possible_paths = [
            r'C:\Program Files\Tesseract-OCR\tesseract.exe',
            r'C:\Program Files (x86)\Tesseract-OCR\tesseract.exe',
            r'C:\Users\{}\AppData\Local\Programs\Tesseract-OCR\tesseract.exe'.format(os.getenv('USERNAME', '')),
        ]
        for path in possible_paths:
            if os.path.exists(path):
                pytesseract.pytesseract.tesseract_cmd = path
                tesseract_found = True
                logger.info(f"Tesseract found at: {path}")
                break
    else:
        # On Linux, Tesseract should be in PATH (installed via apt-get in Dockerfile)
        # Try to verify it's available by checking if command exists
        import shutil
        if shutil.which('tesseract'):
            logger.info("‚úÖ Tesseract found in PATH (Linux)")
            tesseract_found = True
        else:
            logger.info("‚ÑπÔ∏è Tesseract not found in PATH. OCR will be disabled. Install with: apt-get install tesseract-ocr")
            tesseract_found = False
    
    if not tesseract_found:
        logger.info("[INFO] Tesseract not found. OCR analysis will be disabled. Install tesseract-ocr package if needed.")
        OCR_AVAILABLE = False
    else:
        # Don't test Tesseract at import time - it can hang or timeout
        # Test will happen when OCR is actually needed
        logger.info("‚úÖ Tesseract OCR path configured. Will be tested when needed.")
except ImportError:
    OCR_AVAILABLE = False
    tesseract_found = False
    logger.info("‚ÑπÔ∏è pytesseract not available. OCR analysis will be disabled. Install with: pip install pytesseract")

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ app.config (—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑ ENV)
try:
    from app.config import BOT_TOKEN, BOT_MODE, WEBHOOK_URL
    from app.utils.mask import mask as mask_secret
    from app.bot_mode import get_bot_mode, ensure_polling_mode, ensure_webhook_mode, handle_conflict_gracefully
except ImportError:
    # Fallback –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (–µ—Å–ª–∏ app.config –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω)
    import warnings
    warnings.warn("app.config not found, using os.getenv directly. This is deprecated.")
    BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    BOT_MODE = os.getenv('BOT_MODE', 'polling')
    WEBHOOK_URL = os.getenv('WEBHOOK_URL')
    
    # Fallback –¥–ª—è mask_secret
    def mask_secret(value: Optional[str], show_first: int = 4, show_last: int = 4) -> str:
        """
        Fallback –º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.
        –í –ø—Ä–æ–¥–∞–∫—à–Ω –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ app.utils.mask.mask()
        """
        if not value:
            return ""
        if len(value) <= show_first + show_last:
            return "****"
        return value[:show_first] + "****" + value[-show_last:]
    
    # Fallback –¥–ª—è bot_mode —Ñ—É–Ω–∫—Ü–∏–π
    def get_bot_mode() -> str:
        """Fallback –¥–ª—è get_bot_mode"""
        mode = os.getenv("BOT_MODE", "").lower().strip()
        # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
        logger.info("üîç FALLBACK_GET_BOT_MODE BOT_MODE_env=%s PORT_env=%s WEBHOOK_URL_env=%s", 
                    os.getenv("BOT_MODE"), os.getenv("PORT"), bool(os.getenv("WEBHOOK_URL")))
        
        if not mode:
            if os.getenv("PORT") and os.getenv("WEBHOOK_URL"):
                mode = "webhook"
            else:
                mode = "polling"
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
        logger.info("üîç FALLBACK_BOT_MODE_RESULT mode=%s", mode)
        
        if mode not in ["polling", "webhook", "web", "smoke"]:
            raise ValueError(f"Invalid BOT_MODE: {mode}")
        return mode
    
    async def ensure_polling_mode(bot):
        """Fallback –¥–ª—è ensure_polling_mode"""
        try:
            webhook_info = await bot.get_webhook_info()
            if webhook_info.url:
                await bot.delete_webhook(drop_pending_updates=True)
            return True
        except Exception as exc:
            logger.warning("DELETE_WEBHOOK_FAILED error=%s", exc, exc_info=True)
            return False
    
    async def ensure_webhook_mode(bot, webhook_url: str):
        """Fallback –¥–ª—è ensure_webhook_mode"""
        if not webhook_url:
            return False
        try:
            await bot.set_webhook(url=webhook_url, drop_pending_updates=True)
            return True
        except Exception as exc:
            logger.warning("SET_WEBHOOK_FAILED url=%s error=%s", webhook_url, exc, exc_info=True)
            return False
    
    def handle_conflict_gracefully(error, mode: str):
        """Fallback –¥–ª—è handle_conflict_gracefully"""
        import sys
        logging.getLogger(__name__).error(f"Conflict detected in {mode} mode: {error}")
        sys.exit(0)
    
    # Singleton lock fallback removed (use app.utils.singleton_lock instead).

# Admin user ID (can be set via environment variable)
try:
    from app.admin.auth import get_admin_ids

    admin_ids = sorted(get_admin_ids())
    ADMIN_ID = admin_ids[0] if admin_ids else 6913446846
except Exception:
    ADMIN_ID = 6913446846  # Default fallback if invalid

# Price conversion constants
# Based on: 18 credits = $0.09 = 6.95 ‚ÇΩ
# NOTE: –¢–µ–ø–µ—Ä—å —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å config.settings –¥–ª—è —ç—Ç–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
CREDIT_TO_USD = 0.005  # 1 credit = $0.005 ($0.09 / 18)
USD_TO_RUB_DEFAULT = 77.83  # 1 USD = 77.83 RUB (fixed from pricing config)

def get_usd_to_rub_rate() -> float:
    """
    Get USD to RUB exchange rate from file, or return default if not set.
    DEPRECATED: Use app.services.payments_service.get_usd_to_rub_rate() instead
    """
    # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏–∑ app/services/payments_service (–ë–ï–ó circular import)
    try:
        from app.services.payments_service import get_usd_to_rub_rate as _get_rate
        return _get_rate()
    except ImportError:
        # Fallback –Ω–∞ —Å—Ç–∞—Ä—É—é –ª–æ–≥–∏–∫—É
        try:
            rate_data = load_json_file(CURRENCY_RATE_FILE, {})
            rate = rate_data.get('usd_to_rub', USD_TO_RUB_DEFAULT)
            if isinstance(rate, (int, float)) and rate > 0:
                return float(rate)
            else:
                logger.warning(f"Invalid currency rate in file: {rate}, using default: {USD_TO_RUB_DEFAULT}")
                return USD_TO_RUB_DEFAULT
        except Exception as e:
            logger.error(f"Error loading currency rate: {e}, using default: {USD_TO_RUB_DEFAULT}")
            return USD_TO_RUB_DEFAULT

def set_usd_to_rub_rate(rate: float) -> bool:
    """Set USD to RUB exchange rate and save to file."""
    logger.warning("USD to RUB rate is locked from pricing config; update ignored: %s", rate)
    return False

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
try:
    from bot_kie_services import pricing_service, storage_service, model_validator
    from bot_kie_utils import is_admin as is_admin_new
    NEW_SERVICES_AVAILABLE = True
    logger.info("‚úÖ –ù–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
except ImportError as e:
    NEW_SERVICES_AVAILABLE = False
    # –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –º–æ–¥—É–ª—å bot_kie_services –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
    logger.debug(f"‚ÑπÔ∏è –ù–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (—ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ): {e}")

# Database module is disabled in github-only storage mode.
log_kie_operation = None
create_operation = None
get_user_operations = None

# Initialize knowledge storage and KIE client (will be initialized in main() to avoid blocking import)
storage = None
kie = None

# PostgreSQL advisory lock connection (global –¥–ª—è keep-alive –∑–∞–¥–∞—á–∏)
# lock_conn –∏ lock_key_int —É–¥–∞–ª–µ–Ω—ã - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è app.locking.single_instance

# Store user sessions (SSOT via SessionStore)
user_sessions = get_session_store()

# Deduplicate update_id to prevent double-processing bursts
_processed_update_ids: dict[int, float] = {}
_processed_update_ttl_seconds = 120

# Store active generations - allows multiple concurrent generations per user
# Structure: active_generations[(user_id, task_id)] = {session_data}
active_generations = {}
active_generations_lock = asyncio.Lock()

# Track in-flight generation tasks to allow user-triggered cancellation
active_generation_tasks: Dict[int, asyncio.Task] = {}
active_generation_tasks_lock = asyncio.Lock()

ACTIVE_JOB_STATES_TERMINAL = {"cancelled", "finished", "failed", "timed_out", "delivered"}
ACTIVE_JOB_STATES_ACTIVE = {
    "queued",
    "waiting",
    "success",
    "result_validated",
    "tg_deliver",
    "delivery_pending",
    "running",
    "cancel_requested",
}


def _now_ms() -> int:
    return int(time.time() * 1000)


def _parse_cancel_callback(callback_data: Optional[str]) -> Optional[str]:
    if not callback_data or not callback_data.startswith("cancel:"):
        return None
    parts = callback_data.split(":", 1)
    if len(parts) != 2 or not parts[1]:
        return None
    return parts[1]


def _parse_sku_callback_data(callback_data: Optional[str]) -> tuple[Optional[str], Dict[str, str]]:
    if not callback_data or not (callback_data.startswith("sku:") or callback_data.startswith("sk:")):
        return None, {}
    from app.pricing.ssot_catalog import resolve_sku_callback

    sku_id = resolve_sku_callback(callback_data)
    if not sku_id:
        return None, {}
    params: Dict[str, str] = {}
    if "::" in sku_id:
        _model_id, raw_params = sku_id.split("::", 1)
        if raw_params and raw_params != "default":
            for segment in raw_params.split("|"):
                if not segment:
                    continue
                key, _, value = segment.partition("=")
                if key:
                    params[key] = value
    return sku_id, params


def _build_cancel_callback(job_id: Optional[str]) -> str:
    if job_id:
        return f"cancel:{job_id}"
    return "cancel"


def _log_cancel_update(
    *,
    correlation_id: Optional[str],
    update_id: Optional[int],
    user_id: Optional[int],
    chat_id: Optional[int],
    message_id: Optional[int],
    callback_query_id: Optional[str],
    callback_data: Optional[str],
    job_id: Optional[str],
    state_before: Optional[str],
    state_after: Optional[str],
    action: str,
) -> None:
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action=action,
        action_path="cancel",
        stage="CANCEL_FLOW",
        outcome=state_after or "noop",
        param={
            "update_id": update_id,
            "user_id": user_id,
            "chat_id": chat_id,
            "message_id": message_id,
            "callback_query_id": callback_query_id,
            "callback_data": callback_data,
            "job_id": job_id,
            "state_before": state_before,
            "state_after": state_after,
            "ts_ms": _now_ms(),
        },
    )


async def _remove_active_generation_task(user_id: int) -> None:
    """Remove task tracking entry (best-effort, ignores missing users)."""
    async with active_generation_tasks_lock:
        active_generation_tasks.pop(user_id, None)


async def register_active_generation_task(user_id: int) -> None:
    """Register the current asyncio.Task for cancellation hooks."""
    task = asyncio.current_task()
    if not task:
        return
    async with active_generation_tasks_lock:
        active_generation_tasks[user_id] = task

    def _cleanup(_task: asyncio.Task) -> None:
        _create_background_task(
            _remove_active_generation_task(user_id),
            action="active_generation_cleanup",
        )

    task.add_done_callback(_cleanup)


async def run_generation_with_tracking(user_id: int, coro: Awaitable[T]) -> T:
    """Run generation coroutine while tracking the underlying task for cancellation."""
    task = asyncio.create_task(coro)
    async with active_generation_tasks_lock:
        active_generation_tasks[user_id] = task

    def _cleanup(done_task: asyncio.Task) -> None:
        async def _remove_if_matches() -> None:
            async with active_generation_tasks_lock:
                if active_generation_tasks.get(user_id) is done_task:
                    active_generation_tasks.pop(user_id, None)

        _create_background_task(_remove_if_matches(), action="active_generation_cleanup")

    task.add_done_callback(_cleanup)
    return await task


async def cancel_active_generation(user_id: int) -> bool:
    """Cancel an in-flight generation task for the user if present."""
    async with active_generation_tasks_lock:
        task = active_generation_tasks.get(user_id)
        if not task:
            return False
        if task.done():
            active_generation_tasks.pop(user_id, None)
            return False
        task.cancel()
        active_generation_tasks.pop(user_id, None)
        return True

# Pending result deliveries for retry (user_id, task_id) -> payload
pending_deliveries: Dict[tuple[int, str], Dict[str, Any]] = {}
pending_deliveries_lock = asyncio.Lock()
_delivery_reconciler_task: Optional[asyncio.Task] = None
_dedupe_reconciler_task: Optional[asyncio.Task] = None
DELIVERY_RECONCILE_INTERVAL_SECONDS = int(os.getenv("DELIVERY_RECONCILE_INTERVAL_SECONDS", "15"))
DELIVERY_RECONCILE_BATCH_LIMIT = int(os.getenv("DELIVERY_RECONCILE_BATCH_LIMIT", "200"))
DELIVERY_PENDING_AGE_ALERT_SECONDS = int(os.getenv("DELIVERY_PENDING_AGE_ALERT_SECONDS", "600"))
DELIVERY_QUEUE_TAIL_ALERT_THRESHOLD = int(os.getenv("DELIVERY_QUEUE_TAIL_ALERT_THRESHOLD", "200"))
DEDUPE_RECONCILE_INTERVAL_SECONDS = int(os.getenv("DEDUPE_RECONCILE_INTERVAL_SECONDS", "30"))
DEDUPE_RECONCILE_BATCH_LIMIT = int(os.getenv("DEDUPE_RECONCILE_BATCH_LIMIT", "400"))
DEDUPE_ORPHAN_MAX_AGE_SECONDS = int(os.getenv("DEDUPE_ORPHAN_MAX_AGE_SECONDS", "90"))
DEDUPE_ORPHAN_ALERT_THRESHOLD = int(os.getenv("DEDUPE_ORPHAN_ALERT_THRESHOLD", "3"))

# Generation submit locks to prevent double confirm clicks
generation_submit_locks: dict[str, float] = {}
generation_submit_locks_guard = asyncio.Lock()
_generation_submit_lock_ttl_raw = float(os.getenv("GENERATION_SUBMIT_LOCK_TTL_SECONDS", "5"))
GENERATION_SUBMIT_LOCK_TTL_SECONDS = max(3.0, min(5.0, _generation_submit_lock_ttl_raw))
REQUEST_DEDUPE_WINDOW_SECONDS = int(os.getenv("GENERATION_DEDUPE_WINDOW_SECONDS", "15"))
DEDUPE_LOCK_WAIT_SECONDS = float(os.getenv("GEN_DEDUPE_LOCK_WAIT_SECONDS", "30"))
DEDUPE_TASK_RESOLUTION_ATTEMPTS = int(os.getenv("GEN_DEDUPE_TASK_RESOLUTION_ATTEMPTS", "20"))
DEDUPE_TASK_RESOLUTION_DELAY_SECONDS = float(os.getenv("GEN_DEDUPE_TASK_RESOLUTION_DELAY_SECONDS", "0.5"))
_request_tracker = RequestTracker(ttl_seconds=REQUEST_DEDUPE_WINDOW_SECONDS)
_pending_result_checks: Dict[int, float] = {}

# Store saved generation data for "generate again" feature
saved_generations = {}

# Maximum concurrent generations per user (to prevent abuse)
MAX_CONCURRENT_GENERATIONS_PER_USER = 5


def get_admin_limits() -> dict:
    """Get admin limits data."""
    return load_json_file(ADMIN_LIMITS_FILE, {})


def save_admin_limits(data: dict):
    """Save admin limits data."""
    save_json_file(ADMIN_LIMITS_FILE, data)


def is_admin(user_id: int) -> bool:
    """Check if user is admin."""
    from app.admin.auth import is_admin as is_admin_env

    return is_admin_env(user_id)


def get_admin_spent(user_id: int) -> float:
    """Get amount spent by admin (for limited admins)."""
    admin_limits = get_admin_limits()
    admin_data = admin_limits.get(str(user_id), {})
    return admin_data.get('spent', 0.0)


def get_admin_limit(user_id: int) -> float:
    """Get spending limit for admin (100 rubles for limited admins, unlimited for main admin)."""
    if user_id == ADMIN_ID:
        return float('inf')  # Main admin has unlimited
    admin_limits = get_admin_limits()
    admin_data = admin_limits.get(str(user_id), {})
    return admin_data.get('limit', 100.0)  # Default 100 rubles


def add_admin_spent(user_id: int, amount: float):
    """Add to admin's spent amount."""
    if user_id == ADMIN_ID:
        return  # Main admin doesn't have limits
    admin_limits = get_admin_limits()
    if str(user_id) not in admin_limits:
        return
    admin_limits[str(user_id)]['spent'] = admin_limits[str(user_id)].get('spent', 0.0) + amount
    save_admin_limits(admin_limits)


def get_admin_remaining(user_id: int) -> float:
    """Get remaining limit for admin."""
    limit = get_admin_limit(user_id)
    if limit == float('inf'):
        return float('inf')
    spent = get_admin_spent(user_id)
    return max(0.0, limit - spent)


def get_is_admin(user_id: int) -> bool:
    """
    Determine if user is admin, taking into account admin user mode.
    
    If admin is in user mode (admin_user_mode = True), returns False.
    Otherwise, returns True for admin, False for regular users.
    """
    return is_admin(user_id)


def is_user_mode(user_id: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∞–¥–º–∏–Ω –≤ —Ä–µ–∂–∏–º–µ –æ–±—ã—á–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    
    Returns:
        True –µ—Å–ª–∏ –∞–¥–º–∏–Ω –≤ —Ä–µ–∂–∏–º–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, False –∏–Ω–∞—á–µ
    """
    if not is_admin(user_id):
        return False  # –ù–µ –∞–¥–º–∏–Ω –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ —Ä–µ–∂–∏–º–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    return user_id in user_sessions and user_sessions[user_id].get('admin_user_mode', False)


def create_user_context_for_pricing(user_id: int, has_free_generations: bool = False) -> 'UserContext':
    """
    –°–æ–∑–¥–∞–µ—Ç UserContext –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ü–µ–Ω.
    
    –í–°–ï –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–º–∏–Ω–∞ –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é.
    –ó–∞–ø—Ä–µ—â–µ–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å is_admin –∫–∞–∫ bool –Ω–∞–ø—Ä—è–º—É—é.
    
    Args:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        has_free_generations: –ï—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    
    Returns:
        UserContext —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ is_admin –∏ is_user_mode
    """
    from services.user_context_factory import create_user_context
    
    return create_user_context(
        user_id=user_id,
        is_admin_func=is_admin,
        is_user_mode_func=is_user_mode,
        has_free_generations=has_free_generations
    )


def _resolve_mode_index(model_id: str, params: Optional[dict], user_id: Optional[int]) -> int:
    """Resolve pricing mode index from session or params."""
    mode_index = None
    if params and isinstance(params, dict):
        mode_index = params.get("mode_index")
        if mode_index is None:
            mode_index = params.get("_mode_index")
    if mode_index is None and user_id is not None:
        mode_index = user_sessions.get(user_id, {}).get("mode_index")
    try:
        return int(mode_index) if mode_index is not None else 0
    except (TypeError, ValueError):
        logger.warning(
            "Invalid mode_index for model %s: %s (user_id=%s)",
            model_id,
            mode_index,
            user_id,
        )
        return 0


# COMPATIBILITY WRAPPER: calculate_price_rub –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç services.pricing_service.get_price() –ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º
def calculate_price_rub(model_id: str, params: dict = None, is_admin: bool = False, user_id: int = None) -> Optional[float]:
    """
    Thin-wrapper –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç services.pricing_service.get_price() –ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º.
    
    Args:
        model_id: ID –º–æ–¥–µ–ª–∏
        params: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        is_admin: –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–æ–º
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    
    Returns:
        –¶–µ–Ω–∞ –≤ —Ä—É–±–ª—è—Ö
    """
    if user_id is not None:
        is_admin = get_is_admin(user_id)
    try:
        from app.pricing.price_resolver import resolve_price_quote
        from app.config import get_settings

        settings = get_settings()
        mode_index = _resolve_mode_index(model_id, params, user_id)
        quote = resolve_price_quote(
            model_id=model_id,
            mode_index=mode_index,
            gen_type=None,
            selected_params=params or {},
            settings=settings,
            is_admin=is_admin,
        )
        if quote is None:
            logger.warning("Price not found for model %s", model_id)
            return None
        return float(quote.price_rub)
    except ImportError as e:
        logger.warning("Pricing resolver unavailable: %s", e)
        return None
    except Exception as e:
        logger.error(f"Error in calculate_price_rub: {e}", exc_info=True)
        return None

# Conversation states for model selection and parameter input
SELECTING_MODEL, INPUTTING_PARAMS, CONFIRMING_GENERATION = range(3)

# Payment states
SELECTING_AMOUNT, WAITING_PAYMENT_SCREENSHOT = range(3, 5)

# Admin test OCR state
ADMIN_TEST_OCR = 5

# Broadcast states
WAITING_BROADCAST_MESSAGE = 6
WAITING_CURRENCY_RATE = 7

# Store user sessions - now supports multiple concurrent generations per user
# Structure: user_sessions[user_id] = {session_data} for input/parameter collection
# Once task is created, it moves to active_generations
# NOTE: user_sessions already declared above (line 224), this is a duplicate - removed

# Store active generations - allows multiple concurrent generations per user
# Structure: active_generations[(user_id, task_id)] = {session_data}
# NOTE: active_generations already declared above (line 358), this is a duplicate - removed


def format_rub_amount(value: float) -> str:
    """Format RUB amount with 2 decimals (ROUND_HALF_UP)."""
    from app.pricing.price_resolver import format_price_rub

    formatted = format_price_rub(value)
    if "." in formatted:
        formatted = formatted.rstrip("0").rstrip(".")
    return f"{formatted} ‚ÇΩ"

_admin_price_notice_logged = False


def format_price_rub(price: float, is_admin: bool = False) -> str:
    """Format price in rubles with appropriate text (2 decimals)."""
    if is_admin:
        global _admin_price_notice_logged
        if not _admin_price_notice_logged:
            _admin_price_notice_logged = True
            logger.info(
                "ADMIN_PRICE_TEXT applied=true message=admin_unlimited_free_generations",
            )
        return "üéÅ –ê–¥–º–∏–Ω: –±–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–∫–≤–æ—Ç–∞ –Ω–µ —Ä–∞—Å—Ö–æ–¥—É–µ—Ç—Å—è)."
    price_str = format_rub_amount(price)
    return f"üí∞ <b>{price_str}</b>"


def _normalize_sku_param_value(value: Any) -> str:
    if isinstance(value, bool):
        return "true" if value else "false"
    if value is None:
        return ""
    return str(value)


def _build_expected_sku_key(model_id: str, params: Optional[dict]) -> str:
    if not params:
        return f"{model_id}::default"
    parts = [f"{key}={_normalize_sku_param_value(params[key])}" for key in sorted(params)]
    return f"{model_id}::" + "|".join(parts)


def _format_pricing_context(settings: "Settings", is_admin: bool, user_lang: str) -> str:
    effective_multiplier = 1.0 if is_admin else settings.price_multiplier
    if user_lang == "ru":
        return f"–∫—É—Ä—Å {settings.usd_to_rub:.2f}, –º–Ω–æ–∂–∏—Ç–µ–ª—å {effective_multiplier:g}"
    return f"rate {settings.usd_to_rub:.2f}, multiplier {effective_multiplier:g}"


def _build_price_line(
    price_rub: float,
    settings: "Settings",
    is_admin: bool,
    user_lang: str,
    *,
    is_from: bool = False,
) -> str:
    from app.pricing.price_resolver import format_price_rub as format_price_value

    if is_admin:
        return "üéÅ –ê–¥–º–∏–Ω: –±–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–∫–≤–æ—Ç–∞ –Ω–µ —Ä–∞—Å—Ö–æ–¥—É–µ—Ç—Å—è)."
    prefix = "–æ—Ç " if user_lang == "ru" and is_from else ("from " if user_lang != "ru" and is_from else "")
    label = "–°—Ç–æ–∏–º–æ—Å—Ç—å" if user_lang == "ru" else "Price"
    price_display = format_price_value(price_rub)
    context = _format_pricing_context(settings, is_admin, user_lang)
    return f"üí∞ <b>{label}:</b> {prefix}{price_display} ‚ÇΩ ({context})"


def _build_price_unavailable_line(user_lang: str) -> str:
    if user_lang == "ru":
        return "üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> —Ü–µ–Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"
    return "üí∞ <b>Price:</b> temporarily unavailable"


def _resolve_price_for_display(
    session: dict,
    *,
    model_id: str,
    mode_index: int,
    gen_type: Optional[str],
    params: dict,
    user_lang: str,
    is_admin: bool,
    correlation_id: Optional[str],
    update_id: Optional[int],
    action_path: str,
    user_id: Optional[int],
    chat_id: Optional[int],
) -> tuple[Optional[float], str, Optional[str]]:
    from app.config import get_settings

    settings = get_settings()
    quote = _update_price_quote(
        session,
        model_id=model_id,
        mode_index=mode_index,
        gen_type=gen_type,
        params=params,
        correlation_id=correlation_id,
        update_id=update_id,
        action_path=action_path,
        user_id=user_id,
        chat_id=chat_id,
        is_admin=is_admin,
    )
    if quote:
        price_value = float(quote["price_rub"])
        return price_value, _build_price_line(price_value, settings, is_admin, user_lang), None
    return None, _build_price_unavailable_line(user_lang), None


def get_model_price_text(model_id: str, params: dict = None, is_admin: bool = False, user_id: int = None) -> str:
    """Get formatted price text for a model (from-price for menu cards)."""
    from app.pricing.price_ssot import get_min_price

    if user_id is not None:
        is_admin = get_is_admin(user_id)
    price = calculate_price_rub(model_id, params, is_admin, user_id)
    if price is None:
        min_price = get_min_price(model_id)
        if min_price is None:
            return "üí∞ <b>–æ—Ç ‚Äî ‚ÇΩ</b>"
        return f"üí∞ <b>–æ—Ç {format_rub_amount(float(min_price))}</b>"
    return format_price_rub(price, is_admin)


def get_from_price_value(model_id: str) -> Optional[float]:
    """Return the minimum price in RUB for a model, if available."""
    from app.pricing.price_ssot import get_min_price

    min_price = get_min_price(model_id)
    return float(min_price) if min_price is not None else None


def _normalize_gen_type(gen_type: Optional[str]) -> Optional[str]:
    if not gen_type:
        return None
    return gen_type.replace("_", "-")


UI_CONTEXT_MAIN_MENU = "MAIN_MENU"
UI_CONTEXT_GEN_TYPE_MENU = "GEN_TYPE_MENU"
UI_CONTEXT_MODEL_MENU = "MODEL_MENU"
UI_CONTEXT_FREE_TOOLS_MENU = "FREE_TOOLS_MENU"
UI_CONTEXT_WIZARD = "WIZARD"


def _derive_model_gen_type(model_spec: Any | None) -> Optional[str]:
    if model_spec is None:
        return None
    return _normalize_gen_type(
        getattr(model_spec, "model_mode", None)
        or getattr(model_spec, "model_type", None)
    )


def _resolve_session_gen_type(session: dict | None, model_spec: Any | None = None) -> Optional[str]:
    if session and session.get("active_gen_type"):
        return _normalize_gen_type(session.get("active_gen_type"))
    if session and session.get("gen_type"):
        return _normalize_gen_type(session.get("gen_type"))
    if model_spec is not None:
        return _normalize_gen_type(getattr(model_spec, "model_mode", None) or getattr(model_spec, "model_type", None))
    return None


def _model_supports_gen_type(model_spec: Any, gen_type: Optional[str]) -> bool:
    if not gen_type or not model_spec:
        return True
    expected = _normalize_gen_type(gen_type)
    supported = {
        _normalize_gen_type(getattr(model_spec, "model_mode", None)),
        _normalize_gen_type(getattr(model_spec, "model_type", None)),
    }
    return expected in supported


def _update_price_quote(
    session: dict,
    *,
    model_id: str,
    mode_index: int,
    gen_type: Optional[str],
    params: dict,
    correlation_id: Optional[str],
    update_id: Optional[int],
    action_path: str,
    user_id: Optional[int] = None,
    chat_id: Optional[int] = None,
    is_admin: bool = False,
) -> Optional[dict]:
    from app.pricing.price_resolver import resolve_price_quote
    from app.config import get_settings

    def _log_model_blocked(reason: str) -> None:
        try:
            from app.pricing.ssot_catalog import get_pricing_coverage_entry

            entry = get_pricing_coverage_entry(model_id) or {}
            status = entry.get("status") or reason or "PRICING_COVERAGE"
            issues = entry.get("issues")
            if not isinstance(issues, list):
                issues = []
        except Exception:
            status = reason or "PRICING_COVERAGE"
            issues = []
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="MODEL_BLOCKED",
            action_path=action_path,
            model_id=model_id,
            gen_type=gen_type,
            stage="PRICE_RESOLVE",
            outcome="blocked",
            error_code=status,
            fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ PRICING_COVERAGE –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏.",
            param={
                "issues": issues,
                "reason": status,
                "mode_index": mode_index,
                "params": params or {},
            },
        )

    def _resolve_free_tool_sku_id() -> Optional[str]:
        for free_sku in FREE_TOOL_SKU_IDS:
            if free_sku.split("::", 1)[0] == model_id:
                return free_sku
        return None
    try:
        quote = resolve_price_quote(
            model_id=model_id,
            mode_index=mode_index,
            gen_type=gen_type,
            selected_params=params or {},
            settings=get_settings(),
            is_admin=is_admin,
        )
    except Exception as exc:
        logger.error(
            "PRICE_CALC_FAIL model_id=%s mode_index=%s error=%s",
            model_id,
            mode_index,
            exc,
            exc_info=True,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="PRICE_CALC_FAIL",
            action_path=action_path,
            model_id=model_id,
            gen_type=gen_type,
            stage="PRICE_RESOLVE",
            outcome="failed",
            error_code=type(exc).__name__,
            fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ pricing SSOT –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏.",
            param={
                "mode_index": mode_index,
                "params": params or {},
            },
        )
        return None
    if quote is None:
        free_sku_id = _resolve_free_tool_sku_id()
        if free_sku_id:
            session["price_quote"] = {
                "price_rub": "0.00",
                "currency": "RUB",
                "breakdown": {
                    "model_id": model_id,
                    "mode_index": mode_index,
                    "gen_type": gen_type,
                    "params": dict(params or {}),
                    "sku_id": free_sku_id,
                    "unit": "free",
                    "free_fallback": True,
                },
            }
            session["sku_id"] = free_sku_id
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="PRICE_RESOLVED",
                action_path=action_path,
                model_id=model_id,
                gen_type=gen_type,
                stage="PRICE_RESOLVE",
                outcome="resolved",
                param={
                    "price_rub": "0.00",
                    "mode_index": mode_index,
                    "params": params or {},
                    "free_fallback": True,
                },
            )
            return session["price_quote"]
        session["price_quote"] = None
        try:
            from app.pricing.price_ssot import PRICING_SSOT_PATH, list_model_skus
        except Exception as exc:
            logger.debug("PRICING_SSOT_IMPORT_FALLBACK error=%s - using defaults", exc)
            PRICING_SSOT_PATH = "data/kie_pricing_rub.yaml"
            list_model_skus = None
        skus = list_model_skus(model_id) if list_model_skus else []
        if not skus:
            expected_sku = _build_expected_sku_key(model_id, params)
            logger.warning(
                "Missing pricing for SKU %s in %s",
                expected_sku,
                PRICING_SSOT_PATH,
            )
            _log_model_blocked("MISSING_PRICE")
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="pricing_miss",
                action_path=action_path,
                model_id=model_id,
                gen_type=gen_type,
                stage="PRICE_RESOLVE",
                outcome="blocked",
                error_code="MISSING_PRICE",
                fix_hint="–î–æ–±–∞–≤—å—Ç–µ SKU –≤ pricing SSOT.",
                param={
                    "mode_index": mode_index,
                    "params": params or {},
                    "expected_sku": expected_sku,
                },
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="PRICE_MISSING_RULE",
                action_path=action_path,
                model_id=model_id,
                gen_type=gen_type,
                stage="PRICE_RESOLVE",
                outcome="missing",
                error_code="PRICE_MISSING_RULE",
                fix_hint="pricing ssot missing SKU mapping; check params and catalog.",
                param={
                    "mode_index": mode_index,
                    "params": params or {},
                },
            )
            return None

        expected_sku = _build_expected_sku_key(model_id, params)
        available_skus = [sku.sku_key for sku in skus]
        logger.warning(
            "pricing_miss model_id=%s mode_index=%s expected_sku=%s available=%s params=%s",
            model_id,
            mode_index,
            expected_sku,
            available_skus,
            params,
        )
        _log_model_blocked("NO_PRICE_FOR_PARAMS")
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="pricing_miss",
            action_path=action_path,
            model_id=model_id,
            gen_type=gen_type,
            stage="PRICE_RESOLVE",
            outcome="blocked",
            error_code="NO_PRICE_FOR_PARAMS",
            fix_hint="–î–æ–±–∞–≤—å—Ç–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–π SKU/–º–∞–ø–ø–∏–Ω–≥ –∏–ª–∏ —Å–∫—Ä–æ–π—Ç–µ –ø—Ä–µ—Å–µ—Ç.",
            param={
                "mode_index": mode_index,
                "params": params or {},
                "expected_sku": expected_sku,
                "available_skus": available_skus,
            },
        )
        return None
    session["price_quote"] = {
        "price_rub": f"{quote.price_rub:.2f}",
        "currency": quote.currency,
        "breakdown": quote.breakdown,
    }
    session["sku_id"] = quote.sku_id
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="PRICE_RESOLVED",
        action_path=action_path,
        model_id=model_id,
        gen_type=gen_type,
        stage="PRICE_RESOLVE",
        outcome="resolved",
        param={
            "price_rub": f"{quote.price_rub:.2f}",
            "mode_index": mode_index,
            "params": params or {},
        },
    )
    return session["price_quote"]


def _build_current_price_line(
    session: dict,
    *,
    user_lang: str,
    model_id: str,
    mode_index: int,
    gen_type: Optional[str],
    params: dict,
    correlation_id: Optional[str],
    update_id: Optional[int],
    action_path: str,
    user_id: Optional[int] = None,
    chat_id: Optional[int] = None,
    is_admin: bool = False,
) -> str:
    from app.pricing.price_resolver import format_price_rub as format_price_value

    quote = session.get("price_quote")
    if quote is None:
        quote = _update_price_quote(
            session,
            model_id=model_id,
            mode_index=mode_index,
            gen_type=gen_type,
            params=params,
            correlation_id=correlation_id,
            update_id=update_id,
            action_path=action_path,
            user_id=user_id,
            chat_id=chat_id,
            is_admin=is_admin,
        )
    if not quote:
        price_text = "–¶–µ–Ω–∞: —É—Ç–æ—á–Ω—è–µ—Ç—Å—è" if user_lang == "ru" else "Price: —É—Ç–æ—á–Ω—è–µ—Ç—Å—è"
    else:
        breakdown = quote.get("breakdown", {}) if isinstance(quote, dict) else {}
        price_value = quote.get("price_rub") if isinstance(quote, dict) else None
        is_free = bool(breakdown.get("free_sku")) or bool(breakdown.get("admin_free"))
        if price_value is None:
            price_text = "–¶–µ–Ω–∞: —É—Ç–æ—á–Ω—è–µ—Ç—Å—è" if user_lang == "ru" else "Price: —É—Ç–æ—á–Ω—è–µ—Ç—Å—è"
        elif is_free:
            price_text = "üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ" if user_lang == "ru" else "üéÅ Free"
        else:
            formatted_price = format_price_value(price_value)
            if user_lang == "ru":
                price_text = f"–¶–µ–Ω–∞ –ø–æ –ø—Ä–∞–π—Å—É: {formatted_price} ‚ÇΩ"
            else:
                price_text = f"Price (RUB): {formatted_price} ‚ÇΩ"
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="PRICE_SHOWN",
        action_path=action_path,
        model_id=model_id,
        gen_type=gen_type,
        stage="PRICE_DISPLAY",
        outcome="shown",
        param={
            "mode_index": mode_index,
            "params": params or {},
            "price_text": price_text,
        },
    )
    return price_text


def build_option_confirm_text(
    user_lang: str,
    param_label: str,
    display_value: str,
    price_rub: float,
) -> str:
    price_line = f"{price_rub:.2f} ‚ÇΩ"
    if user_lang == "ru":
        return (
            f"‚úÖ {param_label}: <b>{display_value}</b>\n"
            f"üí∞ <b>–≠—Ç–∞ –æ–ø—Ü–∏—è:</b> {price_line}\n\n"
            "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—ã–±–æ—Ä?"
        )
    return (
        f"‚úÖ {param_label}: <b>{display_value}</b>\n"
        f"üí∞ <b>This option:</b> {price_line}\n\n"
        "Confirm selection?"
    )


def _build_price_preview_text(user_lang: str, price: float, balance: float) -> str:
    after_balance = balance - price
    price_str = format_rub_amount(price)
    balance_str = format_rub_amount(balance)
    after_str = format_rub_amount(max(after_balance, 0))
    rounding_note = (
        "üí° <i>–¶–µ–Ω–∞ –æ–∫—Ä—É–≥–ª—è–µ—Ç—Å—è –¥–æ –∫–æ–ø–µ–µ–∫ (0.01 ‚ÇΩ).</i>"
        if user_lang == "ru"
        else "üí° <i>Prices are rounded to 0.01 ‚ÇΩ.</i>"
    )
    if user_lang == "ru":
        return (
            "üßæ <b>–ü–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º</b>\n\n"
            f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}\n"
            f"üí≥ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str}\n"
            f"‚úÖ <b>–ü–æ—Å–ª–µ —Å–ø–∏—Å–∞–Ω–∏—è:</b> {after_str}\n\n"
            f"{rounding_note}"
        )
    return (
        "üßæ <b>Before we start</b>\n\n"
        f"üí∞ <b>Price:</b> {price_str}\n"
        f"üí≥ <b>Balance:</b> {balance_str}\n"
        f"‚úÖ <b>After charge:</b> {after_str}\n\n"
        f"{rounding_note}"
    )


def _build_insufficient_funds_text(user_lang: str, price: float, balance: float) -> str:
    price_str = format_rub_amount(price)
    balance_str = format_rub_amount(balance)
    needed_str = format_rub_amount(max(price - balance, 0))
    rounding_note = (
        "üí° <i>–¶–µ–Ω–∞ –æ–∫—Ä—É–≥–ª—è–µ—Ç—Å—è –¥–æ –∫–æ–ø–µ–µ–∫ (0.01 ‚ÇΩ).</i>"
        if user_lang == "ru"
        else "üí° <i>Prices are rounded to 0.01 ‚ÇΩ.</i>"
    )
    if user_lang == "ru":
        return (
            "‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
            f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}\n"
            f"üí≥ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str}\n"
            f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str}\n\n"
            f"{rounding_note}\n\n"
            "–ß—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:\n"
            "‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n"
            "‚Ä¢ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã\n"
            "‚Ä¢ –ù–∞–ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É"
        )
    return (
        "‚ùå <b>Insufficient funds</b>\n\n"
        f"üí∞ <b>Price:</b> {price_str}\n"
        f"üí≥ <b>Balance:</b> {balance_str}\n"
        f"‚ùå <b>Missing:</b> {needed_str}\n\n"
        f"{rounding_note}\n\n"
        "What you can do:\n"
        "‚Ä¢ Top up your balance\n"
        "‚Ä¢ See payment options\n"
        "‚Ä¢ Contact support"
    )


def _build_insufficient_funds_keyboard(user_lang: str) -> InlineKeyboardMarkup:
    keyboard = [
        [InlineKeyboardButton(t('btn_check_balance', lang=user_lang), callback_data="check_balance")],
        [
            InlineKeyboardButton(
                "üí≥ –ö–∞–∫ –æ–ø–ª–∞—Ç–∏—Ç—å" if user_lang == "ru" else "üí≥ How to pay",
                callback_data="topup_balance",
            )
        ],
        [InlineKeyboardButton(t('btn_support', lang=user_lang), callback_data="support_contact")],
        [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")],
    ]
    return InlineKeyboardMarkup(keyboard)


def _build_topup_menu_keyboard(user_lang: str) -> InlineKeyboardMarkup:
    keyboard = [
        [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
        [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")],
    ]
    return InlineKeyboardMarkup(keyboard)


def _build_mode_selection_text(model_name: str, user_lang: str) -> str:
    if user_lang == "ru":
        return (
            "üß© <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
            "–¶–µ–Ω–∞ –∏ —Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–µ–∂–∏–º–∞."
        )
    return (
        "üß© <b>Select a generation mode</b>\n\n"
        f"ü§ñ <b>Model:</b> {model_name}\n\n"
        "Price and charge depend on the mode."
    )


def _resolve_mode_price_quote(model_id: str, mode_index: int, gen_type: Optional[str]) -> Optional["PriceQuote"]:
    from app.config import get_settings
    from app.pricing.price_resolver import resolve_price_quote

    settings = get_settings()
    return resolve_price_quote(
        model_id=model_id,
        mode_index=mode_index,
        gen_type=gen_type,
        selected_params={},
        settings=settings,
        is_admin=False,
    )


def _prefill_params_from_quote(session: dict, model_id: str, quote: Optional["PriceQuote"]) -> None:
    if not quote:
        return
    breakdown = quote.breakdown if isinstance(quote.breakdown, dict) else {}
    default_params = breakdown.get("params")
    if not isinstance(default_params, dict) or not default_params:
        return
    from app.kie_contract.schema_loader import get_model_schema

    schema = get_model_schema(model_id) or {}
    allowed_keys = set(schema.keys()) if isinstance(schema, dict) else set()
    existing = session.get("prefill_params")
    merged = dict(existing) if isinstance(existing, dict) else {}
    for key, value in default_params.items():
        if allowed_keys and key not in allowed_keys:
            continue
        merged.setdefault(key, value)
    session["prefill_params"] = merged


def _build_mode_selection_keyboard(model_id: str, mode_entries: List[tuple[int, Any]], user_lang: str) -> InlineKeyboardMarkup:
    buttons: List[List[InlineKeyboardButton]] = []
    for index, mode in mode_entries:
        label = _resolve_mode_label(mode, index, user_lang)
        buttons.append([InlineKeyboardButton(label, callback_data=f"select_mode:{model_id}:{index}")])
    buttons.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
    return InlineKeyboardMarkup(buttons)


def _build_kie_request_failed_message(
    status: Optional[int],
    user_lang: str,
    user_message: Optional[str] = None,
) -> str:
    if user_message:
        return user_message
    if status == 401:
        return (
            "‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á</b>\n\n"
            "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ KIE_API_KEY –≤ ENV (Render/Timeweb) –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–∏—Å."
            if user_lang == "ru"
            else "‚ùå <b>Authorization issue</b>\n\nCheck KIE_API_KEY in ENV and restart the service."
        )
    if status == 402:
        return (
            "‚ö†Ô∏è <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ KIE –∞–∫–∫–∞—É–Ω—Ç–µ</b>\n\n"
            "–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å KIE –∞–∫–∫–∞—É–Ω—Ç–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            if user_lang == "ru"
            else "‚ö†Ô∏è <b>KIE account has insufficient credits</b>\n\nPlease top up and try again."
        )
    if status == 422:
        return (
            "‚ö†Ô∏è <b>–û—à–∏–±–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–æ–¥–µ–ª–∏</b>\n\n"
            "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            if user_lang == "ru"
            else "‚ö†Ô∏è <b>Check the parameters</b>\n\nSome values are invalid. Please adjust your request."
        )
    if status == 429:
        return (
            "‚è≥ <b>–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤</b>\n\n"
            "–û—á–µ—Ä–µ–¥—å –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ –ø–∞—Ä—É –º–∏–Ω—É—Ç."
            if user_lang == "ru"
            else "‚è≥ <b>Too many requests</b>\n\nQueue is busy. Please try again in a few minutes."
        )
    if status == 500:
        return (
            "‚ùå <b>–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞</b>\n\n"
            "–ú—ã —É–∂–µ –∏—â–µ–º –ø—Ä–∏—á–∏–Ω—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            if user_lang == "ru"
            else "‚ùå <b>Server error</b>\n\nWe're investigating. Please try again later."
        )
    return (
        "‚ùå <b>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é</b>\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        if user_lang == "ru"
        else "‚ùå <b>Could not start generation</b>\n\nPlease try again later."
    )


def _is_kie_model_not_supported(message: Optional[str]) -> bool:
    if not message:
        return False
    lowered = message.lower()
    return "model name" in lowered and "not supported" in lowered

# Broadcast states
WAITING_BROADCAST_MESSAGE = 6
WAITING_CURRENCY_RATE = 7

# Helper functions for balance management

# NOTE: active_generations already declared above (line 358), this is a duplicate - removed

# File operation locks to prevent race conditions (using threading.Lock for sync operations)
_file_locks = {
    'balances': threading.Lock(),
    'generations_history': threading.Lock(),
    'referrals': threading.Lock(),
    'referral_events': threading.Lock(),
    'promocodes': threading.Lock(),
    'free_generations': threading.Lock(),
    'languages': threading.Lock(),
    'gifts': threading.Lock(),
    'payments': threading.Lock(),
    'broadcasts': threading.Lock(),
    'admin_limits': threading.Lock(),
    'blocked_users': threading.Lock(),
    'user_registry': threading.Lock(),
    'jobs': threading.Lock(),
    'ui_actions': threading.Lock(),
}

# In-memory cache for frequently accessed data (optimized for 1000+ users)
_data_cache = {
    'balances': {},
    'free_generations': {},
    'languages': {},
    'gifts': {},
    'user_registry': {},
    'jobs': {},
    'ui_actions': {},
    'cache_timestamps': {}
}

# Cache TTL in seconds (5 minutes)
CACHE_TTL = 300
_last_save_time = {}
USER_REGISTRY_DEBOUNCE_SECONDS = float(os.getenv("USER_REGISTRY_DEBOUNCE_SECONDS", "60.0"))
USER_REGISTRY_FLUSH_INTERVAL_SECONDS = float(os.getenv("USER_REGISTRY_FLUSH_INTERVAL_SECONDS", "1.5"))
USER_REGISTRY_FLUSH_MAX_BATCH = int(os.getenv("USER_REGISTRY_FLUSH_MAX_BATCH", "200"))
USER_REGISTRY_PERSIST_TIMEOUT_SECONDS = float(
    os.getenv("USER_REGISTRY_PERSIST_TIMEOUT_SECONDS", "2.5")
)

_user_registry_debouncer = TTLCache(USER_REGISTRY_DEBOUNCE_SECONDS)
_user_registry_pending: Dict[int, Dict[str, Any]] = {}
_user_registry_flush_task: Optional[asyncio.Task[Any]] = None
_user_registry_flush_lock: Optional[asyncio.Lock] = None
_user_registry_flush_event: Optional[asyncio.Event] = None

# Storage paths - storage backend handles persistence (DB only).
DATA_DIR = os.getenv("DATA_DIR", "").strip()
BOT_INSTANCE_ID = os.getenv("BOT_INSTANCE_ID", "").strip()
_data_dir_warning_logged = False


def _resolve_data_dir() -> str:
    base_dir = DATA_DIR or "."
    bot_instance_id = BOT_INSTANCE_ID or "default"
    if not BOT_INSTANCE_ID:
        global _data_dir_warning_logged
        if not _data_dir_warning_logged:
            _data_dir_warning_logged = True
            logger.warning("BOT_INSTANCE_ID missing; data dir defaulted tenant=%s", bot_instance_id)
    if bot_instance_id:
        base_path = Path(base_dir)
        if bot_instance_id not in base_path.parts:
            base_path = base_path / bot_instance_id
        return str(base_path)
    return base_dir


def get_data_file_path(filename: str) -> str:
    """Return logical filename scoped by BOT_INSTANCE_ID when possible."""
    base_dir = _resolve_data_dir()
    if not base_dir or base_dir == ".":
        return os.path.join(base_dir, filename).lstrip("./")
    return os.path.join(base_dir, filename)

# Payment data files - all stored in DATA_DIR for persistence
BALANCES_FILE = get_data_file_path("user_balances.json")
USER_LANGUAGES_FILE = get_data_file_path("user_languages.json")
GIFT_CLAIMED_FILE = get_data_file_path("gift_claimed.json")
ADMIN_LIMITS_FILE = get_data_file_path("admin_limits.json")  # File to store admins with spending limits
PAYMENTS_FILE = get_data_file_path("payments.json")
BLOCKED_USERS_FILE = get_data_file_path("blocked_users.json")
FREE_GENERATIONS_FILE = get_data_file_path("daily_free_generations.json")  # File to store daily free generations
PROMOCODES_FILE = get_data_file_path("promocodes.json")  # File to store promo codes
CURRENCY_RATE_FILE = get_data_file_path("currency_rate.json")  # File to store USD to RUB exchange rate
REFERRALS_FILE = get_data_file_path("referrals.json")  # File to store referral data
REFERRAL_EVENTS_FILE = get_data_file_path("referral_events.json")  # File to store referral events
BROADCASTS_FILE = get_data_file_path("broadcasts.json")  # File to store broadcast statistics
GENERATIONS_HISTORY_FILE = get_data_file_path("generations_history.json")  # File to store user generation history
USER_REGISTRY_FILE = get_data_file_path("user_registry.json")
JOBS_FILE = get_data_file_path("jobs.json")
UI_ACTIONS_FILE = get_data_file_path("ui_actions.json")

# Free tools settings
FREE_TOOLS_CONFIG = get_free_tools_config()
FREE_TOOL_SKU_IDS = get_free_tools_model_ids()
FREE_TOOL_MODEL_IDS = [sku_id.split("::", 1)[0] for sku_id in FREE_TOOL_SKU_IDS]
FREE_SKU_ID = FREE_TOOL_SKU_IDS[0] if FREE_TOOL_SKU_IDS else ""

def is_video_model(model_id: str) -> bool:
    """Check if model is a video generation model"""
    video_keywords = ['video', 'animate', 'avatar', 'speech-to-video']
    return any(keyword in model_id.lower() for keyword in video_keywords)

def is_audio_model(model_id: str) -> bool:
    """Check if model is an audio processing model"""
    audio_keywords = ['speech-to-text', 'audio', 'transcribe']
    return any(keyword in model_id.lower() for keyword in audio_keywords)


def get_generation_timeout_seconds(model_spec: Any) -> int:
    """Determine generation timeout per model category."""
    model_mode = (getattr(model_spec, "model_mode", "") or "").lower()
    output_media = (getattr(model_spec, "output_media_type", "") or "").lower()
    if "video" in model_mode or output_media == "video":
        return int(os.getenv("KIE_TIMEOUT_VIDEO", "420"))
    if any(token in model_mode for token in ("audio", "speech")) or output_media in {"audio", "voice"}:
        return int(os.getenv("KIE_TIMEOUT_AUDIO", "180"))
    return int(os.getenv("KIE_TIMEOUT_IMAGE", "180"))
FREE_GENERATIONS_PER_DAY = FREE_TOOLS_CONFIG.base_per_day
REFERRAL_BONUS_GENERATIONS = FREE_TOOLS_CONFIG.referral_bonus  # Bonus generations for inviting a user

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤ helpers
set_constants(FREE_GENERATIONS_PER_DAY, REFERRAL_BONUS_GENERATIONS, ADMIN_ID)


# ==================== Payment System Functions ====================

def get_cache_key(filename: str) -> str:
    """Get cache key for filename."""
    cache_map = {
        BALANCES_FILE: 'balances',
        FREE_GENERATIONS_FILE: 'free_generations',
        USER_LANGUAGES_FILE: 'languages',
        GIFT_CLAIMED_FILE: 'gifts',
        REFERRALS_FILE: 'referrals',
        PROMOCODES_FILE: 'promocodes',
        GENERATIONS_HISTORY_FILE: 'generations_history',
        PAYMENTS_FILE: 'payments',
        BROADCASTS_FILE: 'broadcasts',
        ADMIN_LIMITS_FILE: 'admin_limits',
        BLOCKED_USERS_FILE: 'blocked_users',
        USER_REGISTRY_FILE: 'user_registry',
        JOBS_FILE: 'jobs',
        UI_ACTIONS_FILE: 'ui_actions',
        REFERRAL_EVENTS_FILE: 'referral_events',
    }
    return cache_map.get(filename, filename)


def _normalize_storage_payload(
    payload: Any,
    *,
    filename: str,
    source: str,
    default: Dict[str, Any],
) -> Dict[str, Any]:
    if isinstance(payload, dict):
        return payload
    if isinstance(payload, str):
        try:
            nested = json.loads(payload)
        except Exception:
            nested = None
        if isinstance(nested, dict):
            return nested
    correlation_id = f"storage-{uuid.uuid4().hex[:8]}"
    log_structured_event(
        correlation_id=correlation_id,
        action="STORAGE_JSON_READ",
        action_path="bot_kie.load_json_file",
        stage="sanitize",
        outcome="fallback_default",
        error_code="STORAGE_JSON_TYPE_INVALID",
        fix_hint="Storage JSON payload –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º; –≤–æ–∑–≤—Ä–∞—â–∞–µ–º default.",
        param={
            "filename": filename,
            "source": source,
            "payload_type": type(payload).__name__,
        },
    )
    logger.warning(
        "STORAGE_JSON_TYPE_INVALID correlation_id=%s filename=%s source=%s payload_type=%s",
        correlation_id,
        filename,
        source,
        type(payload).__name__,
    )
    return default.copy()

def load_json_file(filename: str, default: dict = None) -> dict:
    """Load JSON payload via storage with caching and locking."""
    if default is None:
        default = {}
    
    cache_key = get_cache_key(filename)
    current_time = time.time()
    
    # Check cache first (thread-safe read)
    if cache_key in _data_cache['cache_timestamps']:
        cache_time = _data_cache['cache_timestamps'][cache_key]
        if current_time - cache_time < CACHE_TTL and cache_key in _data_cache:
            if cache_key != filename:  # Only for mapped cache keys
                cached_data = _data_cache.get(cache_key)
                if cached_data is not None:
                    if isinstance(cached_data, dict):
                        return cached_data.copy()
                    _data_cache.pop(cache_key, None)
                    _data_cache['cache_timestamps'].pop(cache_key, None)
                    _normalize_storage_payload(
                        cached_data,
                        filename=filename,
                        source="cache",
                        default=default,
                    )
    
    # Get lock for this file type
    lock_key = cache_key if cache_key in _file_locks else 'balances'  # Default to balances lock
    lock = _file_locks.get(lock_key, _file_locks['balances'])
    
    # Load from storage with lock to prevent race conditions
    with lock:
        try:
            from app.storage.factory import get_storage

            storage = get_storage()
            storage_filename = os.path.basename(filename)
            data = _run_storage_coro_sync(
                storage.read_json_file(storage_filename, default),
                label=f"read:{storage_filename}",
            )
            data = _normalize_storage_payload(
                data,
                filename=filename,
                source="storage",
                default=default,
            )
            if cache_key != filename and isinstance(data, dict):
                _data_cache[cache_key] = data.copy()
                _data_cache['cache_timestamps'][cache_key] = current_time
            return data
        except Exception as e:
            logger.error("Storage read failed for %s: %s", filename, e, exc_info=True)
            return default.copy()


def _sanitize_json_payload(data: dict, *, filename: str) -> dict:
    try:
        json.dumps(data)
        return data
    except TypeError:
        sanitized = json.loads(json.dumps(data, default=str))
        logger.warning(
            "STORAGE_JSON_SANITIZED filename=%s reason=non_serializable_payload",
            filename,
        )
        return sanitized


def save_json_file(filename: str, data: dict, use_cache: bool = True):
    """Save data to storage with cached writes."""
    try:
        cache_key = get_cache_key(filename)
        current_time = time.time()
        safe_data = _sanitize_json_payload(data, filename=filename)
        
        # Update cache immediately
        if use_cache and cache_key != filename:
            _data_cache[cache_key] = safe_data.copy()
            _data_cache['cache_timestamps'][cache_key] = current_time
        
        try:
            from app.storage.factory import get_storage

            storage = get_storage()
            storage_filename = os.path.basename(filename)
            _run_storage_coro_sync(
                storage.write_json_file(storage_filename, safe_data),
                label=f"write:{storage_filename}",
            )
            _last_save_time[filename] = current_time
        except Exception as storage_error:
            logger.error(
                "Storage write failed for %s: %s",
                filename,
                storage_error,
                exc_info=True,
            )
    except Exception as e:
        logger.error(f"‚ùå CRITICAL ERROR saving {filename}: {e}", exc_info=True)


async def _persist_user_registry_batch(batch: Dict[int, Dict[str, Any]]) -> None:
    if not batch:
        return
    try:
        from app.storage.factory import get_storage

        storage = get_storage()
        storage_filename = os.path.basename(USER_REGISTRY_FILE)

        def updater(data: dict) -> dict:
            payload = dict(data or {})
            for user_id, entry in batch.items():
                user_key = str(user_id)
                existing = payload.get(user_key, {})
                payload[user_key] = {**existing, **entry}
            return payload

        await asyncio.wait_for(
            storage.update_json_file(storage_filename, updater),
            timeout=USER_REGISTRY_PERSIST_TIMEOUT_SECONDS,
        )
    except asyncio.TimeoutError:
        logger.warning(
            "USER_REGISTRY_PERSIST_TIMEOUT batch_size=%s timeout_s=%s",
            len(batch),
            USER_REGISTRY_PERSIST_TIMEOUT_SECONDS,
        )
        _mark_storage_degraded("user_registry_update_timeout")
    except Exception as exc:
        logger.warning("USER_REGISTRY_PERSIST_FAILED batch_size=%s error=%s", len(batch), exc)


async def _user_registry_flush_worker() -> None:
    global _user_registry_flush_event, _user_registry_flush_lock
    if _user_registry_flush_event is None:
        _user_registry_flush_event = asyncio.Event()
    if _user_registry_flush_lock is None:
        _user_registry_flush_lock = asyncio.Lock()
    while True:
        await _user_registry_flush_event.wait()
        await asyncio.sleep(USER_REGISTRY_FLUSH_INTERVAL_SECONDS)
        async with _user_registry_flush_lock:
            if not _user_registry_pending:
                _user_registry_flush_event.clear()
                continue
            pending = dict(_user_registry_pending)
            _user_registry_pending.clear()
            _user_registry_flush_event.clear()
        user_ids = list(pending.keys())
        for idx in range(0, len(user_ids), max(1, USER_REGISTRY_FLUSH_MAX_BATCH)):
            batch_ids = user_ids[idx : idx + USER_REGISTRY_FLUSH_MAX_BATCH]
            batch = {uid: pending[uid] for uid in batch_ids}
            await _persist_user_registry_batch(batch)


def _ensure_user_registry_worker() -> None:
    global _user_registry_flush_task
    if _user_registry_flush_task and not _user_registry_flush_task.done():
        return
    loop = None
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:
        loop = None
    if not loop or not loop.is_running():
        return
    _user_registry_flush_task = _create_background_task(
        _user_registry_flush_worker(),
        action="user_registry_flush_worker",
    )


async def upsert_user_registry_entry(
    user: Optional["telegram.User"],
    *,
    correlation_id: Optional[str] = None,
) -> None:
    """Queue user registry update (debounced + batched) for background persistence."""
    if user is None:
        return
    user_id = user.id
    if _user_registry_debouncer.seen(user_id):
        return
    global _user_registry_flush_lock, _user_registry_flush_event
    entry = {
        "user_id": user_id,
        "username": user.username or "",
        "first_name": user.first_name or "",
        "last_name": user.last_name or "",
        "updated_at": datetime.now().isoformat(),
    }
    if _user_registry_flush_lock is None:
        _user_registry_flush_lock = asyncio.Lock()
    if _user_registry_flush_event is None:
        _user_registry_flush_event = asyncio.Event()
    async with _user_registry_flush_lock:
        _user_registry_pending[user_id] = entry
        _user_registry_flush_event.set()
    _ensure_user_registry_worker()
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        action="REGISTRY_UPDATE_QUEUED",
        action_path="user_registry:queue",
        stage="STORAGE",
        outcome="queued",
        param={"debounce_s": USER_REGISTRY_DEBOUNCE_SECONDS},
    )


def get_user_registry_entry(user_id: int) -> dict:
    """Get stored user identity if available."""
    data = load_json_file(USER_REGISTRY_FILE, {})
    return data.get(str(user_id), {})


def _load_jobs_registry() -> dict:
    return load_json_file(JOBS_FILE, {})


def _save_jobs_registry(data: dict) -> None:
    save_json_file(JOBS_FILE, data, use_cache=True)


def _create_job_record(
    *,
    job_id: str,
    user_id: int,
    chat_id: Optional[int],
    message_id: Optional[int],
    model_id: Optional[str],
    correlation_id: Optional[str],
    state: str,
    start_ts_ms: int,
    request_id: Optional[str] = None,
    prompt: Optional[str] = None,
    prompt_hash: Optional[str] = None,
) -> dict:
    data = _load_jobs_registry()
    record = {
        "job_id": job_id,
        "user_id": user_id,
        "chat_id": chat_id,
        "message_id": message_id,
        "model_id": model_id,
        "correlation_id": correlation_id,
        "request_id": request_id,
        "prompt": prompt,
        "prompt_hash": prompt_hash,
        "state": state,
        "start_ts_ms": start_ts_ms,
        "updated_ts_ms": start_ts_ms,
    }
    data[job_id] = record
    _save_jobs_registry(data)
    return record


def _update_job_record(job_id: str, **updates: Any) -> Optional[dict]:
    data = _load_jobs_registry()
    record = data.get(job_id)
    if not record:
        return None
    record.update(updates)
    record["updated_ts_ms"] = updates.get("updated_ts_ms", _now_ms())
    data[job_id] = record
    _save_jobs_registry(data)
    return record


def _get_job_record(job_id: Optional[str]) -> Optional[dict]:
    if not job_id:
        return None
    data = _load_jobs_registry()
    return data.get(job_id)


async def _resolve_task_id_from_job(job_id: str) -> Optional[str]:
    from app.generations.request_dedupe_store import get_task_id_for_job, set_job_task_mapping

    mapped_task_id = await get_task_id_for_job(job_id)
    if mapped_task_id:
        return mapped_task_id
    job_record = _get_job_record(job_id)
    task_id = None
    if job_record:
        task_id = job_record.get("task_id") or job_record.get("external_task_id")
        if task_id:
            await set_job_task_mapping(job_id, task_id)
            return task_id
    from app.storage import get_storage

    storage_instance = get_storage()
    try:
        storage_job = await storage_instance.get_job(job_id)
    except Exception as exc:
        logger.warning("dedupe_job_lookup_failed job_id=%s error=%s", job_id, exc)
        return None
    if not storage_job:
        return None
    task_id = storage_job.get("task_id") or storage_job.get("external_task_id")
    if task_id and job_record:
        _update_job_record(job_id, task_id=task_id, updated_ts_ms=_now_ms())
    if task_id:
        await set_job_task_mapping(job_id, task_id)
    return task_id


def _set_user_ui_action(user_id: int, action: str, ts_ms: int) -> None:
    data = load_json_file(UI_ACTIONS_FILE, {})
    data[str(user_id)] = {"action": action, "ts_ms": ts_ms}
    save_json_file(UI_ACTIONS_FILE, data, use_cache=True)


def _get_user_ui_action(user_id: int) -> dict:
    data = load_json_file(UI_ACTIONS_FILE, {})
    return data.get(str(user_id), {})


def _is_recent_cancel_click(user_id: int, now_ms: int, window_ms: int = 3000) -> bool:
    record = _get_user_ui_action(user_id)
    if record.get("action") != "cancel_click":
        return False
    ts_ms = record.get("ts_ms")
    if not isinstance(ts_ms, int):
        return False
    return 0 <= now_ms - ts_ms <= window_ms


def _log_job_state_update(
    *,
    correlation_id: Optional[str],
    update_id: Optional[int],
    user_id: Optional[int],
    chat_id: Optional[int],
    message_id: Optional[int],
    callback_query_id: Optional[str],
    callback_data: Optional[str],
    job_id: Optional[str],
    state_before: Optional[str],
    state_after: Optional[str],
) -> None:
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="JOB_STATE_UPDATE",
        action_path="job_state",
        stage="JOB_STATE",
        outcome=state_after or "noop",
        param={
            "update_id": update_id,
            "user_id": user_id,
            "chat_id": chat_id,
            "message_id": message_id,
            "callback_query_id": callback_query_id,
            "callback_data": callback_data,
            "job_id": job_id,
            "state_before": state_before,
            "state_after": state_after,
            "ts_ms": _now_ms(),
        },
    )


def _recover_jobs_on_startup() -> None:
    data = _load_jobs_registry()
    if not data:
        return
    now_ms = _now_ms()
    updated = False
    for job_id, record in data.items():
        state = record.get("state")
        if state not in ACTIVE_JOB_STATES_ACTIVE:
            continue
        increment_cancel_metric("worker_restart_detected_total")
        start_ts = record.get("start_ts_ms") or now_ms
        if isinstance(start_ts, str) and start_ts.isdigit():
            start_ts = int(start_ts)
        timed_out = now_ms - int(start_ts) >= JOB_TIMEOUT_MS
        record["state"] = "timed_out"
        record["timed_out_ts_ms"] = now_ms
        record["recovered_ts_ms"] = now_ms
        data[job_id] = record
        updated = True
        if timed_out:
            increment_cancel_metric("job_timeout_total")
        _log_job_state_update(
            correlation_id=record.get("correlation_id"),
            update_id=None,
            user_id=record.get("user_id"),
            chat_id=record.get("chat_id"),
            message_id=record.get("message_id"),
            callback_query_id=None,
            callback_data=None,
            job_id=job_id,
            state_before=state,
            state_after="timed_out",
        )
    if updated:
        _save_jobs_registry(data)


async def _build_referral_info_text(user_id: int, user_lang: str) -> tuple[str, dict]:
    """Build referral info payload and metrics for structured logging."""
    referral_link = get_user_referral_link(user_id)
    stats = await get_referral_stats(user_id)
    remaining_free = await get_user_free_generations_remaining(user_id)

    def _format_stat(value: int) -> str:
        return str(value) if value > 0 else "‚Äî"

    invited_count = int(stats.get("invited", 0))
    activated_count = int(stats.get("activated", 0))
    bonus_total = int(stats.get("bonus_total", 0))
    bonus_total_display = _format_stat(bonus_total)

    referral_text = (
        f'{t("msg_referral_title", lang=user_lang)}\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{t("msg_referral_how_it_works", lang=user_lang, bonus=REFERRAL_BONUS_GENERATIONS)}\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{t("msg_referral_stats", lang=user_lang, invited=_format_stat(invited_count), activated=_format_stat(activated_count), bonus_total=bonus_total_display, remaining=remaining_free)}\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{t("msg_referral_important", lang=user_lang)}\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{t("msg_referral_link_title", lang=user_lang)}\n\n'
        f'<code>{referral_link}</code>\n\n'
        f'üìã <i>–ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Å—Å—ã–ª–∫—É –≤—ã—à–µ, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</i>\n\n'
        f'{t("msg_referral_send", lang=user_lang, bonus=REFERRAL_BONUS_GENERATIONS)}'
    )
    metrics = {
        "invited": invited_count,
        "activated": activated_count,
        "bonus_total": bonus_total,
        "remaining_free": remaining_free,
    }
    return referral_text, metrics


async def handle_referral_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Route handler for the referral/partner button with safe fallback."""
    correlation_id = ensure_correlation_id(update, context)
    query = update.callback_query if update else None
    if not query or not query.from_user:
        return ConversationHandler.END
    user_id = query.from_user.id
    user_lang = get_user_language(user_id)
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=update.effective_chat.id if update and update.effective_chat else None,
        action="REFERRAL_INFO",
        action_path="handle_referral_info",
        outcome="start",
    )
    try:
        try:
            await query.answer()
        except Exception:
            pass
        reset_session_on_navigation(user_id, reason="referral_info")
        referral_text, metrics = await _build_referral_info_text(user_id, user_lang)
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton(t("btn_back_to_menu", lang=user_lang), callback_data="back_to_menu")]]
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=update.effective_chat.id if update and update.effective_chat else None,
            action="REFERRAL_LINK_SHOWN",
            action_path="ui:referral_info",
            outcome="shown",
            param={
                "referrer_id": user_id,
                "bonus_value": REFERRAL_BONUS_GENERATIONS,
                **metrics,
            },
        )
        try:
            await query.edit_message_text(
                referral_text,
                reply_markup=keyboard,
                parse_mode="HTML",
            )
        except Exception as exc:
            logger.warning("referral_info_edit_failed user_id=%s error=%s", user_id, exc)
            await query.message.reply_text(
                referral_text,
                reply_markup=keyboard,
                parse_mode="HTML",
            )
        return ConversationHandler.END
    except Exception as exc:
        logger.error("referral_info_failed user_id=%s error=%s", user_id, exc, exc_info=True)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=update.effective_chat.id if update and update.effective_chat else None,
            action="REFERRAL_INFO",
            action_path="handle_referral_info",
            outcome="failed",
            error_code="REFERRAL_INFO_FAILED",
            fix_hint=str(exc),
        )
        try:
            fallback_text = build_error_message(correlation_id, lang=user_lang)
            await query.answer(fallback_text.replace("<b>", "").replace("</b>", ""), show_alert=False)
        except Exception:
            pass
        try:
            await ensure_main_menu(
                update,
                context,
                source="referral_info_fallback",
                prefer_edit=True,
            )
        except Exception:
            pass
        return ConversationHandler.END


async def _check_and_deliver_pending_results(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Check for timed-out/running jobs and attempt late delivery."""
    user_id = update.effective_user.id if update and update.effective_user else None
    if not user_id:
        return
    now = time.monotonic()
    last_check = _pending_result_checks.get(user_id, 0.0)
    if now - last_check < 8:
        return
    _pending_result_checks[user_id] = now
    from app.storage import get_storage
    from app.integrations.kie_stub import get_kie_client_or_stub
    from app.delivery.reconciler import deliver_job_result
    from app.generations.state_machine import normalize_provider_state

    storage = get_storage()
    jobs = await storage.list_jobs(user_id=user_id, limit=10)
    pending_jobs = [
        job for job in jobs
        if job.get("status")
        in {
            "timeout",
            "pending",
            "queued",
            "waiting",
            "success",
            "result_validated",
            "tg_deliver",
            "delivery_pending",
            "running",
        }
    ]
    if not pending_jobs:
        return
    client = get_kie_client_or_stub()
    for job in pending_jobs:
        task_id = job.get("task_id") or job.get("external_task_id")
        if not task_id:
            continue
        correlation_id = job.get("correlation_id") or job.get("request_id")
        try:
            status = await client.get_task_status(task_id, correlation_id=correlation_id)
        except Exception:
            continue
        resolution = normalize_provider_state(status.get("state"))
        state = resolution.canonical_state
        status["_raw_state"] = resolution.raw_state
        status["state"] = state
        status["taskId"] = task_id
        if state == "success":
            await deliver_job_result(
                context.bot,
                storage,
                job=job,
                status_record=status,
                notify_user=True,
                source="pending_result_check",
                get_user_language=get_user_language,
            )
        elif state in {"failed", "canceled"}:
            await storage.update_job_status(
                job.get("job_id") or task_id,
                "failed",
                error_message=status.get("failMsg"),
                error_code=status.get("failCode") or "KIE_FAIL_STATE",
            )


async def build_admin_user_overview(target_user_id: int) -> tuple[str, InlineKeyboardMarkup]:
    """Build admin overview text and keyboard for a user."""
    registry_entry = get_user_registry_entry(target_user_id)
    username = registry_entry.get("username") or ""
    first_name = registry_entry.get("first_name") or ""
    last_name = registry_entry.get("last_name") or ""
    full_name = " ".join([name for name in [first_name, last_name] if name]).strip() or "‚Äî"
    username_text = f"@{username}" if username else "‚Äî"

    balance = await get_user_balance_async(target_user_id)
    balance_str = format_rub_amount(balance)
    user_payments = get_user_payments(target_user_id)
    total_paid = sum(p.get("amount", 0) for p in user_payments)
    total_paid_str = format_rub_amount(total_paid)

    lines = [
        f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {target_user_id}",
        f"üßæ <b>–ù–∏–∫:</b> {username_text}",
        f"üìõ <b>–ò–º—è:</b> {full_name}",
        f"üí∞ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str}",
        f"üíµ <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–æ –≤—Å–µ–≥–æ:</b> {total_paid_str}",
        f"üìù <b>–ü–ª–∞—Ç–µ–∂–µ–π:</b> {len(user_payments)}",
    ]

    if user_payments:
        lines.append("\n<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:</b>")
        for payment in user_payments[:5]:
            amount_str = format_rub_amount(payment.get("amount", 0))
            timestamp = payment.get("timestamp")
            if timestamp:
                dt = datetime.fromtimestamp(timestamp)
                date_str = dt.strftime("%d.%m.%Y %H:%M")
            else:
                date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            lines.append(f"‚Ä¢ {amount_str} | {date_str}")

    text = "\n".join(lines)
    keyboard = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("‚ûï –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data=f"admin_topup_user:{target_user_id}")],
            [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=f"admin_user_info:{target_user_id}")],
            [InlineKeyboardButton("üè† –í –º–µ–Ω—é", callback_data="back_to_menu")],
        ]
    )
    return text, keyboard


async def get_http_client() -> aiohttp.ClientSession:
    """Get or create global HTTP client with connection pooling."""
    global _http_client
    if _http_client is None or _http_client.closed:
        connector = aiohttp.TCPConnector(
            limit=100,  # Max connections
            limit_per_host=30,  # Max connections per host
            ttl_dns_cache=300,  # DNS cache TTL
            use_dns_cache=True,
        )
        timeout = aiohttp.ClientTimeout(total=60, connect=10)
        _http_client = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': 'TelegramBot/1.0'}
        )
    return _http_client


async def cleanup_http_client():
    """Close HTTP client on shutdown."""
    global _http_client
    if _http_client and not _http_client.closed:
        await _http_client.close()
        _http_client = None


async def cleanup_storage():
    """Close storage sessions on shutdown."""
    try:
        from app.storage.factory import get_storage

        storage_instance = get_storage()
        close_method = getattr(storage_instance, "close", None)
        if close_method:
            result = close_method()
            if asyncio.iscoroutine(result):
                await result
    except Exception as exc:
        logger.warning("Failed to close storage cleanly: %s", exc)


def cleanup_old_sessions(max_age_seconds: int = 3600):
    """Clean up old user sessions to prevent memory leaks (optimized for 1000+ users)."""
    current_time = time.time()
    keys_to_remove = []
    
    for user_id, session in user_sessions.items():
        session_time = session.get('last_activity', current_time)
        if current_time - session_time > max_age_seconds:
            keys_to_remove.append(user_id)
    
    for key in keys_to_remove:
        del user_sessions[key]
    
    if keys_to_remove:
        logger.info(f"Cleaned up {len(keys_to_remove)} old user sessions")


def update_session_activity(user_id: int):
    """Update last activity time for user session."""
    if user_id in user_sessions:
        user_sessions[user_id]['last_activity'] = time.time()


def _clear_session_flow_keys(session: dict, *, clear_gen_type: bool) -> list[str]:
    cleared_keys: list[str] = []
    for key in (
        "waiting_for",
        "current_param",
        "model_id",
        "model_info",
        "model_spec",
        "param_history",
        "param_order",
        "params",
        "properties",
        "required",
        "required_original",
        "required_forced_media",
        "optional_media_params",
        "image_ref_prompt",
        "ssot_conflicts",
        "skipped_params",
        "payment_method",
        "topup_amount",
        "stars_amount",
        "invoice_payload",
        "balance_charged",
        "active_model_id",
    ):
        if key in session:
            session.pop(key, None)
            cleared_keys.append(key)
    if clear_gen_type:
        for key in ("active_gen_type", "gen_type"):
            if key in session:
                session.pop(key, None)
                cleared_keys.append(key)
    return cleared_keys


def reset_session_context(
    user_id: int,
    *,
    reason: str,
    clear_gen_type: bool,
    correlation_id: Optional[str] = None,
    update_id: Optional[int] = None,
    chat_id: Optional[int] = None,
) -> None:
    """Clear flow-specific session data when user navigates to a new context."""
    if user_id not in user_sessions:
        return
    session = user_sessions[user_id]
    from_context = session.get("ui_context")
    cleared_keys = _clear_session_flow_keys(session, clear_gen_type=clear_gen_type)
    if cleared_keys:
        logger.info(
            "üßπ SESSION_RESET: action_path=%s cleared=%s",
            reason,
            ",".join(cleared_keys),
        )
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="SESSION_CONTEXT_RESET",
        action_path=reason,
        model_id=session.get("active_model_id") or session.get("model_id"),
        gen_type=session.get("active_gen_type") or session.get("gen_type"),
        stage="SESSION",
        outcome="cleared" if cleared_keys else "no_op",
        param={
            "from_context": from_context,
            "to_context": session.get("ui_context"),
            "cleared_keys": cleared_keys,
        },
    )
    if session.get("model_id") is None and any(
        key in session for key in ("params", "properties", "required", "waiting_for", "current_param")
    ):
        clear_user_session(user_id, reason=f"{reason}:stale_model_id")


def set_session_context(
    user_id: int,
    *,
    to_context: str,
    reason: str,
    active_gen_type: Optional[str] = None,
    active_model_id: Optional[str] = None,
    clear_gen_type: bool = False,
    correlation_id: Optional[str] = None,
    update_id: Optional[int] = None,
    chat_id: Optional[int] = None,
) -> None:
    session = user_sessions.ensure(user_id)
    from_context = session.get("ui_context")
    if clear_gen_type:
        for key in ("active_gen_type", "gen_type"):
            session.pop(key, None)
    if active_gen_type is not None:
        session["active_gen_type"] = active_gen_type
        session["gen_type"] = active_gen_type
    if active_model_id is not None:
        session["active_model_id"] = active_model_id
    session["ui_context"] = to_context
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="SESSION_CONTEXT_SET",
        action_path=reason,
        model_id=session.get("active_model_id") or session.get("model_id"),
        gen_type=session.get("active_gen_type") or session.get("gen_type"),
        stage="SESSION",
        outcome="updated",
        param={
            "from_context": from_context,
            "to_context": to_context,
            "cleared_keys": ["active_gen_type", "gen_type"] if clear_gen_type else [],
        },
    )


def reset_session_on_navigation(user_id: int, *, reason: str) -> None:
    """Backward-compatible wrapper for legacy reset semantics."""
    reset_session_context(user_id, reason=reason, clear_gen_type=False)


def clear_user_session(user_id: int, *, reason: str) -> None:
    """Hard reset session state to avoid stale keys."""
    session = user_sessions.get(user_id)
    if session is None:
        return
    session.clear()
    session["last_activity"] = time.time()
    logger.info("üßπ SESSION_RESET_FULL: action_path=%s user_id=%s", reason, user_id)


def _generation_submit_lock_remaining(lock_key: str) -> float:
    last = generation_submit_locks.get(lock_key)
    if not last:
        return 0.0
    elapsed = time.time() - last
    return max(0.0, GENERATION_SUBMIT_LOCK_TTL_SECONDS - elapsed)


def _build_request_fingerprint(model_id: str, params: Optional[Dict[str, Any]]) -> str:
    payload = {
        "model_id": model_id or "",
        "params": params or {},
    }
    try:
        serialized = json.dumps(payload, ensure_ascii=False, sort_keys=True, default=str)
    except Exception:
        serialized = f"{model_id}:{str(params)}"
    return hashlib.sha256(serialized.encode("utf-8")).hexdigest()[:12]


def _build_generation_submit_lock_key(
    *,
    partner_id: str,
    user_id: int,
    chat_id: int,
    fingerprint: str,
) -> str:
    safe_partner = partner_id or "default"
    return f"{safe_partner}:{user_id}:{chat_id}:{fingerprint}"


def _is_terminal_job_status(status: Optional[str]) -> bool:
    if not status:
        return False
    return status in ACTIVE_JOB_STATES_TERMINAL


def _clear_session_task_id(
    session: Optional[Dict[str, Any]],
    *,
    reason: str,
    task_id: Optional[str] = None,
    allow_mismatch: bool = False,
) -> bool:
    if not isinstance(session, dict):
        return False
    current_task_id = session.get("task_id")
    if current_task_id is None:
        return False
    if task_id and current_task_id != task_id and not allow_mismatch:
        logger.info(
            "üßπ TASK_CONTEXT_SKIP_CLEAR: reason=%s task_id=%s current_task_id=%s",
            reason,
            task_id,
            current_task_id,
        )
        return False
    session.pop("task_id", None)
    session.pop("task_terminal_state", None)
    session["last_activity"] = time.time()
    logger.info(
        "üßπ TASK_CONTEXT_CLEARED: reason=%s task_id=%s",
        reason,
        current_task_id,
    )
    return True


def _clear_user_task_context(
    user_id: int,
    *,
    reason: str,
    task_id: Optional[str] = None,
    allow_mismatch: bool = False,
) -> None:
    session = user_sessions.get(user_id)
    cleared = _clear_session_task_id(
        session,
        reason=reason,
        task_id=task_id,
        allow_mismatch=allow_mismatch,
    )
    if not cleared:
        logger.debug(
            "TASK_CONTEXT_NOT_CLEARED: reason=%s user_id=%s task_id=%s",
            reason,
            user_id,
            task_id,
        )


def _build_task_already_started_keyboard(
    user_lang: str,
    *,
    task_id: str,
    job_id: Optional[str],
) -> InlineKeyboardMarkup:
    status_label = "üìä –°—Ç–∞—Ç—É—Å" if user_lang == "ru" else "üìä Status"
    open_label = "üìÇ –û—Ç–∫—Ä—ã—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç" if user_lang == "ru" else "üìÇ Open result"
    cancel_label = "üõë –û—Ç–º–µ–Ω–∞" if user_lang == "ru" else "üõë Cancel"
    cancel_callback = _build_cancel_callback(job_id) if job_id else "cancel"
    return InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton(status_label, callback_data="my_generations"),
                InlineKeyboardButton(open_label, callback_data=f"open_result:{task_id}"),
            ],
            [
                InlineKeyboardButton(cancel_label, callback_data=cancel_callback),
                InlineKeyboardButton(t("btn_home", lang=user_lang), callback_data="back_to_menu"),
            ],
        ]
    )


def _build_task_already_started_text(user_lang: str, task_id: str) -> str:
    if user_lang == "ru":
        return (
            "‚ÑπÔ∏è <b>–ó–∞–¥–∞—á–∞ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞</b>\n\n"
            "–ú—ã —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —ç—Ç–æ—Ç –∑–∞–ø—Ä–æ—Å. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å, –æ—Ç–∫—Ä—ã—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç "
            "–∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–¥–∞—á—É.\n\n"
            f"Task ID: <code>{task_id}</code>"
        )
    return (
        "‚ÑπÔ∏è <b>Task already started</b>\n\n"
        "This request is already running. You can check the status, open the result, "
        "or cancel the task.\n\n"
        f"Task ID: <code>{task_id}</code>"
    )


async def _show_task_already_started(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    user_lang: str,
    task_id: str,
    job_id: Optional[str],
    reason: str,
    correlation_id: Optional[str],
) -> None:
    query = update.callback_query
    chat_id = query.message.chat_id if query and query.message else None
    log_structured_event(
        correlation_id=correlation_id,
        user_id=update.effective_user.id if update.effective_user else None,
        chat_id=chat_id,
        action="CONFIRM_GENERATE",
        action_path="confirm_generate",
        outcome=reason,
        task_id=task_id,
        job_id=job_id,
        dedup_hit=True,
    )
    text = _build_task_already_started_text(user_lang, task_id)
    keyboard = _build_task_already_started_keyboard(user_lang, task_id=task_id, job_id=job_id)
    if query and query.message:
        try:
            await query.edit_message_text(text, parse_mode="HTML", reply_markup=keyboard)
            return
        except Exception:
            pass
        await query.message.reply_text(text, parse_mode="HTML", reply_markup=keyboard)
        return
    chat = update.effective_chat
    if chat:
        try:
            await context.bot.send_message(chat_id=chat.id, text=text, parse_mode="HTML", reply_markup=keyboard)
        except Exception as exc:
            logger.warning("task_already_started_notify_failed chat_id=%s error=%s", chat.id, exc)


async def _acquire_generation_submit_lock(lock_key: str) -> bool:
    now = time.time()
    async with generation_submit_locks_guard:
        last = generation_submit_locks.get(lock_key)
        if last and now - last < GENERATION_SUBMIT_LOCK_TTL_SECONDS:
            return False
        generation_submit_locks[lock_key] = now
    return True


def _release_generation_submit_lock(lock_key: str) -> None:
    generation_submit_locks.pop(lock_key, None)

def _cleanup_processed_updates(now_ts: float) -> None:
    expired = [
        update_id
        for update_id, ts in _processed_update_ids.items()
        if now_ts - ts > _processed_update_ttl_seconds
    ]
    for update_id in expired:
        _processed_update_ids.pop(update_id, None)


def _should_dedupe_update(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    action: str,
    action_path: str,
    user_id: Optional[int],
    chat_id: Optional[int],
) -> bool:
    update_id = getattr(update, "update_id", None)
    if update_id is None:
        return False
    now_ts = time.time()
    _cleanup_processed_updates(now_ts)
    if update_id in _processed_update_ids:
        correlation_id = ensure_correlation_id(update, context)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action=action,
            action_path=action_path,
            stage="dedup",
            outcome="deduped",
            error_code=None,
            fix_hint="duplicate_update_id",
        )
        return True
    _processed_update_ids[update_id] = now_ts
    return False


def _guard_sync_wrapper_in_event_loop(wrapper_name: str) -> None:
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:
        return
    if loop.is_running():
        import traceback

        stack = "".join(traceback.format_stack(limit=12))
        logger.error(
            "SYNC_WRAPPER_CALLED_IN_ASYNC wrapper=%s stack=%s",
            wrapper_name,
            stack,
        )
        raise RuntimeError(f"{wrapper_name} called inside running event loop")


_storage_executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)
_storage_sync_warned: set[str] = set()


def _run_storage_coro_sync(coro, *, label: str = "storage_call"):
    storage_mode = os.getenv("STORAGE_MODE", "unknown")
    partner_id = (os.getenv("PARTNER_ID") or os.getenv("BOT_INSTANCE_ID") or "unknown").strip()
    try:
        asyncio.get_running_loop()
    except RuntimeError:
        return asyncio.run(coro)
    if label not in _storage_sync_warned:
        _storage_sync_warned.add(label)
        logger.debug(
            "STORAGE_SYNC_CALL_IN_RUNNING_LOOP label=%s storage_mode=%s partner_id=%s",
            label,
            storage_mode,
            partner_id,
        )
    future = _storage_executor.submit(lambda: asyncio.run(coro))
    try:
        return future.result(timeout=STORAGE_IO_TIMEOUT_SECONDS)
    except concurrent.futures.TimeoutError as exc:
        logger.error(
            "SYNC_STORAGE_CALL_TIMEOUT label=%s timeout=%.2fs storage_mode=%s partner_id=%s",
            label,
            STORAGE_IO_TIMEOUT_SECONDS,
            storage_mode,
            partner_id,
        )
        raise TimeoutError(f"{label} timed out after {STORAGE_IO_TIMEOUT_SECONDS}s") from exc
    except Exception as exc:
        logger.error("SYNC_STORAGE_CALL_FAILED label=%s error=%s", label, exc, exc_info=True)
        raise


def get_user_balance(user_id: int) -> float:
    """Get user balance in rubles (synchronous wrapper for storage)."""
    import asyncio
    from app.services.user_service import get_user_balance as get_balance_async

    _guard_sync_wrapper_in_event_loop("get_user_balance")
    try:
        return asyncio.run(get_balance_async(user_id))
    except Exception as e:
        logger.error(f"‚ùå Error getting user balance: {e}", exc_info=True)
        return 0.0


def set_user_balance(user_id: int, amount: float):
    """Set user balance in rubles (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import (
        get_user_balance as get_balance_async,
        set_user_balance as set_balance_async,
    )
    logger.info(f"üí∞üí∞üí∞ SET_BALANCE: user_id={user_id}, amount={amount:.2f} ‚ÇΩ")

    _guard_sync_wrapper_in_event_loop("set_user_balance")
    try:
        asyncio.run(set_balance_async(user_id, amount))
        verified_balance = asyncio.run(get_balance_async(user_id))
        logger.info(
            "BALANCE VERIFIED: user_id=%s balance=%.2f ‚ÇΩ",
            user_id,
            verified_balance,
        )
    except Exception as e:
        logger.error(f"‚ùå Error setting user balance: {e}", exc_info=True)


def add_user_balance(user_id: int, amount: float) -> float:
    """Add amount to user balance, return new balance (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import add_user_balance as add_balance_async
    logger.info(f"üí∞üí∞üí∞ ADD_BALANCE: user_id={user_id}, amount={amount:.2f} ‚ÇΩ")

    _guard_sync_wrapper_in_event_loop("add_user_balance")
    try:
        return asyncio.run(add_balance_async(user_id, amount))
    except Exception as e:
        logger.error(f"‚ùå Error adding user balance: {e}", exc_info=True)
        return get_user_balance(user_id)  # Return current balance on error


def subtract_user_balance(user_id: int, amount: float) -> bool:
    """Subtract amount from user balance. Returns True if successful, False if insufficient funds (synchronous wrapper for storage)."""
    # Use storage layer through async wrapper (blocking call)
    import asyncio
    from app.services.user_service import subtract_user_balance as subtract_balance_async

    _guard_sync_wrapper_in_event_loop("subtract_user_balance")
    try:
        return asyncio.run(subtract_balance_async(user_id, amount))
    except Exception as e:
        logger.error(f"‚ùå Error subtracting user balance: {e}", exc_info=True)
        return False


# ==================== Async wrappers for storage operations ====================
# These use storage layer (async) - no blocking operations

async def get_user_balance_async(user_id: int) -> float:
    """Async get user balance using storage layer."""
    from app.services.user_service import get_user_balance as get_balance_async
    return await get_balance_async(user_id)


async def set_user_balance_async(user_id: int, amount: float):
    """Async set user balance using storage layer."""
    from app.services.user_service import set_user_balance as set_balance_async
    await set_balance_async(user_id, amount)


async def add_user_balance_async(user_id: int, amount: float) -> float:
    """Async add to user balance using storage layer."""
    from app.services.user_service import add_user_balance as add_balance_async
    return await add_balance_async(user_id, amount)


async def subtract_user_balance_async(user_id: int, amount: float) -> bool:
    """Async subtract from user balance using storage layer."""
    from app.services.user_service import subtract_user_balance as subtract_balance_async
    return await subtract_balance_async(user_id, amount)


def db_update_user_balance(user_id: int, amount: float):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞–ø—Ä—è–º—É—é –≤ –ë–î (–¥–ª—è —Ç–µ—Å—Ç–æ–≤/–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏).
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–æ–º.
    
    Args:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        amount: –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å
    """
    logger.info(f"db_update_user_balance: user_id={user_id}, amount={amount:.2f} ‚ÇΩ")
    set_user_balance(user_id, amount)


# ==================== User Language System ====================

# –ö—ç—à –¥–ª—è —è–∑—ã–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
_user_language_cache = {}
_user_language_cache_time = {}
CACHE_TTL_LANGUAGE = 300  # 5 –º–∏–Ω—É—Ç

def get_user_language(user_id: int) -> str:
    """Get user language preference (default: 'ru') with caching.
    
    IMPORTANT: Never blocks event loop. Returns cached value or default 'ru'.
    Background refresh happens via async path.
    """
    user_key = str(user_id)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à - –µ—Å–ª–∏ –µ—Å—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–∞–∑—É
    current_time = time.time()
    if user_key in _user_language_cache:
        cache_time = _user_language_cache_time.get(user_key, 0)
        if current_time - cache_time < CACHE_TTL_LANGUAGE:
            return _user_language_cache[user_key]
        # Cache expired but still return cached value, don't block
        return _user_language_cache[user_key]
    
    # No cache - return default 'ru' immediately, don't block event loop
    # The language will be loaded async when user explicitly sets it
    return 'ru'

def has_user_language_set(user_id: int) -> bool:
    """Check if user has explicitly set their language preference.
    
    IMPORTANT: Never blocks event loop. Returns True only if cached.
    """
    user_key = str(user_id)
    # Only check cache - don't block on storage read
    return user_key in _user_language_cache


def set_user_language(user_id: int, language: str):
    """Set user language preference ('ru' or 'en') and update cache.
    
    Updates cache immediately, saves to storage in background.
    """
    user_key = str(user_id)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à —Å—Ä–∞–∑—É - —ç—Ç–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç
    _user_language_cache[user_key] = language
    _user_language_cache_time[user_key] = time.time()
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ storage –≤ —Ñ–æ–Ω–µ
    async def _save_language_async():
        try:
            from app.storage.factory import get_storage
            storage = get_storage()
            if storage:
                storage_filename = os.path.basename(USER_LANGUAGES_FILE)
                await storage.update_json_file(
                    storage_filename,
                    lambda data: {**data, user_key: language}
                )
        except Exception as e:
            logger.warning("Failed to save user language to storage: %s", e)
    
    # Schedule background save
    try:
        loop = asyncio.get_running_loop()
        loop.create_task(_save_language_async())
    except RuntimeError:
        # No running loop - save synchronously (rare case)
        try:
            languages = load_json_file(USER_LANGUAGES_FILE, {})
            languages[user_key] = language
            save_json_file(USER_LANGUAGES_FILE, languages)
        except Exception as e:
            logger.warning("Failed to save user language: %s", e)


# ==================== Gift System ====================

# Cache for gift claimed status
_gift_claimed_cache: dict[str, bool] = {}

def has_claimed_gift(user_id: int) -> bool:
    """Check if user has already claimed their gift.
    
    IMPORTANT: Never blocks event loop. Returns cached value or False.
    """
    user_key = str(user_id)
    # Only check cache - don't block on storage read
    return _gift_claimed_cache.get(user_key, False)


def set_gift_claimed(user_id: int):
    """Mark gift as claimed for user.
    
    Updates cache immediately, saves to storage in background.
    """
    user_key = str(user_id)
    
    # Update cache immediately
    _gift_claimed_cache[user_key] = True
    
    # Save to storage in background
    async def _save_gift_claimed_async():
        try:
            from app.storage.factory import get_storage
            storage = get_storage()
            if storage:
                storage_filename = os.path.basename(GIFT_CLAIMED_FILE)
                await storage.update_json_file(
                    storage_filename,
                    lambda data: {**data, user_key: True}
                )
        except Exception as e:
            logger.warning("Failed to save gift claimed to storage: %s", e)
    
    try:
        loop = asyncio.get_running_loop()
        loop.create_task(_save_gift_claimed_async())
    except RuntimeError:
        try:
            claimed = load_json_file(GIFT_CLAIMED_FILE, {})
            claimed[user_key] = True
            save_json_file(GIFT_CLAIMED_FILE, claimed)
        except Exception as e:
            logger.warning("Failed to save gift claimed: %s", e)


def spin_gift_wheel() -> float:
    """Spin the gift wheel and return random amount between 10 and 30 rubles."""
    import random
    # Generate random amount between 10 and 30 with 2 decimal places
    amount = round(random.uniform(10.0, 30.0), 2)
    return amount


# ==================== Free Generations System ====================

# Cache for free generations data
_free_generations_cache: dict = {}
_free_generations_cache_time: float = 0
FREE_GENERATIONS_CACHE_TTL = 60  # 1 minute

def get_free_generations_data() -> dict:
    """Get daily free generations data.
    
    IMPORTANT: Returns cached data or empty dict. Never blocks.
    """
    global _free_generations_cache_time
    current_time = time.time()
    
    # Return cached data if fresh enough
    if current_time - _free_generations_cache_time < FREE_GENERATIONS_CACHE_TTL:
        return _free_generations_cache.copy()
    
    # Return cached data even if stale - don't block
    if _free_generations_cache:
        return _free_generations_cache.copy()
    
    # No cache - return empty, will be populated by async calls
    return {}


def save_free_generations_data(data: dict):
    """Save daily free generations data.
    
    Updates cache immediately, saves in background.
    """
    global _free_generations_cache, _free_generations_cache_time
    
    # Update cache immediately
    _free_generations_cache = data.copy()
    _free_generations_cache_time = time.time()
    
    # Save in background
    async def _save_async():
        try:
            from app.storage.factory import get_storage
            storage = get_storage()
            if storage:
                storage_filename = os.path.basename(FREE_GENERATIONS_FILE)
                await storage.write_json_file(storage_filename, data)
        except Exception as e:
            logger.warning("Failed to save free generations data: %s", e)
    
    try:
        loop = asyncio.get_running_loop()
        loop.create_task(_save_async())
    except RuntimeError:
        try:
            save_json_file(FREE_GENERATIONS_FILE, data)
        except Exception as e:
            logger.warning("Failed to save free generations: %s", e)


def get_user_free_generations_today(user_id: int) -> int:
    """Get number of free generations used by user today.
    
    IMPORTANT: Never blocks. Returns cached value or 0.
    """
    from datetime import datetime
    
    data = get_free_generations_data()
    user_key = str(user_id)
    today = datetime.now().strftime('%Y-%m-%d')
    
    if user_key not in data:
        return 0
    
    user_data = data[user_key]
    if user_data.get('date') == today:
        return user_data.get('count', 0)
    else:
        # Reset for new day
        return 0


async def get_user_free_generations_remaining(user_id: int) -> int:
    """Get remaining free generations for user today (including referral bank)."""
    status = await get_free_generation_status(user_id)
    return int(status.get("total_remaining", 0))


async def use_free_generation(user_id: int, sku_id: str, *, correlation_id: Optional[str] = None) -> bool:
    """Consume a free generation if available."""
    result = await check_and_consume_free_generation(user_id, sku_id, correlation_id=correlation_id)
    return result.get("status") == "ok"


async def is_free_generation_available(user_id: int, sku_id: str) -> bool:
    """Check if free generation is available for this user and model."""
    from app.pricing.free_policy import is_sku_free_daily

    if not is_sku_free_daily(sku_id):
        return False
    status = await get_free_generation_status(user_id)
    return int(status.get("total_remaining", 0)) > 0


def _format_free_counter_line(
    remaining: int,
    limit_per_day: int,
    next_refill_in: int,
    user_lang: str,
    *,
    is_admin: bool = False,
) -> str:
    return format_free_counter_block(
        remaining,
        limit_per_day,
        next_refill_in,
        user_lang=user_lang,
        is_admin=is_admin,
    )


def _append_free_counter_text(text: str, line: str) -> str:
    if not line:
        return text
    return f"{text}\n\n{line}"


def _ensure_session_task_registry(session: Dict[str, Any], key: str) -> Set[str]:
    registry = session.get(key)
    if isinstance(registry, set):
        return registry
    if isinstance(registry, list):
        registry = set(registry)
    else:
        registry = set()
    session[key] = registry
    return registry


async def _charge_balance_once(
    *,
    user_id: int,
    task_id: Optional[str],
    sku_id: str,
    model_id: Optional[str],
    price: float,
    correlation_id: Optional[str],
    chat_id: Optional[int],
) -> Dict[str, Any]:
    from app.storage.factory import get_storage
    from app.utils.distributed_lock import distributed_lock

    if not task_id:
        if correlation_id:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="CHARGE_COMMIT",
                action_path="delivery",
                model_id=model_id,
                stage="CHARGE_COMMIT",
                outcome="missing_task_id_fallback",
                error_code="MISSING_TASK_ID",
                fix_hint="–î–æ–±–∞–≤—å—Ç–µ task_id –¥–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ —Å–ø–∏—Å–∞–Ω–∏–π.",
                param={"amount": price},
            )
            lock_key = f"balance:{user_id}:{correlation_id}"
            async with distributed_lock(lock_key, ttl_seconds=15, wait_seconds=3) as acquired:
                if not acquired:
                    log_structured_event(
                        correlation_id=correlation_id,
                        user_id=user_id,
                        chat_id=chat_id,
                        action="CHARGE_COMMIT",
                        action_path="delivery",
                        model_id=model_id,
                        stage="CHARGE_COMMIT",
                        outcome="lock_failed",
                        error_code="BALANCE_LOCK",
                        fix_hint="Redis lock –∑–∞–Ω—è—Ç; –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ —Å–ø–∏—Å–∞–Ω–∏–µ.",
                        param={"amount": price},
                    )
                    return {"status": "lock_failed"}
        before_balance = await get_user_balance_async(user_id)
        if before_balance < price:
            return {"status": "insufficient", "balance_before": before_balance, "balance_after": before_balance}
        success = await subtract_user_balance_async(user_id, price)
        after_balance = await get_user_balance_async(user_id) if success else before_balance
        return {
            "status": "charged" if success else "failed",
            "balance_before": before_balance,
            "balance_after": after_balance,
        }

    storage = get_storage()
    if hasattr(storage, "charge_balance_once"):
        lock_key = f"balance:{user_id}:{task_id}"
        async with distributed_lock(lock_key, ttl_seconds=15, wait_seconds=3) as acquired:
            if not acquired:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    action="CHARGE_COMMIT",
                    action_path="delivery",
                    model_id=model_id,
                    stage="CHARGE_COMMIT",
                    outcome="lock_failed",
                    error_code="BALANCE_LOCK",
                    fix_hint="Redis lock –∑–∞–Ω—è—Ç; –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ —Å–ø–∏—Å–∞–Ω–∏–µ.",
                    param={"task_id": task_id, "sku_id": sku_id, "amount": price},
                )
                return {"status": "lock_failed"}
            return await storage.charge_balance_once(
                user_id,
                price,
                task_id=task_id,
                sku_id=sku_id,
                model_id=model_id or "",
            )

    before_balance = await get_user_balance_async(user_id)
    if before_balance < price:
        return {"status": "insufficient", "balance_before": before_balance, "balance_after": before_balance}
    success = await subtract_user_balance_async(user_id, price)
    after_balance = await get_user_balance_async(user_id) if success else before_balance
    return {
        "status": "charged" if success else "failed",
        "balance_before": before_balance,
        "balance_after": after_balance,
    }


async def _commit_post_delivery_charge(
    *,
    session: Dict[str, Any],
    user_id: int,
    chat_id: Optional[int],
    task_id: Optional[str],
    sku_id: str,
    price: float,
    is_free: bool,
    is_admin_user: bool,
    correlation_id: Optional[str],
    model_id: Optional[str],
) -> Dict[str, Any]:
    outcome: Dict[str, Any] = {"charged": False, "free_consumed": False}
    task_key = task_id or correlation_id or f"task-unknown:{uuid.uuid4().hex[:8]}"

    if is_admin_user:
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="admin_free",
            param={
                "task_id": task_id,
                "amount": price,
                "delivered": True,
                "is_admin": True,
            },
        )
        return outcome

    if is_free:
        registry = _ensure_session_task_registry(session, "free_consumed_task_ids")
        if task_key in registry:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="FREE_DEDUCT_COMMIT",
                action_path="delivery",
                model_id=model_id,
                stage="FREE_DEDUCT",
                outcome="duplicate_skip",
                param={"task_id": task_id, "sku_id": sku_id, "delivered": True},
            )
            return outcome
        import inspect

        consume_kwargs = {"correlation_id": correlation_id, "source": "delivery"}
        if "task_id" in inspect.signature(consume_free_generation).parameters:
            consume_kwargs["task_id"] = task_id
        consume_result = await consume_free_generation(
            user_id,
            sku_id,
            **consume_kwargs,
        )
        registry.add(task_key)
        if consume_result.get("status") == "ok":
            outcome["free_consumed"] = True
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="FREE_DEDUCT_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="FREE_DEDUCT",
            outcome=consume_result.get("status", "unknown"),
            param={
                "task_id": task_id,
                "sku_id": sku_id,
                "delivered": True,
                "used_today": consume_result.get("used_today"),
                "remaining": consume_result.get("remaining"),
                "limit_per_day": consume_result.get("limit_per_day"),
            },
        )
        return outcome

    if price <= 0:
        return outcome

    registry = _ensure_session_task_registry(session, "charged_task_ids")
    if task_key in registry or session.get("balance_charged"):
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="duplicate_skip",
            param={"task_id": task_id, "amount": price, "delivered": True},
        )
        return outcome

    charge_result = await _charge_balance_once(
        user_id=user_id,
        task_id=task_id,
        sku_id=sku_id,
        model_id=model_id,
        price=price,
        correlation_id=correlation_id,
        chat_id=chat_id,
    )
    if charge_result.get("status") == "insufficient":
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="insufficient_funds",
            param={
                "task_id": task_id,
                "required": price,
                "available": charge_result.get("balance_before"),
            },
        )
        logger.error(
            "‚ùå Insufficient balance: user=%s required=%.2f available=%.2f",
            user_id,
            price,
            charge_result.get("balance_before", 0.0),
        )
        return outcome

    if charge_result.get("status") == "duplicate":
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="duplicate_skip",
            param={
                "task_id": task_id,
                "amount": price,
                "delivered": True,
            },
        )
        return outcome

    if charge_result.get("status") == "lock_failed":
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="lock_failed",
            error_code="BALANCE_LOCK",
            fix_hint="Redis lock –∑–∞–Ω—è—Ç; –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ —Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–∑–∂–µ.",
            param={"task_id": task_id, "amount": price, "delivered": True},
        )
        return outcome

    if charge_result.get("status") == "charged":
        before_balance = charge_result.get("balance_before")
        after_balance = charge_result.get("balance_after")
        session["balance_charged"] = True
        registry.add(task_key)
        outcome["charged"] = True
        # FIX #2: Log history operation when balance is charged
        logger.info(f"üí∏ Balance charged: user_id={user_id}, model_id={model_id}, amount={price}, before={before_balance}, after={after_balance}")
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="charged",
            param={
                "task_id": task_id,
                "amount": price,
                "delivered": True,
                "charged_before": before_balance,
                "charged_after": after_balance,
            },
        )
    else:
        before_balance = charge_result.get("balance_before")
        after_balance = charge_result.get("balance_after")
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CHARGE_COMMIT",
            action_path="delivery",
            model_id=model_id,
            stage="CHARGE_COMMIT",
            outcome="failed",
            error_code="BALANCE_DEDUCT_FAIL",
            fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å storage –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ.",
            param={
                "task_id": task_id,
                "amount": price,
                "delivered": True,
                "charged_before": before_balance,
                "charged_after": after_balance,
            },
        )
    return outcome


async def _resolve_free_counter_line(
    user_id: int,
    user_lang: str,
    correlation_id: Optional[str],
    action_path: str,
    sku_id: Optional[str] = None,
) -> str:
    try:
        return await get_free_counter_line(
            user_id,
            user_lang=user_lang,
            correlation_id=correlation_id,
            action_path=action_path,
            sku_id=sku_id,
        )
    except Exception as exc:
        logger.warning("Failed to resolve free counter line: %s", exc)
        return ""


async def get_free_counter_line(
    user_id: int,
    *,
    user_lang: str,
    correlation_id: Optional[str],
    action_path: str,
    sku_id: Optional[str] = None,
) -> str:
    if not user_id:
        return ""
    if sku_id is None:
        return ""
    from app.pricing.free_policy import is_sku_free_daily

    if not is_sku_free_daily(sku_id):
        return ""
    snapshot = await get_free_counter_snapshot(user_id)
    line = _format_free_counter_line(
        snapshot["remaining"],
        snapshot["limit_per_day"],
        snapshot["next_refill_in"],
        user_lang,
        is_admin=bool(snapshot.get("is_admin")),
    )
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        action="FREE_COUNTER_VIEW",
        action_path=action_path,
        outcome="shown",
        error_code="FREE_COUNTER_VIEW_OK",
        fix_hint="–ü–æ–∫–∞–∑–∞–Ω —Å—á–µ—Ç—á–∏–∫ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.",
        param={
            "remaining": snapshot["remaining"],
            "limit_per_day": snapshot["limit_per_day"],
            "used_today": snapshot["used_today"],
            "next_refill_in": snapshot["next_refill_in"],
            "is_admin": snapshot.get("is_admin"),
        },
    )
    return line


# ==================== Referral System ====================

def get_referrals_data() -> dict:
    """Get referrals data."""
    return load_json_file(REFERRAL_EVENTS_FILE, {"events": {}})


def save_referrals_data(data: dict):
    """Save referrals data."""
    save_json_file(REFERRAL_EVENTS_FILE, data)


async def get_user_referrals(user_id: int) -> list:
    """Get list of users referred by this user."""
    return await list_referrals_for_referrer(user_id)


async def get_referrer(user_id: int) -> Optional[int]:
    """Get the user who referred this user, or None if not referred."""
    try:
        from app.storage.factory import get_storage

        storage = get_storage()
        return await storage.get_referrer(user_id)
    except Exception as exc:
        logger.warning("Failed to fetch referrer: user_id=%s error=%s", user_id, exc)
        return None


async def add_referral(referrer_id: int, referred_id: int, *, ref_param: Optional[str] = None) -> Dict[str, Any]:
    """Add a referral relationship and give bonus to referrer (async)."""
    return await award_referral_bonus(
        referrer_id=referrer_id,
        referred_user_id=referred_id,
        ref_param=ref_param,
        correlation_id=None,
        bonus=REFERRAL_BONUS_GENERATIONS,
    )


def give_bonus_generations(user_id: int, bonus_count: int):
    """Give bonus free generations to a user (legacy wrapper)."""
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:
        loop = None
    if loop and loop.is_running():
        task = loop.create_task(add_referral_free_bonus(user_id, bonus_count))
        _register_background_task(task, action="referral_bonus_legacy")
    else:
        asyncio.run(add_referral_free_bonus(user_id, bonus_count))


def get_user_referral_link(user_id: int, bot_username: str = None) -> str:
    """Get referral link for user."""
    if bot_username is None:
        bot_username = os.getenv("BOT_USERNAME") or "Ferixdi_bot_ai_bot"
    return build_referral_link(user_id, bot_username)


def get_fake_online_count() -> int:
    """Generate dynamic fake online user count - changes every time it's called."""
    # Base number around 500
    base = 500
    # Random variation ¬±80 for more dynamic changes
    variation = random.randint(-80, 80)
    # Time-based variation (slight changes based on time of day)
    current_hour = time.localtime().tm_hour
    # More activity during day hours (9-22)
    if 9 <= current_hour <= 22:
        time_multiplier = random.randint(0, 50)
    else:
        time_multiplier = random.randint(-30, 20)
    
    # Add microsecond-based variation for more randomness
    microsecond_variation = random.randint(-20, 20)
    
    count = base + variation + time_multiplier + microsecond_variation
    # Ensure reasonable bounds (300-700 range)
    return max(300, min(700, count))


# ==================== Promocodes System ====================

def load_promocodes() -> list:
    """Load promocodes from file."""
    data = load_json_file(PROMOCODES_FILE, {})
    return data.get('promocodes', [])


def save_promocodes(promocodes: list):
    """Save promocodes to file."""
    data = {'promocodes': promocodes}
    save_json_file(PROMOCODES_FILE, data)


def get_active_promocode() -> dict:
    """Get the currently active promocode."""
    promocodes = load_promocodes()
    for promo in promocodes:
        if promo.get('active', False):
            return promo
    return None


# ==================== Broadcast System ====================

def get_all_users() -> list:
    """Get list of all user IDs from various sources."""
    user_ids = set()
    
    # From user balances
    balances = load_json_file(BALANCES_FILE, {})
    user_ids.update([int(uid) for uid in balances.keys() if uid.isdigit()])
    
    # From payments
    payments = load_json_file(PAYMENTS_FILE, {})
    for payment in payments.values():
        if 'user_id' in payment:
            user_ids.add(payment['user_id'])
    
    # From referrals
    referrals = get_referrals_data()
    events = referrals.get("events")
    if isinstance(events, dict):
        for event in events.values():
            if not isinstance(event, dict):
                continue
            for key in ("referrer_id", "referred_user_id"):
                value = event.get(key)
                if isinstance(value, int):
                    user_ids.add(value)
                elif isinstance(value, str) and value.isdigit():
                    user_ids.add(int(value))
    else:
        for user_key in referrals.keys():
            if isinstance(user_key, str) and user_key.isdigit():
                user_ids.add(int(user_key))
            referred_users = referrals.get(user_key, {}).get('referred_users', [])
            user_ids.update(referred_users)
    
    # From free generations
    free_gens = get_free_generations_data()
    for user_key in free_gens.keys():
        if user_key.isdigit():
            user_ids.add(int(user_key))
    
    return sorted(list(user_ids))


def save_broadcast(broadcast_data: dict):
    """Save broadcast statistics."""
    broadcasts = load_json_file(BROADCASTS_FILE, {})
    broadcast_id = broadcast_data.get('id', len(broadcasts) + 1)
    broadcasts[str(broadcast_id)] = broadcast_data
    save_json_file(BROADCASTS_FILE, broadcasts)
    return broadcast_id


def get_broadcasts() -> dict:
    """Get all broadcasts."""
    return load_json_file(BROADCASTS_FILE, {})


def get_broadcast(broadcast_id: int) -> dict:
    """Get specific broadcast by ID."""
    broadcasts = get_broadcasts()
    return broadcasts.get(str(broadcast_id), {})


# ==================== Generations History System ====================

def save_generation_to_history(
    user_id: int,
    model_id: str,
    model_name: str,
    params: dict,
    result_urls: list,
    task_id: str,
    price: float = 0.0,
    is_free: bool = False,
    correlation_id: Optional[str] = None,
):
    """Save generation to user history (GitHub JSON storage)."""
    import time
    try:
        from app.storage.factory import get_storage

        storage_instance = get_storage()
        if storage_instance and hasattr(storage_instance, "add_generation_to_history"):
            gen_id = _run_storage_coro_sync(
                storage_instance.add_generation_to_history(
                    user_id=user_id,
                    model_id=model_id,
                    model_name=model_name,
                    params=params.copy(),
                    result_urls=result_urls.copy() if result_urls else [],
                    price=price,
                    operation_id=task_id,
                ),
                label="history:add_generation",
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                action="PERSIST",
                action_path="save_generation_to_history",
                model_id=model_id,
                task_id=task_id,
                stage="PERSIST",
                outcome="success",
                param={
                    "storage": getattr(storage_instance, "storage_mode", "unknown"),
                    "generation_id": gen_id,
                },
            )
            return gen_id

        history = load_json_file(GENERATIONS_HISTORY_FILE, {})
        user_key = str(user_id)

        if user_key not in history:
            history[user_key] = []
            logger.info(f"Created new history entry for user {user_id}")

        generation_entry = {
            'id': len(history[user_key]) + 1,
            'timestamp': int(time.time()),
            'model_id': model_id,
            'model_name': model_name,
            'params': params.copy(),
            'result_urls': result_urls.copy() if result_urls else [],
            'task_id': task_id,
            'price': price,
            'is_free': is_free,
        }

        history[user_key].append(generation_entry)

        # Keep only last 100 generations per user
        if len(history[user_key]) > 100:
            history[user_key] = history[user_key][-100:]

        if GENERATIONS_HISTORY_FILE in _last_save_time:
            del _last_save_time[GENERATIONS_HISTORY_FILE]

        save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=True)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            action="PERSIST",
            action_path="save_generation_to_history",
            model_id=model_id,
            task_id=task_id,
            stage="PERSIST",
            outcome="success",
            param={"storage": "file", "generation_id": generation_entry.get("id")},
        )
        return generation_entry['id']
    except Exception as e:
        logger.error(f"Error saving generation to history: {e}", exc_info=True)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            action="PERSIST",
            action_path="save_generation_to_history",
            model_id=model_id,
            task_id=task_id,
            stage="PERSIST",
            outcome="failed",
            error_code="PERSIST_FAILED",
            fix_hint=str(e),
        )
        return None


def get_user_generations_history(user_id: int, limit: int = 20) -> list:
    """Get user's generation history."""
    try:
        from app.config import get_settings
        from app.storage.factory import get_storage

        if get_settings().get_storage_mode() == "db":
            storage_instance = get_storage()
            history = _run_storage_coro_sync(
                storage_instance.get_user_generations_history(user_id, limit=limit),
                label="history:get_user",
            )
            return history or []

        history = load_json_file(GENERATIONS_HISTORY_FILE, {})
        if not history:
            # Empty history file is normal for new users or first run - use INFO instead of WARNING
            logger.info(f"History file {GENERATIONS_HISTORY_FILE} is empty (normal for new users)")
            return []
        
        # Try both string and integer keys (for compatibility)
        user_key_str = str(user_id)
        user_key_int = user_id
        
        # Debug: log what we're looking for
        logger.info(f"Loading history for user_id={user_id}, trying keys: '{user_key_str}' and {user_key_int}, total_users_in_file={len(history)}")
        
        # Check both string and integer keys
        user_history = None
        if user_key_str in history:
            user_history = history[user_key_str]
            logger.info(f"Found history with string key '{user_key_str}': {len(user_history)} generations")
        elif user_key_int in history:
            user_history = history[user_key_int]
            logger.info(f"Found history with integer key {user_key_int}: {len(user_history)} generations")
            # Migrate to string key for consistency
            history[user_key_str] = user_history
            if user_key_int != user_key_str:
                del history[user_key_int]
            save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=True)
        else:
            # Try to find by checking all keys
            all_keys = list(history.keys())
            logger.info(f"User {user_id} not found in history file. Available keys (first 20): {all_keys[:20]}")
            
            # Try to find numeric matches
            for key in all_keys:
                try:
                    if int(key) == user_id:
                        user_history = history[key]
                        logger.info(f"Found history with numeric match: key={key}, generations={len(user_history)}")
                        # Migrate to string key
                        history[user_key_str] = user_history
                        if key != user_key_str:
                            del history[key]
                        save_json_file(GENERATIONS_HISTORY_FILE, history, use_cache=True)
                        break
                except (ValueError, TypeError):
                    continue
            
            if user_history is None:
                logger.info(f"No history found for user {user_id} after checking all keys")
                return []
        
        if not user_history:
            logger.info(f"User {user_id} has empty history")
            return []
        
        # Return last N generations, sorted by timestamp (newest first)
        logger.info(f"Returning {min(limit, len(user_history))} generations for user {user_id} (total: {len(user_history)})")
        user_history.sort(key=lambda x: x.get('timestamp', 0), reverse=True)
        return user_history[:limit]
    except Exception as e:
        logger.error(f"Error loading user generations history: {e}", exc_info=True)
        return []


def get_generation_by_id(user_id: int, generation_id: int) -> dict:
    """Get specific generation by ID."""
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    user_key = str(user_id)
    
    if user_key not in history:
        return None
    
    for gen in history[user_key]:
        if gen.get('id') == generation_id:
            return gen
    
    return None


def is_new_user(user_id: int) -> bool:
    """Check if user is new (no balance, no history, no payments)."""
    # Check balance
    balance = get_user_balance(user_id)
    if balance > 0:
        return False
    
    # Check history
    history = get_user_generations_history(user_id, limit=1)
    if history:
        return False
    
    # Check payments
    payments = get_user_payments(user_id)
    if payments:
        return False
    
    return True


async def is_new_user_async(user_id: int) -> bool:
    """Async check if user is new (no balance, no history, no payments)."""
    balance = await get_user_balance_async(user_id)
    if balance > 0:
        return False

    history = get_user_generations_history(user_id, limit=1)
    if history:
        return False

    payments = get_user_payments(user_id)
    if payments:
        return False

    return True


async def send_broadcast(context: ContextTypes.DEFAULT_TYPE, broadcast_id: int, user_ids: list, message_text: str = None, message_photo=None):
    """Send broadcast message to all users."""
    sent = 0
    delivered = 0
    failed = 0
    
    for user_id in user_ids:
        try:
            # Skip blocked users
            if is_user_blocked(user_id):
                continue
            
            # Send message
            if message_photo:
                # Send photo with caption
                try:
                    await context.bot.send_photo(
                        chat_id=user_id,
                        photo=message_photo.file_id,
                        caption=message_text,
                        parse_mode='HTML'
                    )
                    delivered += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast photo to {user_id}: {e}")
                    failed += 1
            else:
                # Send text message
                try:
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=message_text,
                        parse_mode='HTML'
                    )
                    delivered += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast message to {user_id}: {e}")
                    failed += 1
            
            sent += 1
            
            # Small delay to avoid rate limiting
            await asyncio.sleep(0.05)  # 50ms delay between messages
            
        except Exception as e:
            logger.error(f"Error in broadcast to {user_id}: {e}")
            failed += 1
            sent += 1
    
    # Update broadcast statistics
    broadcasts = get_broadcasts()
    if str(broadcast_id) in broadcasts:
        broadcasts[str(broadcast_id)]['sent'] = sent
        broadcasts[str(broadcast_id)]['delivered'] = delivered
        broadcasts[str(broadcast_id)]['failed'] = failed
        save_json_file(BROADCASTS_FILE, broadcasts)
        
        # Notify admin
        try:
            admin_id = ADMIN_ID
            await context.bot.send_message(
                chat_id=admin_id,
                text=(
                    f"‚úÖ <b>–†–∞—Å—Å—ã–ª–∫–∞ #{broadcast_id} –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                    f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                    f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent}\n"
                    f"üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {delivered}\n"
                    f"‚ùå –û—à–∏–±–æ–∫: {failed}\n\n"
                    f"üìà <b>–£—Å–ø–µ—à–Ω–æ—Å—Ç—å:</b> {(delivered/sent*100) if sent > 0 else 0:.1f}%"
                ),
                parse_mode='HTML'
            )
        except Exception as e:
            logger.error(f"Error notifying admin about broadcast: {e}")


def is_user_blocked(user_id: int) -> bool:
    """Check if user is blocked."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    return blocked.get(str(user_id), False)


def block_user(user_id: int):
    """Block a user."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    blocked[str(user_id)] = True
    save_json_file(BLOCKED_USERS_FILE, blocked)


def unblock_user(user_id: int):
    """Unblock a user."""
    blocked = load_json_file(BLOCKED_USERS_FILE, {})
    if str(user_id) in blocked:
        del blocked[str(user_id)]
        save_json_file(BLOCKED_USERS_FILE, blocked)


def check_duplicate_payment(screenshot_file_id: str) -> bool:
    """Check if this screenshot was already used for payment."""
    if not screenshot_file_id:
        return False
    payments = load_json_file(PAYMENTS_FILE, {})
    for payment in payments.values():
        if payment.get('screenshot_file_id') == screenshot_file_id:
            return True
    return False


def _persist_payment_record(user_id: int, amount: float, screenshot_file_id: str = None) -> tuple[dict, bool]:
    """Persist payment record and return (payment payload, is_new)."""
    lock = _file_locks.get('payments', _file_locks['balances'])
    payment: dict = {}
    created = False

    with lock:
        from app.storage.factory import get_storage

        storage_instance = get_storage()

        def updater(payload: dict) -> dict:
            nonlocal payment, created
            updated = dict(payload or {})
            if screenshot_file_id:
                for key, existing in updated.items():
                    if existing.get("screenshot_file_id") == screenshot_file_id:
                        if "balance_charged" not in existing:
                            existing["balance_charged"] = True
                            updated[key] = existing
                        payment = existing
                        created = False
                        return updated

            payment_id = len(updated) + 1
            while str(payment_id) in updated:
                payment_id += 1
            import time
            payment = {
                "id": payment_id,
                "user_id": user_id,
                "amount": amount,
                "timestamp": time.time(),
                "screenshot_file_id": screenshot_file_id,
                "status": "completed",
                "balance_charged": False,
            }
            updated[str(payment_id)] = payment
            created = True
            return updated

        if PAYMENTS_FILE in _last_save_time:
            del _last_save_time[PAYMENTS_FILE]
        _run_storage_coro_sync(
            storage_instance.update_json_file(os.path.basename(PAYMENTS_FILE), updater),
            label="payments:update",
        )

    if created:
        logger.info(
            "‚úÖ Saved payment: user_id=%s amount=%.2f payment_id=%s",
            user_id,
            amount,
            payment.get("id"),
        )
    return payment, created


def add_payment(user_id: int, amount: float, screenshot_file_id: str = None) -> dict:
    """Add a payment record. Returns payment dict with id, timestamp, etc."""
    payment, created = _persist_payment_record(user_id, amount, screenshot_file_id)
    if not payment.get("balance_charged"):
        add_user_balance(user_id, amount)
        payment["balance_charged"] = True

        def updater(payload: dict) -> dict:
            updated = dict(payload or {})
            updated[str(payment["id"])] = payment
            return updated

        from app.storage.factory import get_storage

        storage_instance = get_storage()
        _run_storage_coro_sync(
            storage_instance.update_json_file(os.path.basename(PAYMENTS_FILE), updater),
            label="payments:balance_charged",
        )
        logger.info(
            "üí∞ Payment topped up: user_id=%s amount=%.2f payment_id=%s",
            user_id,
            amount,
            payment.get("id"),
        )
    else:
        logger.info(
            "üí∞ Payment idempotent: user_id=%s amount=%.2f payment_id=%s",
            user_id,
            amount,
            payment.get("id"),
        )
    return payment


async def add_payment_async(user_id: int, amount: float, screenshot_file_id: str = None) -> dict:
    """Async add payment with balance credit through async storage."""
    payment, created = _persist_payment_record(user_id, amount, screenshot_file_id)
    if not payment.get("balance_charged"):
        await add_user_balance_async(user_id, amount)
        payment["balance_charged"] = True

        def updater(payload: dict) -> dict:
            updated = dict(payload or {})
            updated[str(payment["id"])] = payment
            return updated

        from app.storage.factory import get_storage

        storage_instance = get_storage()
        await storage_instance.update_json_file(os.path.basename(PAYMENTS_FILE), updater)
    return payment


def get_all_payments() -> list:
    """Get all payments sorted by timestamp (newest first)."""
    payments = load_json_file(PAYMENTS_FILE, {})
    payment_list = list(payments.values())
    payment_list.sort(key=lambda x: x.get("timestamp", 0), reverse=True)
    return payment_list


def get_user_payments(user_id: int) -> list:
    """Get all payments for a specific user."""
    all_payments = get_all_payments()
    return [p for p in all_payments if p.get("user_id") == user_id]


def get_payment_stats() -> dict:
    """Get payment statistics."""
    payments = get_all_payments()
    total_amount = sum(p.get("amount", 0) for p in payments)
    total_count = len(payments)
    successful_statuses = {"completed", "approved"}
    successful_payments = [
        p for p in payments if p.get("status", "completed") in successful_statuses
    ]
    successful_amount = sum(p.get("amount", 0) for p in successful_payments)
    return {
        "total_amount": total_amount,
        "total_count": total_count,
        "successful_count": len(successful_payments),
        "successful_amount": successful_amount,
        "payments": payments,
    }


def get_extended_admin_stats() -> dict:
    """Get extended statistics for admin panel."""
    import time
    from datetime import datetime, timedelta
    
    now = time.time()
    today_start = int((datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)).timestamp())
    week_start = int((datetime.now() - timedelta(days=7)).timestamp())
    month_start = int((datetime.now() - timedelta(days=30)).timestamp())
    
    # Get all users
    all_users = get_all_users()
    total_users = len(all_users)
    
    # Get active users (users with activity in period)
    history = load_json_file(GENERATIONS_HISTORY_FILE, {})
    active_today = set()
    active_week = set()
    active_month = set()
    
    for user_key, user_history in history.items():
        for gen in user_history:
            timestamp = gen.get('timestamp', 0)
            user_id = int(user_key) if user_key.isdigit() else None
            if user_id:
                if timestamp >= today_start:
                    active_today.add(user_id)
                if timestamp >= week_start:
                    active_week.add(user_id)
                if timestamp >= month_start:
                    active_month.add(user_id)
    
    # Get top models by usage
    model_usage = {}
    for user_key, user_history in history.items():
        for gen in user_history:
            model_id = gen.get('model_id', '')
            if model_id:
                model_usage[model_id] = model_usage.get(model_id, 0) + 1
    
    # Sort models by usage and get top 5
    top_models = sorted(model_usage.items(), key=lambda x: x[1], reverse=True)[:5]
    top_models_list = []
    for model_id, count in top_models:
        model_info = get_model_by_id(model_id)
        model_name = model_info.get('name', model_id) if model_info else model_id
        top_models_list.append({'name': model_name, 'id': model_id, 'count': count})
    
    # Get payment statistics
    payment_stats = get_payment_stats()
    total_revenue = payment_stats.get('total_amount', 0)
    total_payments = payment_stats.get('total_count', 0)
    successful_payments = payment_stats.get('successful_count', 0)
    
    # Calculate conversion rate (users who made at least one payment)
    users_with_payments = set()
    for payment in payment_stats.get('payments', []):
        user_id = payment.get('user_id')
        if user_id:
            users_with_payments.add(user_id)
    
    conversion_rate = (len(users_with_payments) / total_users * 100) if total_users > 0 else 0
    
    # Calculate average check
    avg_check = (total_revenue / total_payments) if total_payments > 0 else 0
    
    # Get revenue for periods
    payments = payment_stats.get('payments', [])
    revenue_today = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= today_start)
    revenue_week = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= week_start)
    revenue_month = sum(p.get('amount', 0) for p in payments if p.get('timestamp', 0) >= month_start)
    
    # Total generations count
    total_generations = sum(len(user_history) for user_history in history.values())
    
    return {
        'total_users': total_users,
        'active_today': len(active_today),
        'active_week': len(active_week),
        'active_month': len(active_month),
        'top_models': top_models_list,
        'total_revenue': total_revenue,
        'revenue_today': revenue_today,
        'revenue_week': revenue_week,
        'revenue_month': revenue_month,
        'total_payments': total_payments,
        'successful_payments': successful_payments,
        'conversion_rate': conversion_rate,
        'avg_check': avg_check,
        'total_generations': total_generations
    }


async def render_admin_panel(update_or_query, context: ContextTypes.DEFAULT_TYPE, is_callback: bool = False):
    """Render admin panel with extended statistics."""
    if is_callback:
        query = update_or_query
        user_id = query.from_user.id
        message_func = query.edit_message_text
        try:
            await query.answer()
        except Exception:
            pass
    else:
        update = update_or_query
        user_id = update.effective_user.id
        message_func = update.message.reply_text

    if not is_admin(user_id):
        if is_callback:
            await query.answer("‚ùå –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", show_alert=True)
        else:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    generation_types = await _await_with_timeout(
        asyncio.to_thread(get_generation_types),
        timeout=MAIN_MENU_DEP_TIMEOUT_SECONDS,
        label="generation_types",
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        update_id=update.update_id,
        default=[],
        raise_on_timeout=False,
        log_timeout=False,
    )
    total_models = await _await_with_timeout(
        asyncio.to_thread(lambda: len(get_models_static_only())),
        timeout=MAIN_MENU_DEP_TIMEOUT_SECONDS,
        label="models_count",
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        update_id=update.update_id,
        default=0,
        raise_on_timeout=False,
        log_timeout=False,
    )

    stats = get_extended_admin_stats()

    kie_balance_info = ""
    correlation_id = get_correlation_id() or uuid.uuid4().hex
    if kie is not None:
        try:
            balance_result = await get_kie_credits_cached(correlation_id=correlation_id)
            if balance_result.get('ok'):
                balance = balance_result.get('credits', 0)
                balance_rub = balance * CREDIT_TO_USD * get_usd_to_rub_rate()
                balance_rub_str = f"{balance_rub:.2f}"
                kie_balance_info = f"üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> {balance_rub_str} ‚ÇΩ ({balance} –∫—Ä–µ–¥–∏—Ç–æ–≤)\n\n"
            else:
                status = balance_result.get("status")
                if status == 404:
                    kie_balance_info = "üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> –ë–∞–ª–∞–Ω—Å KIE –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (endpoint 404)\n\n"
                else:
                    kie_balance_info = "üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ\n\n"
                logger.warning(
                    "KIE balance unavailable corr_id=%s status=%s error=%s",
                    balance_result.get("correlation_id", correlation_id),
                    status,
                    balance_result.get("error"),
                )
        except Exception as e:
            logger.error("Error getting KIE balance corr_id=%s error=%s", correlation_id, e)
            kie_balance_info = "üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ\n\n"
    else:
        kie_balance_info = "üí∞ <b>–ë–∞–ª–∞–Ω—Å KIE API:</b> –ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω\n\n"

    top_models_text = ""
    if stats['top_models']:
        top_models_text = "\n<b>–¢–æ–ø-5 –º–æ–¥–µ–ª–µ–π:</b>\n"
        for i, model in enumerate(stats['top_models'], 1):
            top_models_text += f"{i}. {model['name']}: {model['count']} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π\n"
        top_models_text += "\n"
    else:
        top_models_text = "\n<b>–¢–æ–ø-5 –º–æ–¥–µ–ª–µ–π:</b> –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö\n\n"

    admin_text = (
        f'üëë <b>–ü–ê–ù–ï–õ–¨ –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê</b> üëë\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{kie_balance_info}'
        f'üìä <b>–†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:</b>\n\n'
        f'üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>\n'
        f'   ‚Ä¢ –í—Å–µ–≥–æ: <b>{stats["total_users"]}</b>\n'
        f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: <b>{stats["active_today"]}</b>\n'
        f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é: <b>{stats["active_week"]}</b>\n'
        f'   ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –º–µ—Å—è—Ü: <b>{stats["active_month"]}</b>\n\n'
        f'üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b>\n'
        f'   ‚Ä¢ –í—Å–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: <b>{stats["total_generations"]}</b>\n'
        f'{top_models_text}'
        f'üí∞ <b>–§–∏–Ω–∞–Ω—Å—ã:</b>\n'
        f'   ‚Ä¢ –û–±—â–∏–π –¥–æ—Ö–æ–¥: <b>{format_rub_amount(stats["total_revenue"])}</b>\n'
        f'   ‚Ä¢ –î–æ—Ö–æ–¥ —Å–µ–≥–æ–¥–Ω—è: <b>{format_rub_amount(stats["revenue_today"])}</b>\n'
        f'   ‚Ä¢ –î–æ—Ö–æ–¥ –∑–∞ –Ω–µ–¥–µ–ª—é: <b>{format_rub_amount(stats["revenue_week"])}</b>\n'
        f'   ‚Ä¢ –î–æ—Ö–æ–¥ –∑–∞ –º–µ—Å—è—Ü: <b>{format_rub_amount(stats["revenue_month"])}</b>\n'
        f'   ‚Ä¢ –í—Å–µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–π: <b>{stats["total_payments"]}</b>\n'
        f'   ‚Ä¢ –£—Å–ø–µ—à–Ω—ã—Ö –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–π: <b>{stats["successful_payments"]}</b>\n'
        f'   ‚Ä¢ –°—Ä–µ–¥–Ω–∏–π —á–µ–∫: <b>{format_rub_amount(stats["avg_check"])}</b>\n'
        f'   ‚Ä¢ –ö–æ–Ω–≤–µ—Ä—Å–∏—è –≤ –æ–ø–ª–∞—Ç—É: <b>{stats["conversion_rate"]:.1f}%</b>\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'üìä <b>–°–ò–°–¢–ï–ú–ê:</b>\n\n'
        f'‚úÖ <b>{total_models} –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–µ–π</b> –≤ –∞—Ä—Å–µ–Ω–∞–ª–µ\n'
        f'‚úÖ <b>{len(generation_types)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
        f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è–º\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'‚öôÔ∏è <b>–ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –§–£–ù–ö–¶–ò–ò:</b>\n\n'
        f'üìà –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏\n'
        f'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
        f'üéÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏\n'
        f'üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ OCR —Å–∏—Å—Ç–µ–º—ã\n'
        f'üíº –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –±–æ—Ç–æ–º\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'üí´ <b>–í–´–ë–ï–†–ò–¢–ï –î–ï–ô–°–¢–í–ò–ï:</b>'
    )

    keyboard = [
        [InlineKeyboardButton("üìä –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É", callback_data="admin_stats")],
        [InlineKeyboardButton("üìö –ü—Ä–æ—Å–º–æ—Ç—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–π", callback_data="admin_view_generations")],
        [InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")],
        [InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search")],
        [InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")],
        [InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")],
    ]

    await message_func(
        admin_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML',
    )


def _resolve_payment_details() -> tuple[str, str, str, str]:
    card_holder = os.getenv("PAYMENT_CARD_HOLDER", "").strip()
    phone = os.getenv("PAYMENT_PHONE", "").strip()
    bank = os.getenv("PAYMENT_BANK", "").strip()

    source = "partner" if (phone or bank or card_holder) else "missing"

    return phone, bank, card_holder, source


def get_payment_details() -> str:
    """Get payment details from ENV (–°–ë–ü - –°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)."""
    # –£–±—Ä–∞–Ω–æ: load_dotenv()
    # –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard –∏–ª–∏ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV)
    # –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

    phone, bank, card_holder, source = _resolve_payment_details()

    logger.debug(
        "Loading payment details source=%s PAYMENT_PHONE=%s PAYMENT_BANK=%s PAYMENT_CARD_HOLDER=%s",
        source,
        "SET" if phone else "NOT SET",
        "SET" if bank else "NOT SET",
        "SET" if card_holder else "NOT SET",
    )

    if not phone and not bank and not card_holder:
        logger.warning("Payment details not found in environment variables!")
        logger.warning("Set PAYMENT_PHONE, PAYMENT_BANK, and PAYMENT_CARD_HOLDER.")

    details = "üí≥ <b>–†–µ–∫–≤–∏–∑–∏—Ç—ã –¥–ª—è –æ–ø–ª–∞—Ç—ã (–°–ë–ü):</b>\n\n"

    if phone:
        details += f"üì± <b>–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:</b> <code>{phone}</code>\n"
    if bank:
        details += f"üè¶ <b>–ë–∞–Ω–∫:</b> {bank}\n"
    if card_holder:
        details += f"üë§ <b>–ü–æ–ª—É—á–∞—Ç–µ–ª—å:</b> {card_holder}\n"

    if not phone and not bank and not card_holder:
        details += "‚ö†Ô∏è <b>–í–ù–ò–ú–ê–ù–ò–ï: –†–µ–∫–≤–∏–∑–∏—Ç—ã –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã!</b>\n\n"
        details += "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è:\n"
        details += "‚Ä¢ <code>PAYMENT_PHONE</code>\n"
        details += "‚Ä¢ <code>PAYMENT_BANK</code>\n"
        details += "‚Ä¢ <code>PAYMENT_CARD_HOLDER</code>\n\n"
        details += "–ù–∞ Render: –¥–æ–±–∞–≤—å—Ç–µ –∏—Ö –≤ —Ä–∞–∑–¥–µ–ª–µ Environment Variables\n"
        details += "–õ–æ–∫–∞–ª—å–Ω–æ: –¥–æ–±–∞–≤—å—Ç–µ –≤ —Ñ–∞–π–ª .env\n\n"

    details += "\n‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b> –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞ –≤ —ç—Ç–æ—Ç —á–∞—Ç.\n\n"
    details += "‚úÖ <b>–ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</b> –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞."

    return details


def build_manual_payment_instructions(
    *,
    amount: float,
    user_lang: str,
    payment_details: str,
    method_label: str,
) -> str:
    """Build manual payment instructions for SBP/card transfers."""
    examples_count = int(amount / 0.62)  # free tools price
    video_count = int(amount / 3.86)  # Basic video price
    amount_display = format_rub_amount(amount)
    if user_lang == 'ru':
        return (
            f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount_display} ({method_label})</b> üí≥\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{payment_details}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount_display}\n\n'
            f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
            f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (free tools)\n'
            f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
            f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'üì∏ <b>–ö–ê–ö –û–ü–õ–ê–¢–ò–¢–¨:</b>\n'
            f'1Ô∏è‚É£ –ü–µ—Ä–µ–≤–µ–¥–∏ {amount_display} –ø–æ —Ä–µ–∫–≤–∏–∑–∏—Ç–∞–º –≤—ã—à–µ\n'
            f'2Ô∏è‚É£ –°–¥–µ–ª–∞–π —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞\n'
            f'3Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å —Å–∫—Ä–∏–Ω—à–æ—Ç —Å—é–¥–∞\n'
            f'4Ô∏è‚É£ –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏! ‚ö°\n\n'
            f'‚úÖ <b>–í—Å–µ –ø—Ä–æ—Å—Ç–æ –∏ –±—ã—Å—Ç—Ä–æ!</b>'
        )
    return (
        f'üí≥ <b>PAYMENT {amount_display} ({method_label})</b> üí≥\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{payment_details}\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'üíµ <b>Amount to pay:</b> {amount_display}\n\n'
        f'üéØ <b>WHAT YOU WILL GET:</b>\n'
        f'‚Ä¢ ~{examples_count} images (free tools)\n'
        f'‚Ä¢ ~{video_count} videos (basic model)\n'
        f'‚Ä¢ Or a combination of different models!\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'üì∏ <b>HOW TO PAY:</b>\n'
        f'1Ô∏è‚É£ Transfer {amount_display} using details above\n'
        f'2Ô∏è‚É£ Take a screenshot of the transfer\n'
        f'3Ô∏è‚É£ Send screenshot here\n'
        f'4Ô∏è‚É£ Balance will be added automatically! ‚ö°\n\n'
        f'‚úÖ <b>Simple and fast!</b>'
    )


def _resolve_support_details() -> tuple[str, str, str]:
    support_telegram = os.getenv("SUPPORT_TELEGRAM", "").strip()
    support_text = os.getenv("SUPPORT_TEXT", "").strip()

    source = "partner" if (support_telegram or support_text) else "missing"

    return support_telegram, support_text, source


def get_support_contact() -> str:
    """Get support contact information from ENV (only Telegram)."""
    # –£–±—Ä–∞–Ω–æ: load_dotenv()
    # –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¢–û–õ–¨–ö–û –∏–∑ ENV (Render Dashboard –∏–ª–∏ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV)
    # –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

    support_telegram, support_text, source = _resolve_support_details()

    logger.debug(
        "Loading support contact source=%s SUPPORT_TELEGRAM=%s SUPPORT_TEXT=%s",
        source,
        "SET" if support_telegram else "NOT SET",
        "SET" if support_text else "NOT SET",
    )

    contact = "üÜò <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>\n\n"

    if support_text:
        contact += f"{support_text}\n\n"
    else:
        contact += "–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏:\n\n"

    if support_telegram:
        telegram_username = support_telegram.replace("@", "")
        contact += f"üí¨ <b>Telegram:</b> @{telegram_username}\n"
    else:
        logger.warning("Support contact not found in environment variables!")
        logger.warning("Set SUPPORT_TELEGRAM and/or SUPPORT_TEXT.")
        contact += "‚ö†Ô∏è <b>–ö–æ–Ω—Ç–∞–∫—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.</b>\n\n"
        contact += "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å SUPPORT_TELEGRAM.\n\n"
        contact += "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."

    return contact


async def analyze_payment_screenshot(image_data: bytes, expected_amount: float, expected_phone: str = None) -> dict:
    """
    STRICT Payment verification for –°–ë–ü (Fast Bank Transfer) screenshots.
    
    Verification steps:
    1. Extract text via OCR (Russian+English)
    2. Find exact payment amount (¬±5% tolerance, stricter than before)
    3. Find payment keywords (—É—Å–ø–µ—à–Ω–æ, –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ, –ø–ª–∞—Ç–µ–∂, —Å–±–ø, etc.)
    4. Verify phone number if expected
    
    STRICT RULES:
    - Amount MUST be found and match (¬±5%)
    - CRITICAL keywords must be present (—É—Å–ø–µ—à–Ω–æ/–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ/–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ) OR phone must match
    - On OCR failure: REJECT (don't auto-credit)
    - Returns: {valid: bool, amount_found, phone_found, has_critical_keyword, message}
    """
    if not OCR_AVAILABLE or not PIL_AVAILABLE:
        logger.warning(f"‚ö†Ô∏è OCR not available. Payment verification DISABLED - will require manual review")
        return {
            'valid': False,  # STRICT: Reject without OCR
            'amount_found': False,
            'phone_found': False,
            'message': '‚ÑπÔ∏è <b>OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</b>. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ —Ç—Ä–µ–±—É–µ—Ç —Ä—É—á–Ω–æ–π –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç¬≠—Ä–∞—Ç–æ—Ä–æ–º.\n\n‚ùå –ë–∞–ª–∞–Ω—Å <b>–ù–ï –Ω–∞—á–∏—Å–ª–µ–Ω</b> –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.'
        }
    
    try:
        # Convert bytes to PIL Image
        image = Image.open(BytesIO(image_data))
        logger.info(f"üì∏ Analyzing payment screenshot ({image.size[0]}x{image.size[1]}px) for amount {expected_amount} RUB")
        
        # Extract text via OCR
        extracted_text = ""
        try:
            extracted_text = pytesseract.image_to_string(image, lang='rus+eng')
            logger.debug(f"‚úÖ OCR successful (rus+eng): {len(extracted_text)} characters")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è OCR error (rus+eng): {e}")
            # Try English only if Russian fails
            try:
                extracted_text = pytesseract.image_to_string(image, lang='eng')
                logger.debug(f"‚úÖ OCR successful (eng): {len(extracted_text)} characters")
            except Exception as e2:
                logger.warning(f"‚ö†Ô∏è OCR error (eng): {e2}")
                # Try default
                try:
                    extracted_text = pytesseract.image_to_string(image)
                    logger.debug(f"‚úÖ OCR successful (default): {len(extracted_text)} characters")
                except Exception as e3:
                    logger.error(f"‚ùå OCR completely failed: {e3}")
                    raise
        
        extracted_text_lower = extracted_text.lower()
        logger.info(f"üìÑ Recognized text (first 300 chars): {extracted_text_lower[:300]}")
        
        # CRITICAL KEYWORDS: Strong indicators of successful payment
        critical_keywords = [
            '—É—Å–ø–µ—à–Ω–æ',  # Successfully (STRONGEST indicator)
            '–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ',  # Transferred (STRONGEST)
            '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ',  # Sent (STRONGEST)
            '—Å–±–ø',  # SBP system name
        ]
        
        # Additional keywords: Weaker but supporting
        additional_keywords = [
            '–ø–µ—Ä–µ–≤–æ–¥', '–ø–ª–∞—Ç–µ–∂', 'payment', 'transfer', 'amount', '—Å—É–º–º–∞',
            '–∏—Ç–æ–≥–æ', 'total', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å', 'recipient', '—Å—Ç–∞—Ç—É—Å', 'status',
            '–∫–≤–∏—Ç–∞–Ω—Ü–∏—è', 'receipt', '–∫–æ–º–∏—Å—Å–∏—è', 'commission', '–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ', 'topup'
        ]
        
        # STRICT: Require at least ONE critical keyword
        has_critical_keyword = any(keyword in extracted_text_lower for keyword in critical_keywords)
        has_additional_keyword = any(keyword in extracted_text_lower for keyword in additional_keywords)
        has_payment_keywords = has_critical_keyword or has_additional_keyword
        
        if has_critical_keyword:
            logger.info(f"‚úÖ CRITICAL PAYMENT INDICATOR FOUND")
        elif has_additional_keyword:
            logger.info(f"‚úÖ Additional payment indicator found")
        else:
            logger.warning(f"‚ö†Ô∏è NO payment indicators found")
        
        # Extract amount from text - STRICT MATCHING
        amount_patterns = [
            # HIGHEST PRIORITY: Numbers with currency symbols (most reliable)
            (r'(\d{2,6})[.,]?(\d{0,2})\s*[‚ÇΩ—Ä—É–±—Ä—É–±–ª—å]', '—Å —Ä—É–±–ª—ë–º'),
            (r'[‚ÇΩ—Ä—É–±—Ä—É–±–ª—å]\s*(\d{2,6})[.,]?(\d{0,2})', '—Ä—É–±–ª—å –ø–µ—Ä–µ–¥'),
            # HIGH PRIORITY: Near payment keywords
            (r'(?:—Å—É–º–º–∞|–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ?|–ø–µ—Ä–µ–≤–µ–ª|amount)\s*[=:]\s*(\d{2,6})[.,]?(\d{0,2})\s*[‚ÇΩ—Ä—É–±—Ä—É–±–ª—å]?', '—Å—É–º–º–∞='),
            (r'(?:—Å—É–º–º–∞|–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ?|–ø–µ—Ä–µ–≤–µ–ª|amount)[=:]\s*(\d{2,6})', '–∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ'),
            # MEDIUM PRIORITY: Standalone large numbers
            (r'\b(\d{3,6})[.,]?(\d{0,2})\b', '–±–æ–ª—å—à–æ–µ —á–∏—Å–ª–æ'),
        ]
        
        amount_found = False
        found_amount = None
        all_found_amounts = []
        
        # Extract amounts using patterns with priority
        for pattern, pattern_name in amount_patterns:
            matches = re.findall(pattern, extracted_text_lower, re.IGNORECASE)
            if matches:
                for match in matches:
                    try:
                        # Handle both single group and multi-group matches
                        if isinstance(match, tuple):
                            # Multi-group: reconstruct number
                            whole = match[0].strip()
                            decimal = match[1].strip() if len(match) > 1 else ''
                            if decimal:
                                amount_str = f"{whole}.{decimal}"
                            else:
                                amount_str = whole
                        else:
                            amount_str = match.strip()
                        
                        amount_val = float(amount_str.replace(',', '.'))
                        # Sanity check: amount should be reasonable (1-500000 RUB)
                        if 1 <= amount_val <= 500000:
                            all_found_amounts.append((amount_val, pattern_name))
                            logger.debug(f"  Found amount: {amount_val} RUB (pattern: {pattern_name})")
                    except (ValueError, IndexError) as e:
                        logger.debug(f"  Failed to parse amount from {match}: {e}")
                        continue
        
        logger.info(f"üí∞ Total amounts found: {len(all_found_amounts)}: {[a[0] for a in all_found_amounts[:5]]}")
        
        if all_found_amounts:
            # Extract unique amounts and sort by priority (currency symbol patterns first)
            # Group by amount value
            amount_dict = {}  # amount -> count
            for amt, source in all_found_amounts:
                if amt not in amount_dict:
                    amount_dict[amt] = 0
                amount_dict[amt] += 1
            
            # Sort amounts: prefer those that appear multiple times, then largest
            unique_amounts = sorted(amount_dict.keys(), key=lambda x: (-amount_dict[x], -x))
            logger.info(f"üîç Unique amounts (priority): {unique_amounts[:5]}")
            
            # STRICT: Try to find amount that EXACTLY matches (within 5%)
            for amt in unique_amounts:
                diff = abs(amt - expected_amount)
                diff_percent = (diff / expected_amount) if expected_amount > 0 else 1
                
                logger.info(f"  Check {amt} RUB vs {expected_amount} RUB: diff {diff:.2f} ({diff_percent*100:.1f}%)")
                
                # STRICT: Allow only up to 5% difference for security
                if diff_percent <= 0.05:  # 5% tolerance
                    amount_found = True
                    found_amount = amt
                    logger.info(f"‚úÖ AMOUNT MATCHES: {found_amount} RUB (expected {expected_amount})")
                    break
            
            # If no exact match within 5%, try with 10% tolerance (but log warning)
            if not amount_found:
                for amt in unique_amounts:
                    diff = abs(amt - expected_amount)
                    diff_percent = (diff / expected_amount) if expected_amount > 0 else 1
                    if diff_percent <= 0.10:  # 10% tolerance - RELAXED
                        amount_found = True
                        found_amount = amt
                        logger.warning(f"‚ö†Ô∏è AMOUNT APPROXIMATELY MATCHES: {found_amount} RUB (expected {expected_amount}, diff {diff_percent*100:.1f}%)")
                        break
            
            if not amount_found:
                logger.warning(f"‚ùå AMOUNT DOESN'T MATCH: closest found {unique_amounts[0] if unique_amounts else 'NONE'} RUB (expected {expected_amount})")
        
        # Extract phone number from text - STRICT MATCHING
        phone_found = False
        phone_status_msg = "—Ç–µ–ª–µ—Ñ–æ–Ω –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è"
        if expected_phone:
            # Normalize phone (remove +, spaces, dashes, parentheses)
            normalized_expected = re.sub(r'[+\s\-().]', '', str(expected_phone))
            logger.info(f"üì± Looking for phone: {expected_phone} (normalized: {normalized_expected})")
            
            # Look for phone patterns - Russian format
            phone_patterns = [
                r'\+?7\d{10}',  # +7 or 7 followed by 10 digits
                r'8\d{10}',  # 8 followed by 10 digits (Russian format)
                r'\+?7[\s.-]?\(\d{3}\)[\s.-]?\d{3}[\s.-]?\d{2}[\s.-]?\d{2}',  # Formatted: +7(XXX)XXX-XX-XX
                r'\d{11}',  # 11 digit number
            ]
            
            found_phones = []
            for pattern in phone_patterns:
                matches = re.findall(pattern, extracted_text_lower)
                found_phones.extend(matches)
                if matches:
                    logger.debug(f"  Found phones (pattern {pattern}): {matches[:3]}")
            
            if found_phones:
                logger.info(f"üì± Found {len(found_phones)} phone numbers")
                for match in found_phones:
                    normalized_match = re.sub(r'[+\s\-().]', '', match)
                    # Normalize 8 to 7 for comparison (Russian phone standard)
                    if normalized_match.startswith('8'):
                        normalized_match = '7' + normalized_match[1:]
                    
                    logger.debug(f"  Check: {match} -> {normalized_match} vs {normalized_expected}")
                    
                    # STRICT: Require exact match or last 10 digits match
                    if normalized_match == normalized_expected:
                        phone_found = True
                        phone_status_msg = f"‚úÖ –Ω–æ–º–µ—Ä —Å–æ–≤–ø–∞–¥–∞–µ—Ç ({normalized_match[-10:]})"
                        logger.info(f"‚úÖ PHONE MATCHES: {match}")
                        break
                    elif normalized_match[-10:] == normalized_expected[-10:]:
                        phone_found = True
                        phone_status_msg = f"‚úÖ –Ω–æ–º–µ—Ä —Å–æ–≤–ø–∞–¥–∞–µ—Ç (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Ü–∏—Ñ—Ä)"
                        logger.info(f"‚úÖ PHONE MATCHES (last 10 digits): {match}")
                        break
                
                if not phone_found:
                    logger.warning(f"‚ö†Ô∏è PHONE DOESN'T MATCH: found {found_phones[0]} vs expected {expected_phone}")
                    phone_status_msg = f"‚ùå –Ω–æ–º–µ—Ä –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç"
            else:
                logger.warning(f"‚ùå PHONE NOT FOUND in screenshot")
                phone_status_msg = f"‚ùå –Ω–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω"
        
        # STRICT VALIDATION SYSTEM
        # Require: AMOUNT + (KEYWORDS or PHONE) to pass
        logger.info(f"\n‚úîÔ∏è VALIDATION RESULTS:")
        logger.info(f"  1. Amount found: {amount_found} ({found_amount} vs {expected_amount})")
        logger.info(f"  2. Critical keywords: {has_critical_keyword}")
        logger.info(f"  3. {phone_status_msg}")
        
        # CRITICAL RULE: Amount MUST be found
        if not amount_found:
            logger.warning(f"‚ùå VALIDATION REJECTED: amount not found or doesn't match")
            valid = False
        # If amount found, check supporting evidence
        elif not has_critical_keyword and not phone_found:
            # Amount found but no supporting keywords or phone
            logger.warning(f"‚ö†Ô∏è WARNING: amount found but no supporting indicators")
            # Still allow if amount is perfect match
            if amount_found:
                valid = True
                logger.info(f"‚úÖ Amount perfectly matches, allowing payment despite missing supporting indicators")
            else:
                valid = False
        else:
            # Amount found + at least one supporting evidence (keywords or phone)
            valid = True
            logger.info(f"‚úÖ VALIDATION SUCCESS: all checks passed")
        
        # Build user-friendly message
        message_parts = []
        message_parts.append("üîç <b>–†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–†–û–í–ï–†–ö–ò –ü–õ–ê–¢–ï–ñ–ê:</b>")
        message_parts.append("")
        
        if amount_found and found_amount:
            message_parts.append(f"‚úÖ <b>–°—É–º–º–∞:</b> {format_rub_amount(found_amount)} RUB")
        else:
            message_parts.append(f"‚ùå <b>–°—É–º–º–∞:</b> –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–∫—Ä–∏–Ω—à–æ—Ç–µ (–æ–∂–∏–¥–∞–ª–æ—Å—å {format_rub_amount(expected_amount)})")
        
        if expected_phone:
            if phone_found:
                message_parts.append(f"‚úÖ <b>–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:</b> –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω")
            else:
                message_parts.append(f"‚ö†Ô∏è <b>–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:</b> –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç")
        
        if has_critical_keyword:
            message_parts.append("‚úÖ <b>–°—Ç–∞—Ç—É—Å:</b> –ø–ª–∞—Ç–µ–∂ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω (—É—Å–ø–µ—à–Ω–æ/–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ)")
        elif has_additional_keyword:
            message_parts.append("‚úÖ <b>–°—Ç–∞—Ç—É—Å:</b> –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞")
        else:
            message_parts.append("‚ùå <b>–°—Ç–∞—Ç—É—Å:</b> –ø—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã")
        
        if valid:
            message_parts.append("")
            message_parts.append("üéâ <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞! –ë–∞–ª–∞–Ω—Å –±—É–¥–µ—Ç –Ω–∞—á–∏—Å–ª–µ–Ω.</b>")
        else:
            message_parts.append("")
            message_parts.append("‚ö†Ô∏è <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.</b>")
        
        logger.info(f"\nüìã FINAL RESULT: valid={valid}, amount={found_amount}, phone={phone_found}\n")
        
        return {
            'valid': valid,
            'amount_found': amount_found,
            'phone_found': phone_found if expected_phone else None,
            'has_critical_keyword': has_critical_keyword,
            'has_payment_keywords': has_payment_keywords,
            'found_amount': found_amount,
            'message': '\n'.join(message_parts)
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error analyzing payment screenshot: {e}", exc_info=True)
        # STRICT: On exception, REJECT (don't auto-credit)
        return {
            'valid': False,  # STRICT: Fail closed
            'amount_found': False,
            'phone_found': False,
            'message': f'‚ùå <b>–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:</b> {str(e)}.\n\n–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ —Ç—Ä–µ–±—É–µ—Ç <b>—Ä—É—á–Ω–æ–π –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏</b> –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.\n\n‚ö†Ô∏è –ë–∞–ª–∞–Ω—Å <b>–ù–ï –Ω–∞—á–∏—Å–ª–µ–Ω</b> –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.'
        }


# ==================== End Payment System Functions ====================


async def upload_image_to_hosting(image_data: bytes, filename: str = "image.jpg") -> str:
    """
    Upload image to public hosting and return public URL.
    
    üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ü–†–ê–í–ò–õ–û: –≠–¢–ê –§–£–ù–ö–¶–ò–Ø –î–û–õ–ñ–ù–ê –ë–´–¢–¨ –ó–ê–ú–ï–ù–ï–ù–ê –ù–ê KIE AI FILE UPLOAD API!
    
    –í–°–ï —Ñ–∞–π–ª—ã (–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –≤–∏–¥–µ–æ, –∞—É–¥–∏–æ) –î–û–õ–ñ–ù–´ –∑–∞–≥—Ä—É–∂–∞—Ç—å—Å—è —á–µ—Ä–µ–∑ KIE AI File Upload API:
    - Base URL: https://kieai.redpandaai.co
    - Endpoints:
      * POST /api/file-stream-upload - –¥–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)
      * POST /api/file-base64-upload - –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ (‚â§10MB)
      * POST /api/file-url-upload - –¥–ª—è —É–¥–∞–ª–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    - Authentication: Authorization: Bearer YOUR_API_KEY
    - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: https://docs.kie.ai/file-upload-api
    
    ‚ö†Ô∏è –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–Ω–µ—à–Ω–∏–µ —Ö–æ—Å—Ç–∏–Ω–≥–∏ (0x0.st, catbox.moe, transfer.sh)!
    ‚ö†Ô∏è –§–∞–π–ª—ã –≤ KIE AI File Upload API –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ 3 –¥–Ω—è!
    
    NOTE: –∑–∞–º–µ–Ω–∏—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ KIE AI File Upload API
    """
    if not image_data or len(image_data) == 0:
        logger.error("Empty image data provided")
        return None

    request_timeout = aiohttp.ClientTimeout(total=20, sock_connect=6, sock_read=12)
    user_agent_header = {"User-Agent": "TRTBot/1.0 (+https://github.com/ferixdi-png/TRT)"}
    
    # üî¥ –í–†–ï–ú–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤–Ω–µ—à–Ω–∏–µ —Ö–æ—Å—Ç–∏–Ω–≥–∏
    # NOTE: –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ KIE AI File Upload API (https://kieai.redpandaai.co/api/file-stream-upload)
    # Try multiple hosting services
    hosting_services = [
        # 0x0.st - simple file hosting (most reliable)
        {
            'url': 'https://0x0.st',
            'method': 'POST',
            'data_type': 'form',
            'field_name': 'file'
        },
        # catbox.moe - image hosting
        {
            'url': 'https://catbox.moe/user/api.php',
            'method': 'POST',
            'data_type': 'form',
            'field_name': 'fileToUpload',
            'extra_params': {'reqtype': 'fileupload'}
        },
        # transfer.sh - file sharing
        {
            'url': f'https://transfer.sh/{filename}',
            'method': 'PUT',
            'data_type': 'raw',
            'field_name': None
        }
    ]
    
    for service in hosting_services:
        try:
            logger.info(f"Trying to upload to {service['url']}")
            try:
                session = await get_http_client()
            except Exception as e:
                log_structured_event(
                    correlation_id=get_correlation_id(None, None),
                    action="IMAGE_UPLOAD",
                    action_path="image_upload>hosting",
                    stage="image_upload",
                    outcome="http_client_uninitialized",
                    error_code="IMAGE_HOSTING_HTTP_CLIENT_NOT_INITIALIZED",
                    fix_hint="declare_global_http_client_and_init_aiohttp_session",
                )
                logger.error(
                    "HTTP client not initialized for image hosting upload: %s",
                    e,
                    exc_info=True,
                )
                return None
            if service['data_type'] == 'form':
                data = aiohttp.FormData()
                # Add extra params if needed
                if 'extra_params' in service:
                    for key, value in service['extra_params'].items():
                        data.add_field(key, value)
                
                # Add file
                data.add_field(
                    service['field_name'],
                    BytesIO(image_data),
                    filename=filename,
                    content_type='image/jpeg'
                )
                
                async with session.post(
                    service['url'],
                    data=data,
                    timeout=request_timeout,
                    headers=user_agent_header,
                ) as resp:
                    status = resp.status
                    text = await resp.text()
                    logger.info(f"Response from {service['url']}: status={status}, text={text[:100]}")
                    
                    if status in [200, 201]:
                        text = text.strip()
                        # For catbox.moe, response is direct URL
                        if 'catbox.moe' in service['url']:
                            if text.startswith('http'):
                                logger.info("Upload succeeded via catbox.moe")
                                return text
                        # For 0x0.st, response is direct URL
                        elif text.startswith('http'):
                            logger.info("Upload succeeded via 0x0.st")
                            return text
                    else:
                        logger.warning(f"Upload to {service['url']} failed with status {status}: {text[:200]}")
            else:  # raw
                    headers = {
                        'Content-Type': 'image/jpeg',
                        'Max-Downloads': '1',
                        'Max-Days': '7',
                        **user_agent_header,
                    }
                    async with session.put(
                        service['url'],
                        data=image_data,
                        headers=headers,
                        timeout=request_timeout,
                    ) as resp:
                        status = resp.status
                        text = await resp.text()
                        logger.info(f"Response from {service['url']}: status={status}, text={text[:100]}")
                        
                        if status in [200, 201]:
                            text = text.strip()
                            if text.startswith('http'):
                                logger.info("Upload succeeded via transfer.sh")
                                return text
                        else:
                            logger.warning(f"Upload to {service['url']} failed with status {status}: {text[:200]}")
        except asyncio.TimeoutError:
            logger.warning(f"Timeout uploading to {service['url']}")
            continue
        except Exception as e:
            logger.error(f"Exception uploading to {service['url']}: {e}", exc_info=True)
            continue
    
    # If all services fail, return None
    logger.error("All image hosting services failed. Image size: {} bytes".format(len(image_data)))
    return None


async def upload_image_to_kie_file_api(image_data: bytes, filename: str = "image.jpg") -> str:
    """Upload image directly to KIE AI File Upload API and return fileUrl."""
    api_key = os.getenv("KIE_API_KEY", "").strip()
    if not api_key:
        logger.warning("KIE_API_KEY not set; skipping KIE file upload fallback.")
        return None

    base_url = os.getenv("KIE_FILE_UPLOAD_BASE_URL", "https://kieai.redpandaai.co").rstrip("/")
    url = f"{base_url}/api/file-stream-upload"

    try:
        session = await get_http_client()
    except Exception as e:
        log_structured_event(
            correlation_id=get_correlation_id(None, None),
            action="IMAGE_UPLOAD",
            action_path="image_upload>kie_file_api",
            stage="image_upload",
            outcome="http_client_uninitialized",
            error_code="IMAGE_HOSTING_HTTP_CLIENT_NOT_INITIALIZED",
            fix_hint="declare_global_http_client_and_init_aiohttp_session",
        )
        logger.error("HTTP client not initialized for KIE file upload: %s", e, exc_info=True)
        return None

    data = aiohttp.FormData()
    data.add_field(
        "file",
        BytesIO(image_data),
        filename=filename,
        content_type="image/jpeg",
    )
    data.add_field("uploadPath", "images")

    headers = {"Authorization": f"Bearer {api_key}"}
    try:
        async with session.post(url, data=data, headers=headers, timeout=aiohttp.ClientTimeout(total=45)) as resp:
            payload_text = await resp.text()
            if resp.status not in {200, 201}:
                logger.error(
                    "KIE file upload failed: status=%s payload=%s",
                    resp.status,
                    payload_text[:200],
                )
                return None
            try:
                payload = json.loads(payload_text)
            except json.JSONDecodeError:
                logger.error("KIE file upload response is not JSON: %s", payload_text[:200])
                return None
            if not payload.get("success"):
                logger.error("KIE file upload unsuccessful: %s", payload)
                return None
            file_url = payload.get("data", {}).get("fileUrl")
            if not file_url:
                logger.error("KIE file upload missing fileUrl: %s", payload)
                return None
            logger.info("Upload succeeded via KIE file API")
            return file_url
    except asyncio.TimeoutError:
        logger.warning("Timeout uploading image to KIE file API.")
        return None
    except Exception as e:
        logger.error("Exception uploading image to KIE file API: %s", e, exc_info=True)
        return None


async def upload_image_with_fallback(image_data: bytes, filename: str = "image.jpg") -> str:
    """Try public hosting first, fall back to KIE file upload API."""
    public_url = await upload_image_to_hosting(image_data, filename=filename)
    if public_url:
        return public_url
    logger.warning("Public hosting unavailable; trying KIE file upload API fallback.")
    return await upload_image_to_kie_file_api(image_data, filename=filename)


MAIN_MENU_TEXT_FALLBACK = "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"
MINIMAL_MENU_TEXT = "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"
MAIN_MENU_TOTAL_TIMEOUT_SECONDS = float(os.getenv("MAIN_MENU_TOTAL_TIMEOUT_SECONDS", "4.0"))
MAIN_MENU_BUILD_TIMEOUT_SECONDS = float(os.getenv("MAIN_MENU_BUILD_TIMEOUT_SECONDS", "4.0"))
MAIN_MENU_DEP_TIMEOUT_SECONDS = float(os.getenv("MAIN_MENU_DEP_TIMEOUT_SECONDS", "0.6"))
MAIN_MENU_BACKGROUND_TIMEOUT_SECONDS = float(os.getenv("MAIN_MENU_BACKGROUND_TIMEOUT_SECONDS", "6.0"))
START_REFERRAL_TIMEOUT_SECONDS = float(os.getenv("START_REFERRAL_TIMEOUT_SECONDS", "2.0"))
START_FALLBACK_MAX_MS = int(os.getenv("START_FALLBACK_MAX_MS", "1000"))
START_PLACEHOLDER_TIMEOUT_SECONDS = float(os.getenv("START_PLACEHOLDER_TIMEOUT_SECONDS", "1.5"))
START_PLACEHOLDER_RETRY_ATTEMPTS = int(os.getenv("START_PLACEHOLDER_RETRY_ATTEMPTS", "1"))
START_HANDLER_BUDGET_MS = int(os.getenv("START_HANDLER_BUDGET_MS", "900"))
START_TELEGRAM_TIMEOUT_CAP_SECONDS = float(os.getenv("START_TELEGRAM_TIMEOUT_CAP_SECONDS", "2.5"))
START_TELEGRAM_ULTRA_TIMEOUT_SECONDS = float(os.getenv("START_TELEGRAM_ULTRA_TIMEOUT_SECONDS", "1.0"))
START_TELEGRAM_RETRY_ATTEMPTS = int(os.getenv("START_TELEGRAM_RETRY_ATTEMPTS", "2"))
START_ACK_TIMEOUT_SECONDS = float(os.getenv("START_ACK_TIMEOUT_SECONDS", "1.2"))
TELEGRAM_SEND_TIMEOUT_SECONDS = float(os.getenv("TELEGRAM_SEND_TIMEOUT_SECONDS", "20.0"))
TELEGRAM_SEND_RETRY_ATTEMPTS = int(os.getenv("TELEGRAM_SEND_RETRY_ATTEMPTS", "2"))
TELEGRAM_SEND_RETRY_BACKOFF_SECONDS = float(os.getenv("TELEGRAM_SEND_RETRY_BACKOFF_SECONDS", "0.4"))
TELEGRAM_SEND_RETRY_JITTER_RATIO = float(os.getenv("TELEGRAM_SEND_RETRY_JITTER_RATIO", "0.2"))
TELEGRAM_REQUEST_TIMEOUT_SECONDS = float(os.getenv("TELEGRAM_REQUEST_TIMEOUT_SECONDS", "2.0"))
TELEGRAM_API_CONNECT_TIMEOUT_SECONDS = float(os.getenv("TELEGRAM_API_CONNECT_TIMEOUT_SECONDS", "5.0"))
TELEGRAM_API_READ_TIMEOUT_SECONDS = float(os.getenv("TELEGRAM_API_READ_TIMEOUT_SECONDS", "15.0"))
TELEGRAM_API_WRITE_TIMEOUT_SECONDS = float(os.getenv("TELEGRAM_API_WRITE_TIMEOUT_SECONDS", "15.0"))
TELEGRAM_API_POOL_TIMEOUT_SECONDS = float(os.getenv("TELEGRAM_API_POOL_TIMEOUT_SECONDS", "5.0"))
TELEGRAM_IDEMPOTENCY_TTL_SECONDS = float(os.getenv("TELEGRAM_IDEMPOTENCY_TTL_SECONDS", "120.0"))
WEBHOOK_PROCESS_TIMEOUT_SECONDS = float(os.getenv("WEBHOOK_PROCESS_TIMEOUT_SECONDS", "8.0"))
MINIMAL_MENU_FALLBACK_TIMEOUT_SECONDS = float(os.getenv("MINIMAL_MENU_FALLBACK_TIMEOUT_SECONDS", "2.5"))
MINIMAL_MENU_FALLBACK_RETRY_ATTEMPTS = int(os.getenv("MINIMAL_MENU_FALLBACK_RETRY_ATTEMPTS", "2"))
STORAGE_DEGRADED_COOLDOWN_SECONDS = float(os.getenv("STORAGE_DEGRADED_COOLDOWN_SECONDS", "15"))
SAFE_MENU_RENDER_DEDUP_TTL_SECONDS = float(os.getenv("SAFE_MENU_RENDER_DEDUP_TTL_SECONDS", "45.0"))
SAFE_MENU_RENDER_MAX_ENTRIES = int(os.getenv("SAFE_MENU_RENDER_MAX_ENTRIES", "512"))
MAIN_MENU_DEP_CACHE_TTL_SECONDS = float(os.getenv("MAIN_MENU_DEP_CACHE_TTL_SECONDS", "30.0"))
MAIN_MENU_LANG_CACHE_TTL_SECONDS = float(os.getenv("MAIN_MENU_LANG_CACHE_TTL_SECONDS", "300.0"))
MENU_DEP_REFRESH_TTL_SECONDS = float(os.getenv("MENU_DEP_REFRESH_TTL_SECONDS", "30.0"))
_MENU_DEP_CACHE_KEY = "_menu_dep_cache"


class MenuDependencyTimeout(RuntimeError):
    """Raised when a main menu dependency times out."""


class SafeMenuRenderer:
    """Idempotent main menu renderer with dedupe on correlation/update IDs."""

    def __init__(self, ttl_seconds: float, max_entries: int) -> None:
        self._deduper = TTLCache(ttl_seconds)
        self._results: Dict[str, dict] = {}
        self._timestamps: Dict[str, float] = {}
        self._max_entries = max_entries

    @staticmethod
    def _make_key(correlation_id: str, update_id: Optional[int]) -> str:
        return f"{correlation_id}:{update_id if update_id is not None else 'na'}"

    def get_if_duplicate(self, correlation_id: str, update_id: Optional[int]) -> Optional[dict]:
        key = self._make_key(correlation_id, update_id)
        if self._deduper.seen(key):
            return self._results.get(key)
        return None

    def record(self, correlation_id: str, update_id: Optional[int], result: dict) -> None:
        key = self._make_key(correlation_id, update_id)
        now = time.monotonic()
        self._results[key] = result
        self._timestamps[key] = now
        if len(self._results) <= self._max_entries:
            return
        sorted_keys = sorted(self._timestamps.items(), key=lambda item: item[1])
        for stale_key, _ in sorted_keys[: max(1, len(sorted_keys) - self._max_entries)]:
            self._results.pop(stale_key, None)
            self._timestamps.pop(stale_key, None)


_safe_menu_renderer = SafeMenuRenderer(
    SAFE_MENU_RENDER_DEDUP_TTL_SECONDS,
    SAFE_MENU_RENDER_MAX_ENTRIES,
)

_start_inflight_jobs: Dict[int, Dict[str, Any]] = {}


def _claim_start_inflight_job(user_id: int) -> tuple[bool, str]:
    now = time.monotonic()
    entry = _start_inflight_jobs.get(user_id)
    if entry and entry.get("expires_at", 0.0) > now:
        return False, str(entry.get("job_id"))
    job_id = f"start-{user_id}-{uuid.uuid4().hex[:8]}"
    _start_inflight_jobs[user_id] = {
        "job_id": job_id,
        "expires_at": now + START_INFLIGHT_TTL_SECONDS,
    }
    _start_inflight_deduper.seen(f"{user_id}:start")
    return True, job_id


def _release_start_inflight_job(user_id: int, job_id: Optional[str]) -> None:
    if not job_id:
        return
    entry = _start_inflight_jobs.get(user_id)
    if entry and entry.get("job_id") == job_id:
        _start_inflight_jobs.pop(user_id, None)


def _get_menu_dep_cache(session: Optional[Dict[str, Any]], ttl_seconds: float) -> Optional[Dict[str, Any]]:
    if not isinstance(session, dict):
        return None
    cache = session.get(_MENU_DEP_CACHE_KEY)
    if not isinstance(cache, dict):
        return None
    timestamp = cache.get("timestamp")
    if not isinstance(timestamp, (int, float)):
        return None
    if time.monotonic() - timestamp > ttl_seconds:
        return None
    return cache


def _menu_dep_needs_refresh(cache: Optional[Dict[str, Any]], key: str, ttl_seconds: float) -> bool:
    if not isinstance(cache, dict):
        return True
    timestamp = cache.get(f"{key}_ts")
    if not isinstance(timestamp, (int, float)):
        return True
    return (time.monotonic() - timestamp) > ttl_seconds


def _set_menu_dep_cache(session: Optional[Dict[str, Any]], **values: Any) -> None:
    if not isinstance(session, dict):
        return
    cache = session.get(_MENU_DEP_CACHE_KEY)
    if not isinstance(cache, dict):
        cache = {}
    now = time.monotonic()
    for key, value in values.items():
        cache[key] = value
        cache[f"{key}_ts"] = now
    cache["timestamp"] = now
    session[_MENU_DEP_CACHE_KEY] = cache


_storage_degraded_until = 0.0
_storage_degraded_reason: Optional[str] = None


def _is_storage_degraded() -> bool:
    return time.monotonic() < _storage_degraded_until


def _mark_storage_degraded(reason: str) -> None:
    global _storage_degraded_until, _storage_degraded_reason
    now = time.monotonic()
    cooldown_until = now + STORAGE_DEGRADED_COOLDOWN_SECONDS
    if cooldown_until <= _storage_degraded_until:
        return
    _storage_degraded_until = cooldown_until
    _storage_degraded_reason = reason
    logger.warning(
        "STORAGE_DEGRADED reason=%s cooldown_s=%s",
        reason,
        STORAGE_DEGRADED_COOLDOWN_SECONDS,
    )


async def _refresh_menu_language_cache(
    user_id: int,
    *,
    correlation_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
) -> None:
    timeout = MAIN_MENU_DEP_TIMEOUT_SECONDS if timeout_s is None else timeout_s
    if _is_storage_degraded():
        logger.debug(
            "MENU_LANG_REFRESH_SKIPPED storage_degraded=true user_id=%s correlation_id=%s",
            user_id,
            correlation_id,
        )
        return
    try:
        from app.services.user_service import get_user_language as get_user_language_async

        resolved_lang = await asyncio.wait_for(get_user_language_async(user_id), timeout=timeout)
    except asyncio.TimeoutError:
        _mark_storage_degraded("menu_lang_refresh_timeout")
        logger.debug(
            "MENU_LANG_REFRESH_TIMEOUT user_id=%s correlation_id=%s timeout_s=%s",
            user_id,
            correlation_id,
            timeout,
        )
        return
    except Exception as exc:
        logger.debug(
            "MENU_LANG_REFRESH_FAILED user_id=%s correlation_id=%s error=%s",
            user_id,
            correlation_id,
            exc,
        )
        return
    session = user_sessions.ensure(user_id)
    _set_menu_dep_cache(session, user_lang=resolved_lang)


async def _refresh_menu_dependencies(
    user_id: int,
    *,
    correlation_id: Optional[str] = None,
    timeout_s: Optional[float] = None,
    menu_session: Optional[Dict[str, Any]] = None,
) -> None:
    if _is_storage_degraded():
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            action="MENU_DEPS_SKIPPED",
            action_path="menu:dependencies_refresh",
            stage="UI_ROUTER",
            outcome="read_fast",
            param={"reason": _storage_degraded_reason},
        )
        return
    timeout = MAIN_MENU_DEP_TIMEOUT_SECONDS if timeout_s is None else timeout_s
    session = menu_session or user_sessions.ensure(user_id)
    try:
        from app.services.user_service import (
            get_user_free_generations_remaining as get_free_remaining_async,
            get_user_language as get_user_language_async,
        )
        resolved_lang = await _await_with_timeout(
            get_user_language_async(user_id),
            timeout=timeout,
            label="menu_lang_refresh",
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=user_id,
            update_id=None,
            default=None,
            raise_on_timeout=False,
            log_timeout=True,
            degrade_storage_on_timeout=True,
        )
    except Exception as exc:
        logger.debug("MENU_LANG_REFRESH_FAILED user_id=%s correlation_id=%s error=%s", user_id, correlation_id, exc)
        resolved_lang = None
    if resolved_lang:
        _set_menu_dep_cache(session, user_lang=resolved_lang)

    try:
        remaining_free = await _await_with_timeout(
            get_free_remaining_async(user_id),
            timeout=timeout,
            label="menu_free_remaining",
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=user_id,
            update_id=None,
            default=None,
            raise_on_timeout=False,
            log_timeout=False,
            degrade_storage_on_timeout=False,
        )
    except Exception as exc:
        logger.debug("MENU_FREE_REMAINING_REFRESH_FAILED user_id=%s correlation_id=%s error=%s", user_id, correlation_id, exc)
        remaining_free = None
    if remaining_free is not None:
        _set_menu_dep_cache(session, remaining_free=remaining_free)

    try:
        is_new = await _await_with_timeout(
            is_new_user_async(user_id),
            timeout=timeout,
            label="menu_is_new_user",
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=user_id,
            update_id=None,
            default=None,
            raise_on_timeout=False,
            log_timeout=False,
            degrade_storage_on_timeout=False,
        )
    except Exception as exc:
        logger.debug("MENU_IS_NEW_REFRESH_FAILED user_id=%s correlation_id=%s error=%s", user_id, correlation_id, exc)
        is_new = None
    if is_new is not None:
        _set_menu_dep_cache(session, is_new=is_new)

    try:
        referrals = await _await_with_timeout(
            get_user_referrals(user_id),
            timeout=timeout,
            label="referrals_list",
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=user_id,
            update_id=None,
            default=None,
            raise_on_timeout=False,
            log_timeout=True,
            degrade_storage_on_timeout=True,
        )
        referrals_count = len(referrals) if isinstance(referrals, list) else 0
    except Exception as exc:
        logger.debug("MENU_REFERRALS_REFRESH_FAILED user_id=%s correlation_id=%s error=%s", user_id, correlation_id, exc)
        referrals_count = None
    if referrals_count is not None:
        _set_menu_dep_cache(session, referrals_count=referrals_count)


def _schedule_menu_dependency_refresh(
    *,
    user_id: Optional[int],
    correlation_id: Optional[str],
    menu_session: Optional[Dict[str, Any]],
) -> None:
    if not user_id or _is_storage_degraded():
        return
    cache = _get_menu_dep_cache(menu_session, MAIN_MENU_DEP_CACHE_TTL_SECONDS)
    needs_refresh = any(
        _menu_dep_needs_refresh(cache, key, MENU_DEP_REFRESH_TTL_SECONDS)
        for key in ("user_lang", "remaining_free", "is_new", "referrals_count")
    )
    if not needs_refresh:
        return
    _create_background_task(
        _refresh_menu_dependencies(
            user_id,
            correlation_id=correlation_id,
            menu_session=menu_session,
        ),
        action="menu_deps_refresh",
    )

async def _await_with_timeout(
    coro,
    *,
    timeout: float,
    label: str,
    correlation_id: Optional[str],
    user_id: Optional[int],
    chat_id: Optional[int],
    update_id: Optional[int],
    default=None,
    raise_on_timeout: bool = False,
    log_timeout: bool = True,
    degrade_storage_on_timeout: bool = False,
) -> Any:
    try:
        started = time.monotonic()
        result = await asyncio.wait_for(coro, timeout=timeout)
        duration_ms = int((time.monotonic() - started) * 1000)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="DB_WAIT_TIMING",
            action_path=f"db:{label}",
            stage="DB",
            outcome="ok",
            param={
                "db_wait_ms": duration_ms,
                "timeout_s": timeout,
            },
        )
        return result
    except asyncio.TimeoutError as exc:
        if degrade_storage_on_timeout:
            _mark_storage_degraded(f"{label}_timeout")
        if log_timeout:
            logger.warning(
                "MENU_DEP_TIMEOUT label=%s correlation_id=%s user_id=%s chat_id=%s update_id=%s",
                label,
                correlation_id,
                user_id,
                chat_id,
                update_id,
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="MENU_DEP_TIMEOUT",
                action_path=f"menu:{label}",
                stage="UI_ROUTER",
                outcome="timeout",
                error_code="MENU_DEP_TIMEOUT",
                fix_hint="dependency_timeout",
            )
            log_critical_event(
                correlation_id=correlation_id,
                update_id=update_id,
                stage="DB_WAIT",
                latency_ms=timeout * 1000,
                retry_after=None,
                timeout_s=timeout,
                attempt=None,
                error_code="MENU_DEP_TIMEOUT",
                error_id="MENU_DEP_TIMEOUT",
                exception_class=type(exc).__name__,
                where=f"menu_dependency:{label}",
                fix_hint="Check dependency latency and storage health.",
                retryable=True,
                upstream="db",
                deadline_s=timeout,
                elapsed_ms=timeout * 1000,
            )
        if raise_on_timeout:
            raise MenuDependencyTimeout(label) from exc
        return default
    except Exception as exc:
        logger.warning(
            "MENU_DEP_ERROR label=%s correlation_id=%s user_id=%s chat_id=%s update_id=%s error=%s",
            label,
            correlation_id,
            user_id,
            chat_id,
            update_id,
            exc,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="MENU_DEP_ERROR",
            action_path=f"menu:{label}",
            stage="UI_ROUTER",
            outcome="error",
            error_code="MENU_DEP_ERROR",
            fix_hint=str(exc),
        )
        return default


async def _send_menu_error_notice(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    correlation_id: str,
) -> None:
    try:
        notice_text = f"‚ö†Ô∏è –í—Ä–µ–º–µ–Ω–Ω—ã–π —Å–±–æ–π, –ø–æ–∫–∞–∑—ã–≤–∞—é –º–µ–Ω—é. –õ–æ–≥: {correlation_id}."
        if update.message:
            await update.message.reply_text(notice_text)
        elif update.callback_query and update.callback_query.message:
            await update.callback_query.message.reply_text(notice_text)
        elif update.effective_chat:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=notice_text)
    except Exception:
        logger.debug("menu error notice failed", exc_info=True)


def _get_release_version() -> str:
    env_version = os.getenv("BOT_RELEASE_VERSION", "").strip()
    if env_version:
        return env_version
    try:
        import subprocess
        result = subprocess.run(
            ["git", "rev-parse", "--short", "HEAD"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass
    return "1.0.0"


def _get_release_date() -> str:
    env_date = os.getenv("BOT_RELEASE_DATE", "").strip()
    if env_date:
        return env_date
    return datetime.now().strftime("%d.%m.%Y")


def _get_whats_new_lines(user_lang: str) -> list[str]:
    env_lines = os.getenv("BOT_WHATS_NEW", "").strip()
    if env_lines:
        return [line.strip("‚Ä¢ ").strip() for line in env_lines.splitlines() if line.strip()]
    if user_lang == "en":
        return [
            "Welcome screen and main menu restored",
            "GitHub storage stability improvements",
            "Catalog and pricing flow synchronized",
        ]
    return [
        "–í–æ–∑–≤—Ä–∞—â–µ–Ω–æ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        "–£—Å—Ç–æ–π—á–∏–≤—ã–π GitHub storage –±–µ–∑ –ø–∞–¥–µ–Ω–∏–π",
        "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω –∫–∞—Ç–∞–ª–æ–≥ –º–æ–¥–µ–ª–µ–π –∏ —Ü–µ–Ω—ã",
    ]


def _format_refill_eta(seconds: int, user_lang: str) -> str:
    safe_seconds = max(0, int(seconds))
    if safe_seconds < 60:
        return f"{safe_seconds} —Å–µ–∫" if user_lang == "ru" else f"{safe_seconds}s"
    minutes = int((safe_seconds + 59) / 60)
    return f"{minutes} –º–∏–Ω" if user_lang == "ru" else f"{minutes} min"


def _build_release_block(user_lang: str) -> str:
    version_label = "Version" if user_lang == "en" else "–í–µ—Ä—Å–∏—è"
    date_label = "Date" if user_lang == "en" else "–î–∞—Ç–∞"
    whats_new_label = "What's new" if user_lang == "en" else "–ß—Ç–æ –Ω–æ–≤–æ–≥–æ"
    lines = _get_whats_new_lines(user_lang)
    bullets = "\n".join(f"‚Ä¢ {line}" for line in lines)
    return (
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üßæ <b>{version_label}:</b> {_get_release_version()}\n"
        f"üìÖ <b>{date_label}:</b> {_get_release_date()}\n"
        f"üÜï <b>{whats_new_label}:</b>\n"
        f"{bullets}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    )


async def _build_main_menu_sections(
    update: Update,
    *,
    correlation_id: Optional[str] = None,
    user_lang: Optional[str] = None,
    menu_session: Optional[Dict[str, Any]] = None,
) -> tuple[str, str]:
    user = update.effective_user
    user_id = user.id if user else None
    storage_degraded = _is_storage_degraded()
    cached_menu = _get_menu_dep_cache(menu_session, MAIN_MENU_DEP_CACHE_TTL_SECONDS)
    if cached_menu:
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=update.effective_chat.id if update.effective_chat else None,
            update_id=update.update_id,
            action="MENU_CACHE_HIT",
            action_path="menu:dependencies",
            stage="UI_ROUTER",
            outcome="hit",
            param={"keys": sorted(cached_menu.keys())},
        )
    if storage_degraded:
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=update.effective_chat.id if update.effective_chat else None,
            update_id=update.update_id,
            action="MENU_DEPS_SKIPPED",
            action_path="menu:dependencies",
            stage="UI_ROUTER",
            outcome="read_fast",
            param={"reason": _storage_degraded_reason},
        )
    resolved_lang = user_lang or "ru"
    cached_lang = cached_menu.get("user_lang") if cached_menu else None
    if cached_lang and user_lang is None:
        resolved_lang = cached_lang
    if user_lang is None and not cached_lang:
        try:
            if update.effective_user and update.effective_user.language_code:
                lang_code = update.effective_user.language_code.lower()
                resolved_lang = "en" if lang_code.startswith("en") else "ru"
        except Exception:
            resolved_lang = "ru"

    generation_types = await _await_with_timeout(
        asyncio.to_thread(get_generation_types),
        timeout=MAIN_MENU_DEP_TIMEOUT_SECONDS,
        label="generation_types",
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        update_id=update.update_id,
        default=[],
        raise_on_timeout=False,
        log_timeout=False,
    )
    total_models = await _await_with_timeout(
        asyncio.to_thread(lambda: len(get_models_static_only())),
        timeout=MAIN_MENU_DEP_TIMEOUT_SECONDS,
        label="models_count",
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        update_id=update.update_id,
        default=0,
        raise_on_timeout=False,
        log_timeout=False,
    )
    remaining_free = (
        cached_menu.get("remaining_free") if cached_menu and "remaining_free" in cached_menu else FREE_GENERATIONS_PER_DAY
    )
    if user_id:
        if cached_menu and "is_new" in cached_menu:
            is_new = cached_menu["is_new"]
        else:
            is_new = True
    else:
        is_new = True
    referral_link = get_user_referral_link(user_id) if user_id else ""
    if user_id:
        if cached_menu and "referrals_count" in cached_menu:
            referrals_count = cached_menu["referrals_count"]
        else:
            referrals_count = 0
    else:
        referrals_count = 0
    online_count = get_fake_online_count()

    if resolved_lang == "en":
        name = user.mention_html() if user else "friend"
    else:
        name = user.mention_html() if user else "–¥—Ä—É–≥"

    if resolved_lang == "ru":
        header_text = (
            "–ü—Ä–∏–≤–µ—Ç! üëã\n\n"
            "üî• FERIXDI AI ‚Äî Ultra Creative Suite\n"
            "–ü—Ä–µ–º–∏–∞–ª—å–Ω–∞—è AI-—Å—Ç—É–¥–∏—è –≤ Telegram –¥–ª—è –º–∞—Ä–∫–µ—Ç–∏–Ω–≥–∞ / SMM / –∞—Ä–±–∏—Ç—Ä–∞–∂–∞.\n"
            "–ó–¥–µ—Å—å –¥–µ–ª–∞—é—Ç –∫—Ä–µ–∞—Ç–∏–≤ –Ω–µ '–ø–æ–∏–≥—Ä–∞—Ç—å—Å—è', –∞ –±—ã—Å—Ç—Ä–æ —Å–æ–±—Ä–∞—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª –ø–æ–¥ —Ç—Ä–∞—Ñ–∏–∫: –≤–∞—Ä–∏–∞–Ω—Ç—ã, —Å—Ç–∏–ª–∏, —É—Å–∏–ª–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞ ‚Äî –∏ —Å—Ä–∞–∑—É –≤ —Ä–∞–±–æ—Ç—É.\n\n"
            "‚ö° –ß—Ç–æ —Ç—ã –ø–æ–ª—É—á–∞–µ—à—å:\n"
            "‚Ä¢ üé® –í–∏–∑—É–∞–ª-–ø–∞–∫ –ø–æ–¥ —Ä–µ–∫–ª–∞–º—É ‚Äî –≥–µ–Ω–µ—Ä–∞—Ü–∏—è, —Å—Ç–∏–ª–∏, –≤–∞—Ä–∏–∞—Ü–∏–∏, –∞–ø—Å–∫–µ–π–ª, —Ñ–æ–Ω\n"
            "‚Ä¢ üß© –†–µ–º–∏–∫—Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ‚Äî –ø—Ä–æ–∫–∞—á–∞—Ç—å –∏—Å—Ö–æ–¥–Ω–∏–∫, —Å–º–µ–Ω–∏—Ç—å –≤–∞–π–±, —É—Å–∏–ª–∏—Ç—å –¥–µ—Ç–∞–ª–∏\n"
            "‚Ä¢ üé¨ –í–∏–¥–µ–æ-–∫—Ä–µ–∞—Ç–∏–≤—ã ‚Äî –∏–∑ –∏–¥–µ–∏ –≤ —Ä–æ–ª–∏–∫, –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –¥–≤–∏–∂–µ–Ω–∏–µ, —É–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞\n"
            "‚Ä¢ üßº –†–µ–º–∞—Å—Ç–µ—Ä –∫–∞—á–µ—Å—Ç–≤–∞ ‚Äî '–ø–æ–¥–Ω—è—Ç—å' –∫–æ–Ω—Ç–µ–Ω—Ç —Ç–∞–∫, —á—Ç–æ–±—ã –≤—ã–≥–ª—è–¥–µ–ª –¥–æ—Ä–æ–≥–æ –∏ —á–∏—Å—Ç–æ\n"
            "‚Ä¢ üöÄ –°–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ ‚Äî –º–∏–Ω–∏–º—É–º –¥–µ–π—Å—Ç–≤–∏–π, –º–∞–∫—Å–∏–º—É–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞\n\n"
            "üß© –°–ø–µ—Ü-—Ä–∞–∑–¥–µ–ª (–¥–æ–ø. –∫–∞—Ç–µ–≥–æ—Ä–∏–∏):\n"
            "–¢–∞–º –∂–∏–≤—É—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –ø–æ–¥ –Ω–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏ ‚Äî –Ω–∞–ø—Ä–∏–º–µ—Ä —É–¥–∞–ª–µ–Ω–∏–µ –≤–∞—Ç–µ—Ä–º–∞—Ä–∫–∏ –∏ –¥—Ä—É–≥–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è –¥–∞–ª—å—à–µ.\n\n"
            "üìå –ö–∞–∫ —Ä–∞–±–æ—Ç–∞—Ç—å:\n"
            "1) –í—ã–±–∏—Ä–∞–µ—à—å —Ä–∞–∑–¥–µ–ª\n"
            "2) –î–∞—ë—à—å –¢–ó –∏–ª–∏ –∑–∞–≥—Ä—É–∂–∞–µ—à—å —Ñ–∞–π–ª\n"
            "3) –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—à—å ‚Üí –∑–∞–±–∏—Ä–∞–µ—à—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç ‚úÖ\n\n"
            "üëá –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –Ω–∏–∂–µ."
        )
        referral_bonus_text = ""
    else:
        if is_new:
            header_text = t(
                "welcome_new",
                lang=resolved_lang,
                name=name,
                free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                free_limit=FREE_GENERATIONS_PER_DAY,
                models=total_models,
                types=len(generation_types),
                online=online_count,
                ref_bonus=REFERRAL_BONUS_GENERATIONS,
                ref_link=referral_link,
            )
            referral_bonus_text = ""
        else:
            referral_bonus_text = ""
            if referrals_count > 0:
                referral_bonus_text = t(
                    "msg_referral_bonus",
                    lang=resolved_lang,
                    count=referrals_count,
                    bonus=referrals_count * REFERRAL_BONUS_GENERATIONS,
                )

            header_text = t(
                "welcome_returning",
                lang=resolved_lang,
                name=name,
                online=online_count,
                free=remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY,
                free_limit=FREE_GENERATIONS_PER_DAY,
                models=total_models,
                types=len(generation_types),
            )

        if resolved_lang == "en":
            header_text += "\nüëá Select a section from the menu below."
        else:
            header_text += "\nüëá –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –≤ –º–µ–Ω—é –Ω–∏–∂–µ."

    from app.utils.singleton_lock import get_lock_admin_notice, get_lock_mode, is_lock_degraded

    is_admin_user = get_is_admin(user_id) if user_id else False
    admin_lock_notice = get_lock_admin_notice(resolved_lang) if is_admin_user else ""
    if admin_lock_notice:
        header_text += f"\n\n{admin_lock_notice}"
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else user_id,
        update_id=update.update_id,
        action="LOCK_STATUS",
        action_path="menu:lock_status",
        stage="UI_ROUTER",
        outcome="observed",
        param={
            "lock_mode": get_lock_mode(),
            "lock_degraded": is_lock_degraded(),
            "lock_notice": admin_lock_notice or None,
        },
    )

    details_parts = []
    if referral_bonus_text:
        details_parts.append(referral_bonus_text.strip())
    details_parts.append(
        t(
            "msg_full_functionality",
            lang=resolved_lang,
            remaining=remaining_free,
            total=FREE_GENERATIONS_PER_DAY,
            ref_bonus=REFERRAL_BONUS_GENERATIONS,
            ref_link=referral_link,
            models=total_models,
            types=len(generation_types),
        )
    )
    details_parts.append(_build_release_block(resolved_lang))
    details_text = "\n\n".join(part for part in details_parts if part)

    return header_text, details_text


def _split_text_by_delimiters(text: str, limit: int, delimiters: List[str]) -> List[str]:
    if len(text) <= limit:
        return [text]
    if not delimiters:
        return [text[i:i + limit] for i in range(0, len(text), limit)]

    delimiter = delimiters[0]
    parts = text.split(delimiter)
    chunks: List[str] = []
    current = ""

    for index, part in enumerate(parts):
        prefix = delimiter if index > 0 else ""
        segment = f"{prefix}{part}"
        if len(segment) > limit:
            if current:
                chunks.append(current)
                current = ""
            subchunks = _split_text_by_delimiters(part, limit, delimiters[1:])
            if prefix:
                if subchunks:
                    subchunks[0] = f"{prefix}{subchunks[0]}"
                else:
                    subchunks = [prefix]
            chunks.extend(subchunks)
            continue
        if len(current) + len(segment) <= limit:
            current += segment
        else:
            if current:
                chunks.append(current)
            current = segment

    if current:
        chunks.append(current)
    return chunks


def _find_split_index(text: str, max_len: int, delimiters: List[str]) -> int:
    for delimiter in delimiters:
        index = text.rfind(delimiter, 0, max_len + 1)
        if index != -1:
            return index + len(delimiter)
    return -1


def _split_html_text(text: str, limit: int, delimiters: List[str]) -> List[str]:
    tag_pattern = re.compile(r"<(/?)([a-zA-Z0-9]+)([^>]*)?>")
    void_tags = {"br", "img", "hr"}

    tokens: List[tuple[str, str]] = []
    last_end = 0
    for match in tag_pattern.finditer(text):
        if match.start() > last_end:
            tokens.append(("text", text[last_end:match.start()]))
        tokens.append(("tag", match.group(0)))
        last_end = match.end()
    if last_end < len(text):
        tokens.append(("text", text[last_end:]))

    stack: List[tuple[str, str]] = []
    chunks: List[str] = []
    current = ""

    def closing_len() -> int:
        return sum(len(f"</{name}>") for name, _ in stack)

    def flush_chunk() -> None:
        nonlocal current
        if not current:
            return
        closing_tags = "".join(f"</{name}>" for name, _ in reversed(stack))
        chunks.append(current + closing_tags)
        current = "".join(tag for _, tag in stack)

    for token_type, token_value in tokens:
        if token_type == "text":
            remaining = token_value
            while remaining:
                available = limit - len(current) - closing_len()
                if available <= 0:
                    flush_chunk()
                    continue
                if len(remaining) <= available:
                    current += remaining
                    break
                split_index = _find_split_index(remaining, available, delimiters)
                if split_index <= 0:
                    split_index = available
                segment = remaining[:split_index]
                current += segment
                remaining = remaining[split_index:]
                flush_chunk()
            continue

        match = tag_pattern.match(token_value)
        if not match:
            current += token_value
            continue
        is_closing = match.group(1) == "/"
        tag_name = match.group(2).lower()
        is_self_closing = token_value.endswith("/>") or tag_name in void_tags

        if is_closing and not any(name == tag_name for name, _ in stack):
            continue

        projected_stack = list(stack)
        if not is_self_closing:
            if is_closing:
                for index in range(len(projected_stack) - 1, -1, -1):
                    if projected_stack[index][0] == tag_name:
                        del projected_stack[index]
                        break
            else:
                projected_stack.append((tag_name, token_value))

        projected_closing_len = sum(len(f"</{name}>") for name, _ in projected_stack)
        if len(current) + len(token_value) + projected_closing_len > limit and current:
            flush_chunk()

        current += token_value
        if not is_self_closing:
            if is_closing:
                for index in range(len(stack) - 1, -1, -1):
                    if stack[index][0] == tag_name:
                        del stack[index]
                        break
            else:
                stack.append((tag_name, token_value))

    if current:
        flush_chunk()

    return chunks


def _is_safe_html_chunk(text: str) -> bool:
    if text.count("<") != text.count(">"):
        return False

    tag_pattern = re.compile(r"<(/?)([a-zA-Z0-9]+)(?:\\s[^>]*)?>")
    stack: List[str] = []
    for match in tag_pattern.finditer(text):
        tag = match.group(2).lower()
        if tag in {"br"}:
            continue
        if match.group(1) == "/":
            if not stack or stack[-1] != tag:
                return False
            stack.pop()
        else:
            stack.append(tag)
    return not stack


async def send_long_message(
    bot,
    chat_id: int,
    text: str,
    *,
    parse_mode: Optional[str] = "HTML",
    disable_web_page_preview: bool = True,
    reply_markup: Optional[InlineKeyboardMarkup] = None,
    **kwargs: Any,
) -> List[Any]:
    if not text:
        return []

    if parse_mode == "HTML":
        chunks = _split_html_text(
            text,
            TELEGRAM_CHUNK_LIMIT,
            ["\n\n", "\n", " "],
        )
    else:
        chunks = _split_text_by_delimiters(
            text,
            TELEGRAM_CHUNK_LIMIT,
            ["\n\n", "\n", " "],
        )
    sent_messages = []
    total_chunks = len(chunks)

    for index, chunk in enumerate(chunks):
        message_kwargs = dict(kwargs)
        if disable_web_page_preview is not None:
            message_kwargs["disable_web_page_preview"] = disable_web_page_preview
        if index == total_chunks - 1 and reply_markup is not None:
            message_kwargs["reply_markup"] = reply_markup

        if parse_mode:
            message_kwargs["parse_mode"] = parse_mode

        sent_messages.append(
            await bot.send_message(
                chat_id=chat_id,
                text=chunk,
                **message_kwargs,
            )
        )

    return sent_messages


def _build_minimal_menu_keyboard(user_lang: str, *, include_refresh: bool = False) -> InlineKeyboardMarkup:
    rows: List[List[InlineKeyboardButton]] = []
    if include_refresh:
        label = "üîÑ Refresh" if user_lang == "en" else "üîÑ –û–±–Ω–æ–≤–∏—Ç—å"
        rows.append([InlineKeyboardButton(label, callback_data="back_to_menu")])
    if user_lang == "en":
        rows.extend(
            [
                [InlineKeyboardButton("Models", callback_data="show_models")],
                [InlineKeyboardButton("Balance / Payment", callback_data="check_balance")],
                [InlineKeyboardButton("Help", callback_data="help_menu")],
                [InlineKeyboardButton("Profile", callback_data="my_generations")],
            ]
        )
    else:
        rows.extend(
            [
                [InlineKeyboardButton("–ú–æ–¥–µ–ª–∏", callback_data="show_models")],
                [InlineKeyboardButton("–ë–∞–ª–∞–Ω—Å / –û–ø–ª–∞—Ç–∞", callback_data="check_balance")],
                [InlineKeyboardButton("–ü–æ–º–æ—â—å", callback_data="help_menu")],
                [InlineKeyboardButton("–ü—Ä–æ—Ñ–∏–ª—å", callback_data="my_generations")],
            ]
        )
    return InlineKeyboardMarkup(rows)


def _build_menu_fallback_keyboard(user_lang: str) -> InlineKeyboardMarkup:
    label = "üè† Main Menu" if user_lang == "en" else "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"
    return InlineKeyboardMarkup([[InlineKeyboardButton(label, callback_data="back_to_menu")]])


_telegram_retry_random = random.Random(0)
_telegram_idempotency_cache: Dict[str, float] = {}
_telegram_idempotency_inflight: set[str] = set()
TELEGRAM_IDEMPOTENCY_STORAGE_FILE = "telegram_idempotency.json"


def _telegram_idempotency_cleanup(now: float) -> None:
    expired = [
        key
        for key, ts in _telegram_idempotency_cache.items()
        if (now - ts) > TELEGRAM_IDEMPOTENCY_TTL_SECONDS
    ]
    for key in expired:
        _telegram_idempotency_cache.pop(key, None)


def _telegram_idempotency_hit(key: Optional[str]) -> bool:
    if not key:
        return False
    now = time.monotonic()
    _telegram_idempotency_cleanup(now)
    return key in _telegram_idempotency_cache


def _telegram_idempotency_mark(key: Optional[str]) -> None:
    if not key:
        return
    now = time.monotonic()
    _telegram_idempotency_cleanup(now)
    _telegram_idempotency_cache[key] = now


async def _resolve_idempotency_storage():
    global storage
    if storage is None:
        try:
            from app.storage import get_storage

            storage = get_storage()
        except Exception:
            return None
    return storage


def _prune_idempotency_payload(payload: Dict[str, Any], *, now_s: float) -> Dict[str, float]:
    raw_keys = payload.get("keys", {})
    if not isinstance(raw_keys, dict):
        raw_keys = {}
    pruned = {}
    for key, ts in raw_keys.items():
        try:
            ts_value = float(ts)
        except (TypeError, ValueError):
            continue
        if now_s - ts_value <= TELEGRAM_IDEMPOTENCY_TTL_SECONDS:
            pruned[key] = ts_value
    return pruned


async def _telegram_idempotency_store_hit(key: Optional[str]) -> bool:
    if not key:
        return False
    if _telegram_idempotency_hit(key):
        return True
    if os.getenv("TEST_MODE", "").strip() == "1":
        return False
    storage_instance = await _resolve_idempotency_storage()
    if storage_instance is None:
        return False
    now_s = time.time()
    try:
        payload = await storage_instance.read_json_file(TELEGRAM_IDEMPOTENCY_STORAGE_FILE, default={})
    except Exception:
        return False
    pruned = _prune_idempotency_payload(payload, now_s=now_s)
    return key in pruned


async def _telegram_idempotency_store_mark(key: Optional[str]) -> None:
    if not key:
        return
    if os.getenv("TEST_MODE", "").strip() == "1":
        return
    storage_instance = await _resolve_idempotency_storage()
    if storage_instance is None:
        return
    now_s = time.time()
    def _updater(payload: Dict[str, Any]) -> Dict[str, Any]:
        pruned = _prune_idempotency_payload(payload, now_s=now_s)
        pruned[key] = now_s
        payload["keys"] = pruned
        payload["updated_at"] = now_s
        payload["ttl_s"] = TELEGRAM_IDEMPOTENCY_TTL_SECONDS
        return payload

    try:
        await storage_instance.update_json_file(
            TELEGRAM_IDEMPOTENCY_STORAGE_FILE,
            _updater,
            lock_mode="redis",
        )
    except Exception:
        return


def _build_telegram_idempotency_key(
    action: str,
    *,
    update_id: Optional[int],
    chat_id: Optional[int],
    message_id: Optional[int] = None,
    callback_id: Optional[str] = None,
) -> Optional[str]:
    if update_id is None:
        return None
    parts = [action, str(update_id), str(chat_id or "na")]
    if message_id is not None:
        parts.append(str(message_id))
    if callback_id:
        parts.append(callback_id)
    return ":".join(parts)


def _resolve_telegram_send_timeout(timeout_s: Optional[float]) -> float:
    resolved_timeout = TELEGRAM_SEND_TIMEOUT_SECONDS if timeout_s is None else timeout_s
    webhook_budget_raw = os.getenv("WEBHOOK_PROCESS_TIMEOUT_SECONDS", "").strip()
    if webhook_budget_raw:
        try:
            webhook_budget = float(webhook_budget_raw)
        except ValueError:
            webhook_budget = None
        if webhook_budget:
            headroom = float(os.getenv("TELEGRAM_SEND_BUDGET_HEADROOM_SECONDS", "0.5"))
            capped = max(0.2, webhook_budget - max(0.0, headroom))
            if capped < resolved_timeout:
                resolved_timeout = capped
    return max(0.1, resolved_timeout)


def _resolve_start_send_timeout(timeout_s: Optional[float] = None) -> float:
    requested = START_TELEGRAM_TIMEOUT_CAP_SECONDS if timeout_s is None else timeout_s
    return _resolve_telegram_send_timeout(min(requested, START_TELEGRAM_TIMEOUT_CAP_SECONDS))


def _resolve_retry_delay(backoff_s: float, attempt: int) -> float:
    base_delay = max(0.05, backoff_s * (2 ** max(0, attempt - 1)))
    jitter_ratio = max(0.0, min(0.5, TELEGRAM_SEND_RETRY_JITTER_RATIO))
    if jitter_ratio <= 0:
        return base_delay
    rng = _telegram_retry_random if is_test_mode() else random
    jitter = base_delay * jitter_ratio
    return max(0.05, base_delay + rng.uniform(0.0, jitter))


def _telegram_request_timeouts() -> Dict[str, float]:
    return {
        "connect_timeout": TELEGRAM_API_CONNECT_TIMEOUT_SECONDS,
        "read_timeout": TELEGRAM_API_READ_TIMEOUT_SECONDS,
        "write_timeout": TELEGRAM_API_WRITE_TIMEOUT_SECONDS,
        "pool_timeout": TELEGRAM_API_POOL_TIMEOUT_SECONDS,
    }


def _minimal_menu_fallback_text(user_lang: str) -> str:
    return "Main menu" if user_lang == "en" else "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"


def _build_start_ack_text(user_lang: str) -> str:
    return "‚è≥ Preparing the menu..." if user_lang == "en" else "‚è≥ –ì–æ—Ç–æ–≤–ª—é –º–µ–Ω—é..."


async def _send_start_ack(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    correlation_id: Optional[str],
    text_override: Optional[str] = None,
) -> Optional[int]:
    user_lang = "ru"
    try:
        if update.effective_user and update.effective_user.language_code:
            lang_code = update.effective_user.language_code.lower()
            user_lang = "en" if lang_code.startswith("en") else "ru"
    except Exception:
        user_lang = "ru"
    chat_id = update.effective_chat.id if update.effective_chat else None
    if not chat_id and update.effective_user:
        chat_id = update.effective_user.id
    if not chat_id:
        return None
    text = text_override or _build_start_ack_text(user_lang)
    telegram_timeouts = _telegram_request_timeouts()
    result, _timeout_seen = await _run_telegram_request(
        "start_ack_send",
        correlation_id=correlation_id,
        timeout_s=_resolve_start_send_timeout(START_ACK_TIMEOUT_SECONDS),
        retry_attempts=1,
        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
        request_fn=lambda: context.bot.send_message(
            chat_id=chat_id,
            text=text,
            **telegram_timeouts,
        ),
        update_id=update.update_id,
        chat_id=chat_id,
    )
    if result is None:
        return None
    increment_update_metric("send_message")
    return getattr(result, "message_id", None)


async def _send_ultra_minimal_menu(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    correlation_id: Optional[str],
    user_lang: str,
    action_prefix: str,
) -> bool:
    chat_id = update.effective_chat.id if update.effective_chat else None
    if not chat_id:
        return False
    ultra_text = (
        "Menu is updating, please wait." if user_lang == "en" else "–ú–µ–Ω—é –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è, –ø–æ–¥–æ–∂–¥–∏—Ç–µ."
    )
    telegram_timeouts = _telegram_request_timeouts()
    result, _timed_out = await _run_telegram_request(
        f"{action_prefix}_ultra_minimal",
        correlation_id=correlation_id,
        timeout_s=_resolve_start_send_timeout(START_TELEGRAM_ULTRA_TIMEOUT_SECONDS),
        retry_attempts=1,
        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
        request_fn=lambda: context.bot.send_message(
            chat_id=chat_id,
            text=ultra_text,
            **telegram_timeouts,
        ),
        update_id=update.update_id,
        chat_id=chat_id,
    )
    if result is not None:
        log_structured_event(
            correlation_id=correlation_id,
            user_id=update.effective_user.id if update.effective_user else None,
            chat_id=chat_id,
            update_id=update.update_id,
            action="SEND_ULTRA_MINIMAL_USED",
            action_path=f"menu:{action_prefix}",
            stage="UI_ROUTER",
            outcome="used",
            param={"reason": "timeout"},
        )
        increment_update_metric("send_message")
        return True
    return False


async def _send_start_inflight_notice(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    correlation_id: Optional[str],
    job_id: str,
) -> None:
    user_lang = "ru"
    try:
        if update.effective_user and update.effective_user.language_code == "en":
            user_lang = "en"
    except Exception:
        user_lang = "ru"
    text = (
        f"Menu is already updating. Please wait.\n\njob_id: {job_id}"
        if user_lang == "en"
        else f"–ú–µ–Ω—é —É–∂–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.\n\njob_id: {job_id}"
    )
    telegram_timeouts = _telegram_request_timeouts()
    await _run_telegram_request(
        "start_inflight_notice",
        correlation_id=correlation_id,
        timeout_s=_resolve_start_send_timeout(),
        retry_attempts=START_TELEGRAM_RETRY_ATTEMPTS,
        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
        request_fn=lambda: context.bot.send_message(
            chat_id=update.effective_chat.id if update.effective_chat else update.effective_user.id,
            text=text,
            **telegram_timeouts,
        ),
        update_id=update.update_id,
        chat_id=update.effective_chat.id if update.effective_chat else update.effective_user.id,
    )


async def _run_telegram_request(
    action: str,
    *,
    correlation_id: Optional[str],
    timeout_s: float,
    retry_attempts: int,
    retry_backoff_s: float,
    request_fn: Callable[[], Awaitable[Any]],
    update_id: Optional[int] = None,
    chat_id: Optional[int] = None,
    message_id: Optional[int] = None,
    callback_id: Optional[str] = None,
    idempotency_key: Optional[str] = None,
) -> tuple[Optional[Any], bool]:
    from app.utils.fault_injection import maybe_inject_sleep

    resolved_timeout_s = _resolve_telegram_send_timeout(timeout_s)
    timeout_seen = False
    resolved_idempotency_key = idempotency_key or _build_telegram_idempotency_key(
        action,
        update_id=update_id,
        chat_id=chat_id,
        message_id=message_id,
        callback_id=callback_id,
    )

    if resolved_idempotency_key and resolved_idempotency_key in _telegram_idempotency_inflight:
        log_structured_event(
            correlation_id=correlation_id,
            update_id=update_id,
            chat_id=chat_id,
            action="TELEGRAM_SEND_DEDUP",
            action_path=f"telegram:{action}",
            stage="TG_SEND",
            outcome="deduped",
            dedup_hit=True,
            param={"idempotency_key": resolved_idempotency_key, "source": "inflight"},
        )
        return None, timeout_seen

    if await _telegram_idempotency_store_hit(resolved_idempotency_key):
        log_structured_event(
            correlation_id=correlation_id,
            update_id=update_id,
            chat_id=chat_id,
            action="TELEGRAM_SEND_DEDUP",
            action_path=f"telegram:{action}",
            stage="TG_SEND",
            outcome="deduped",
            dedup_hit=True,
            param={"idempotency_key": resolved_idempotency_key, "source": "storage"},
        )
        return None, timeout_seen

    if resolved_idempotency_key:
        _telegram_idempotency_inflight.add(resolved_idempotency_key)

    try:
        for attempt in range(1, max(1, retry_attempts) + 1):
            attempt_started = time.monotonic()
            try:
                await maybe_inject_sleep(
                    "TRT_FAULT_INJECT_TELEGRAM_CONNECT_SLEEP_MS",
                    label=f"telegram.{action}",
                )
                if os.getenv("TRT_FAULT_INJECT_TELEGRAM_CONNECT_TIMEOUT", "").strip() in {"1", "true", "yes"}:
                    raise TimedOut("Injected Telegram connect timeout")
                result = await asyncio.wait_for(request_fn(), timeout=resolved_timeout_s)
                duration_ms = (time.monotonic() - attempt_started) * 1000
                increment_update_metric("telegram_request_ok")
                _telegram_idempotency_mark(resolved_idempotency_key)
                await _telegram_idempotency_store_mark(resolved_idempotency_key)
                log_structured_event(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    chat_id=chat_id,
                    action="TG_SEND_TIMING",
                    action_path=f"telegram:{action}",
                    stage="TG_SEND",
                    outcome="ok",
                    tg_send_ms=int(duration_ms),
                    tg_retry_count=max(0, attempt - 1),
                    param={
                        "timeout_s": resolved_timeout_s,
                        "attempt": attempt,
                        "idempotency_key": resolved_idempotency_key,
                    },
                )
                return result, timeout_seen
            except RetryAfter as exc:
                delay = max(0.1, float(exc.retry_after or retry_backoff_s))
                latency_ms = (time.monotonic() - attempt_started) * 1000
                logger.warning(
                    "TELEGRAM_REQUEST_RETRY_AFTER action=%s correlation_id=%s attempt=%s delay_s=%s error=%s error_repr=%s",
                    action,
                    correlation_id,
                    attempt,
                    delay,
                    str(exc),
                    repr(exc),
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    chat_id=chat_id,
                    action="TG_SEND_RETRY",
                    action_path=f"telegram:{action}",
                    stage="TG_SEND",
                    outcome="retry",
                    tg_retry_count=attempt,
                    param={"delay_s": delay, "reason": "retry_after"},
                )
                log_critical_event(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    stage="TG_SEND",
                    latency_ms=latency_ms,
                    retry_after=delay,
                    timeout_s=resolved_timeout_s,
                    attempt=attempt,
                    error_code="TELEGRAM_RETRY_AFTER",
                    error_id="TELEGRAM_RETRY_AFTER",
                    exception_class=type(exc).__name__,
                    where="telegram.request",
                    fix_hint="Respect retry_after and reduce send rate.",
                    retryable=True,
                    upstream="telegram",
                    elapsed_ms=latency_ms,
                )
                increment_update_metric("telegram_request_retry_after")
                await asyncio.sleep(delay)
            except (asyncio.TimeoutError, TimedOut, httpx.ConnectTimeout, httpx.ReadTimeout) as exc:
                timeout_seen = True
                latency_ms = (time.monotonic() - attempt_started) * 1000
                logger.warning(
                    "TELEGRAM_REQUEST_TIMEOUT action=%s correlation_id=%s attempt=%s error=%s error_repr=%s error_type=%s",
                    action,
                    correlation_id,
                    attempt,
                    str(exc),
                    repr(exc),
                    type(exc).__name__,
                )
                log_critical_event(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    stage="TG_SEND",
                    latency_ms=latency_ms,
                    retry_after=None,
                    timeout_s=resolved_timeout_s,
                    attempt=attempt,
                    error_code="TELEGRAM_REQUEST_TIMEOUT",
                    error_id="TELEGRAM_REQUEST_TIMEOUT",
                    exception_class=type(exc).__name__,
                    where="telegram.request",
                    fix_hint="Increase timeouts or reduce payload size; verify Telegram API latency.",
                    retryable=True,
                    upstream="telegram",
                    elapsed_ms=latency_ms,
                )
                increment_update_metric("telegram_request_timeout")
                if attempt >= retry_attempts:
                    return None, timeout_seen
                await asyncio.sleep(_resolve_retry_delay(retry_backoff_s, attempt))
            except Exception as exc:
                latency_ms = (time.monotonic() - attempt_started) * 1000
                logger.warning(
                    "TELEGRAM_REQUEST_FAILED action=%s correlation_id=%s attempt=%s error=%s error_repr=%s error_type=%s",
                    action,
                    correlation_id,
                    attempt,
                    str(exc),
                    repr(exc),
                    type(exc).__name__,
                )
                log_critical_event(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    stage="TG_SEND",
                    latency_ms=latency_ms,
                    retry_after=None,
                    timeout_s=resolved_timeout_s,
                    attempt=attempt,
                    error_code="TELEGRAM_REQUEST_FAILED",
                    error_id="TELEGRAM_REQUEST_FAILED",
                    exception_class=type(exc).__name__,
                    where="telegram.request",
                    fix_hint="Inspect Telegram API errors and retry policy.",
                    retryable=True,
                    upstream="telegram",
                    elapsed_ms=latency_ms,
                )
                increment_update_metric("telegram_request_failed")
                if attempt >= retry_attempts:
                    return None, timeout_seen
                await asyncio.sleep(_resolve_retry_delay(retry_backoff_s, attempt))
        return None, timeout_seen
    finally:
        if resolved_idempotency_key:
            _telegram_idempotency_inflight.discard(resolved_idempotency_key)


async def _show_minimal_menu(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    source: str,
    correlation_id: Optional[str],
    prefer_edit: bool = True,
    edit_message_id: Optional[int] = None,
    timeout_s: Optional[float] = None,
    max_attempts: Optional[int] = None,
    fallback_timeout_s: Optional[float] = None,
    fallback_max_attempts: Optional[int] = None,
    action_prefix: str = "minimal_menu",
    include_refresh: bool = False,
) -> dict:
    user_id = update.effective_user.id if update.effective_user else None
    user_lang = "ru"
    try:
        if update.effective_user and update.effective_user.language_code == "en":
            user_lang = "en"
    except Exception:
        user_lang = "ru"
    chat_id = update.effective_chat.id if update.effective_chat else user_id
    reply_markup = _build_minimal_menu_keyboard(user_lang, include_refresh=include_refresh)
    message_id = None
    used_edit = False
    fallback_send = False
    send_ok = False
    telegram_timeouts = _telegram_request_timeouts()
    is_start_flow = source.startswith("/start") or action_prefix.startswith("start")
    resolved_timeout_s = (
        _resolve_start_send_timeout(timeout_s) if is_start_flow else _resolve_telegram_send_timeout(timeout_s)
    )
    resolved_attempts = (
        START_TELEGRAM_RETRY_ATTEMPTS if max_attempts is None and is_start_flow else TELEGRAM_SEND_RETRY_ATTEMPTS
        if max_attempts is None
        else max_attempts
    )
    resolved_fallback_timeout_s = (
        MINIMAL_MENU_FALLBACK_TIMEOUT_SECONDS if fallback_timeout_s is None else fallback_timeout_s
    )
    resolved_fallback_attempts = (
        MINIMAL_MENU_FALLBACK_RETRY_ATTEMPTS if fallback_max_attempts is None else fallback_max_attempts
    )
    if is_start_flow:
        resolved_fallback_timeout_s = min(resolved_fallback_timeout_s, START_TELEGRAM_TIMEOUT_CAP_SECONDS)
    timeout_seen = False

    if update.callback_query and prefer_edit:
        edit_result, edit_timeout = await _run_telegram_request(
            f"{action_prefix}_edit",
            correlation_id=correlation_id,
            timeout_s=resolved_timeout_s,
            retry_attempts=resolved_attempts,
            retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
            request_fn=lambda: update.callback_query.edit_message_text(
                MINIMAL_MENU_TEXT,
                reply_markup=reply_markup,
                **telegram_timeouts,
            ),
            update_id=update.update_id,
            chat_id=chat_id,
            message_id=update.callback_query.message.message_id if update.callback_query.message else None,
        )
        timeout_seen = timeout_seen or edit_timeout
        if edit_result is not None:
            used_edit = True
            send_ok = True
            message_id = getattr(edit_result, "message_id", None) or (
                update.callback_query.message.message_id if update.callback_query.message else None
            )
            logger.info(
                "MINIMAL_MENU_RENDER corr_id=%s method=edit source=%s user_id=%s chat_id=%s",
                correlation_id,
                source,
                user_id,
                chat_id,
            )
            increment_update_metric("send_message")
        else:
            fallback_send = True

    if chat_id and not used_edit and edit_message_id and prefer_edit:
        edit_result, edit_timeout = await _run_telegram_request(
            f"{action_prefix}_edit_message_id",
            correlation_id=correlation_id,
            timeout_s=resolved_timeout_s,
            retry_attempts=resolved_attempts,
            retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
            request_fn=lambda: context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=edit_message_id,
                text=MINIMAL_MENU_TEXT,
                reply_markup=reply_markup,
                **telegram_timeouts,
            ),
            update_id=update.update_id,
            chat_id=chat_id,
            message_id=edit_message_id,
        )
        timeout_seen = timeout_seen or edit_timeout
        if edit_result is not None:
            used_edit = True
            send_ok = True
            message_id = getattr(edit_result, "message_id", None) or edit_message_id
            logger.info(
                "MINIMAL_MENU_RENDER corr_id=%s method=edit_message_id source=%s user_id=%s chat_id=%s",
                correlation_id,
                source,
                user_id,
                chat_id,
            )
            increment_update_metric("send_message")
        else:
            fallback_send = True

    if chat_id and not used_edit:
        send_result, send_timeout = await _run_telegram_request(
            f"{action_prefix}_send",
            correlation_id=correlation_id,
            timeout_s=resolved_timeout_s,
            retry_attempts=resolved_attempts,
            retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
            request_fn=lambda: context.bot.send_message(
                chat_id=chat_id,
                text=MINIMAL_MENU_TEXT,
                reply_markup=reply_markup,
                **telegram_timeouts,
            ),
            update_id=update.update_id,
            chat_id=chat_id,
        )
        timeout_seen = timeout_seen or send_timeout
        if send_result is not None:
            send_ok = True
            message_id = getattr(send_result, "message_id", None)
            logger.info(
                "MINIMAL_MENU_RENDER corr_id=%s method=send source=%s user_id=%s chat_id=%s",
                correlation_id,
                source,
                user_id,
                chat_id,
            )
            increment_update_metric("send_message")
        else:
            logger.error("MINIMAL_MENU_SEND_FAILED corr_id=%s", correlation_id)

    if not send_ok and chat_id:
        logger.warning("MENU_RENDER_FAIL corr_id=%s source=%s fallback=attempt", correlation_id, source)
        fallback_text = _minimal_menu_fallback_text(user_lang)
        fallback_keyboard = _build_menu_fallback_keyboard(user_lang)
        fallback_result, fallback_timeout = await _run_telegram_request(
            f"{action_prefix}_fallback",
            correlation_id=correlation_id,
            timeout_s=resolved_fallback_timeout_s,
            retry_attempts=resolved_fallback_attempts,
            retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
            request_fn=lambda: context.bot.send_message(
                chat_id=chat_id,
                text=fallback_text,
                reply_markup=fallback_keyboard,
                **telegram_timeouts,
            ),
            update_id=update.update_id,
            chat_id=chat_id,
        )
        timeout_seen = timeout_seen or fallback_timeout
        fallback_send = True
        if fallback_result is not None:
            send_ok = True
            message_id = getattr(fallback_result, "message_id", None)
            logger.info("MENU_RENDER_FAIL corr_id=%s fallback_ok=true", correlation_id)
            increment_update_metric("send_message")
        else:
            logger.warning("MENU_RENDER_FAIL corr_id=%s fallback_ok=false", correlation_id)

    if not send_ok and timeout_seen and source.startswith("/start"):
        send_ok = await _send_ultra_minimal_menu(
            update,
            context,
            correlation_id=correlation_id,
            user_lang=user_lang,
            action_prefix=action_prefix,
        )

    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="MENU_RENDER",
        action_path=f"menu:{source}",
        stage="UI_ROUTER",
        outcome="ok" if send_ok else "degraded",
        param={
            "used_edit": used_edit,
            "fallback_send": fallback_send,
            "message_id": message_id,
        },
    )
    return {
        "correlation_id": correlation_id,
        "user_id": user_id,
        "chat_id": chat_id,
        "update_id": update.update_id,
        "ui_context_before": None,
        "ui_context_after": UI_CONTEXT_MAIN_MENU,
        "used_edit": used_edit,
        "fallback_send": fallback_send,
        "message_id": message_id,
    }


async def ensure_main_menu(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    source: str,
    correlation_id: Optional[str] = None,
    prefer_edit: bool = True,
) -> dict:
    """–ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç MAIN_MENU –∏ —è–∫–æ—Ä–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø–æ—Å–ª–µ –ª—é–±—ã—Ö –≤—ã—Ö–æ–¥–æ–≤."""
    result = await show_main_menu(
        update,
        context,
        source=source,
        correlation_id=correlation_id,
        prefer_edit=prefer_edit,
    )
    log_structured_event(
        correlation_id=result.get("correlation_id"),
        user_id=result.get("user_id"),
        chat_id=result.get("chat_id"),
        update_id=result.get("update_id"),
        action="MENU_ANCHOR_RENDER",
        action_path=f"menu_anchor:{source}",
        stage="UI_ROUTER",
        outcome="render",
        param={
            "source": source,
            "ui_context_before": result.get("ui_context_before"),
            "ui_context_after": result.get("ui_context_after"),
            "used_edit": result.get("used_edit"),
            "fallback_send": result.get("fallback_send"),
            "message_id": result.get("message_id"),
        },
    )
    return result


async def _award_referral_bonus_with_timeout(
    *,
    referrer_id: int,
    referred_user_id: int,
    ref_param: Optional[str],
    correlation_id: Optional[str],
    partner_id: str,
    bonus: int,
) -> None:
    try:
        await asyncio.wait_for(
            award_referral_bonus(
                referrer_id=referrer_id,
                referred_user_id=referred_user_id,
                ref_param=ref_param,
                correlation_id=correlation_id,
                partner_id=partner_id,
                bonus=bonus,
            ),
            timeout=START_REFERRAL_TIMEOUT_SECONDS,
        )
    except Exception as exc:
        logger.warning("START_REFERRAL_BONUS_FAILED correlation_id=%s error=%s", correlation_id, exc)


async def _start_menu_with_fallback(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    source: str,
    correlation_id: Optional[str],
    edit_message_id: Optional[int] = None,
) -> dict:
    force_placeholder = bool(
        os.getenv("TRT_FAULT_INJECT_STORAGE_SLEEP_MS", "").strip()
        or os.getenv("TRT_FAULT_INJECT_MENU_SLEEP_MS", "").strip()
        or os.getenv("START_FORCE_PLACEHOLDER", "").strip().lower() in {"1", "true", "yes", "on"}
    )
    try:
        fallback_max_ms = int(os.getenv("START_FALLBACK_MAX_MS", str(START_FALLBACK_MAX_MS)))
    except ValueError:
        fallback_max_ms = START_FALLBACK_MAX_MS
    fast_timeout_s = max(0.1, fallback_max_ms / 1000)
    if not force_placeholder:
        fast_menu_task = asyncio.create_task(
            show_main_menu(
                update,
                context,
                source=source,
                correlation_id=correlation_id,
                prefer_edit=True,
                edit_message_id=edit_message_id,
            ),
        )
        try:
            result = await asyncio.wait_for(fast_menu_task, timeout=fast_timeout_s)
            log_structured_event(
                correlation_id=correlation_id,
                user_id=update.effective_user.id if update.effective_user else None,
                chat_id=update.effective_chat.id if update.effective_chat else None,
                update_id=update.update_id,
                action="START_FAST_PATH",
                action_path=f"menu:{source}",
                stage="UI_ROUTER",
                outcome="full_menu",
                param={"fallback_ms": fallback_max_ms},
            )
            return result
        except asyncio.TimeoutError:
            if not fast_menu_task.done():
                fast_menu_task.cancel()
                fast_menu_task.add_done_callback(
                    lambda t: _suppress_task_exceptions(t, action="start_fast_path_timeout")
                )
            logger.warning(
                "START_FAST_PATH_TIMEOUT source=%s correlation_id=%s timeout_s=%s",
                source,
                correlation_id,
                fast_timeout_s,
            )
        except Exception as exc:
            if not fast_menu_task.done():
                fast_menu_task.cancel()
                fast_menu_task.add_done_callback(
                    lambda t: _suppress_task_exceptions(t, action="start_fast_path_failed")
                )
            logger.warning(
                "START_FAST_PATH_FAILED source=%s correlation_id=%s error=%s",
                source,
                correlation_id,
                exc,
            )
    placeholder_result: dict
    try:
        placeholder_result = await asyncio.wait_for(
            _show_minimal_menu(
                update,
                context,
                source=source,
                correlation_id=correlation_id,
                prefer_edit=bool(edit_message_id),
                edit_message_id=edit_message_id,
                timeout_s=START_PLACEHOLDER_TIMEOUT_SECONDS,
                max_attempts=START_PLACEHOLDER_RETRY_ATTEMPTS,
                fallback_timeout_s=START_PLACEHOLDER_TIMEOUT_SECONDS,
                fallback_max_attempts=1,
                action_prefix="start_placeholder",
                include_refresh=_is_storage_degraded(),
            ),
            timeout=fast_timeout_s,
        )
    except asyncio.TimeoutError:
        logger.warning(
            "START_PLACEHOLDER_TIMEOUT source=%s correlation_id=%s timeout_s=%s",
            source,
            correlation_id,
            fast_timeout_s,
        )
        _create_background_task(
            _show_minimal_menu(
                update,
                context,
                source=source,
                correlation_id=correlation_id,
                prefer_edit=bool(edit_message_id),
                edit_message_id=edit_message_id,
                timeout_s=START_PLACEHOLDER_TIMEOUT_SECONDS,
                max_attempts=START_PLACEHOLDER_RETRY_ATTEMPTS,
                fallback_timeout_s=START_PLACEHOLDER_TIMEOUT_SECONDS,
                fallback_max_attempts=1,
                action_prefix="start_placeholder",
                include_refresh=_is_storage_degraded(),
            ),
            action="start_placeholder_background",
        )
        placeholder_result = {
            "correlation_id": correlation_id,
            "user_id": update.effective_user.id if update.effective_user else None,
            "chat_id": update.effective_chat.id if update.effective_chat else None,
            "update_id": update.update_id,
            "ui_context_before": None,
            "ui_context_after": UI_CONTEXT_MAIN_MENU,
            "used_edit": False,
            "fallback_send": False,
            "message_id": edit_message_id,
        }
    log_structured_event(
        correlation_id=correlation_id,
        user_id=update.effective_user.id if update.effective_user else None,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        update_id=update.update_id,
        action="START_FALLBACK",
        action_path=f"menu:{source}",
        stage="UI_ROUTER",
        outcome="degraded",
        param={
            "fallback_ms": fallback_max_ms,
            "reason": "forced_placeholder" if force_placeholder else "fast_path_timeout",
        },
    )
    placeholder_message_id = placeholder_result.get("message_id") or edit_message_id

    if os.getenv("TRT_FAULT_INJECT_STORAGE_SLEEP_MS", "").strip():
        return placeholder_result

    full_menu_task = asyncio.create_task(
        show_main_menu(
            update,
            context,
            source=source,
            correlation_id=correlation_id,
            prefer_edit=True,
            edit_message_id=placeholder_message_id,
        )
    )
    _register_background_task(full_menu_task, action="start_full_menu")
    return placeholder_result


async def show_main_menu(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    source: str = "unknown",
    *,
    correlation_id: Optional[str] = None,
    prefer_edit: bool = True,
    edit_message_id: Optional[int] = None,
) -> dict:
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –µ–¥–∏–Ω–æ–µ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –¥–ª—è –≤—Å–µ—Ö –≤—Ö–æ–¥–æ–≤."""
    correlation_id = correlation_id or ensure_correlation_id(update, context)
    menu_start_ts = time.monotonic()
    dedup_result = _safe_menu_renderer.get_if_duplicate(correlation_id, update.update_id)
    if dedup_result:
        log_structured_event(
            correlation_id=correlation_id,
            user_id=dedup_result.get("user_id"),
            chat_id=dedup_result.get("chat_id"),
            update_id=update.update_id,
            action="MENU_RENDER_DEDUP",
            action_path=f"menu:{source}",
            stage="UI_ROUTER",
            outcome="skip",
            param={"reason": "correlation_update_dedup"},
        )
        return dedup_result

    result: Optional[dict] = None
    user_id = update.effective_user.id if update.effective_user else None
    user_lang = "ru"
    chat_id = update.effective_chat.id if update.effective_chat else user_id
    ui_context_before = None
    session = user_sessions.ensure(user_id) if user_id else None
    if user_id and user_id in user_sessions:
        ui_context_before = user_sessions[user_id].get("ui_context")
    previous_welcome_version = None
    if user_id and user_id in user_sessions:
        previous_welcome_version = user_sessions[user_id].get("welcome_version")

    if _is_storage_degraded():
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="MENU_DEPS_SKIPPED",
            action_path=f"menu:{source}",
            stage="UI_ROUTER",
            outcome="read_fast",
            param={"reason": _storage_degraded_reason},
        )
        return await _show_minimal_menu(
            update,
            context,
            source=source,
            correlation_id=correlation_id,
            prefer_edit=prefer_edit,
            include_refresh=True,
            action_prefix="minimal_menu",
        )

    try:
        if user_id:
            cached_lang = _get_menu_dep_cache(session, MAIN_MENU_LANG_CACHE_TTL_SECONDS)
            if cached_lang and cached_lang.get("user_lang"):
                user_lang = cached_lang["user_lang"]
            else:
                try:
                    if update.effective_user and update.effective_user.language_code:
                        lang_code = update.effective_user.language_code.lower()
                        user_lang = "en" if lang_code.startswith("en") else "ru"
                except Exception:
                    user_lang = "ru"
                _set_menu_dep_cache(session, user_lang=user_lang)

        if user_id:
            _schedule_menu_dependency_refresh(
                user_id=user_id,
                correlation_id=correlation_id,
                menu_session=session,
            )
            cached_menu = _get_menu_dep_cache(session, MAIN_MENU_DEP_CACHE_TTL_SECONDS) or {}
            missing_keys = [
                key
                for key in ("user_lang", "remaining_free", "is_new", "referrals_count")
                if key not in cached_menu
            ]
            if missing_keys:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_DEPS_SKIPPED",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="background_refresh",
                    param={"missing": missing_keys},
                )

        if user_id:
            reset_session_context(
                user_id,
                reason=f"show_main_menu:{source}",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update.update_id,
                chat_id=chat_id,
            )
            set_session_context(
                user_id,
                to_context=UI_CONTEXT_MAIN_MENU,
                reason=f"show_main_menu:{source}",
                correlation_id=correlation_id,
                update_id=update.update_id,
                chat_id=chat_id,
            )

        is_start_flow = source.startswith("/start")
        telegram_timeouts = _telegram_request_timeouts()
        start_timeout_seen = False

        async def _build_menu_payload(*, timeout: float) -> tuple[InlineKeyboardMarkup, str]:
            from app.utils.fault_injection import maybe_inject_sleep

            await maybe_inject_sleep("TRT_FAULT_INJECT_MENU_SLEEP_MS", label=f"menu_build:{source}")
            keyboard_task = asyncio.create_task(
                build_main_menu_keyboard(user_id, user_lang=user_lang, is_new=False),
                name="menu_keyboard_build",
            )
            sections_task = asyncio.create_task(
                _build_main_menu_sections(
                    update,
                    correlation_id=correlation_id,
                    user_lang=user_lang,
                    menu_session=session,
                ),
                name="menu_sections_build",
            )
            try:
                done, pending = await asyncio.wait(
                    {keyboard_task, sections_task},
                    timeout=timeout,
                    return_when=asyncio.ALL_COMPLETED,
                )
                if pending:
                    for task in pending:
                        task.cancel()
                    await asyncio.gather(*pending, return_exceptions=True)
                    raise asyncio.TimeoutError()
                for task in done:
                    if task.cancelled():
                        raise asyncio.CancelledError()
                    if task.exception():
                        raise task.exception()
                keyboard_payload = keyboard_task.result()
                header_text, _details_text = sections_task.result()
            except Exception:
                for task in (keyboard_task, sections_task):
                    if task and not task.done():
                        task.cancel()
                await asyncio.gather(keyboard_task, sections_task, return_exceptions=True)
                raise
            reply_markup = InlineKeyboardMarkup(keyboard_payload)
            return reply_markup, header_text

        async def _retry_render_full_menu() -> None:
            try:
                reply_markup_retry, header_text_retry = await _build_menu_payload(
                    timeout=MAIN_MENU_BACKGROUND_TIMEOUT_SECONDS,
                )
            except Exception as exc:
                logger.warning(
                    "MENU_RENDER_RETRY_SKIPPED source=%s correlation_id=%s error=%s",
                    source,
                    correlation_id,
                    exc,
                )
                return
            if not chat_id:
                return
            try:
                if is_start_flow:
                    await _run_telegram_request(
                        "start_menu_retry_send",
                        correlation_id=correlation_id,
                        timeout_s=_resolve_start_send_timeout(),
                        retry_attempts=START_TELEGRAM_RETRY_ATTEMPTS,
                        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
                        request_fn=lambda: context.bot.send_message(
                            chat_id=chat_id,
                            text=header_text_retry,
                            reply_markup=reply_markup_retry,
                            parse_mode="HTML",
                            disable_web_page_preview=True,
                            **telegram_timeouts,
                        ),
                        update_id=update.update_id,
                        chat_id=chat_id,
                    )
                else:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=header_text_retry,
                        reply_markup=reply_markup_retry,
                        parse_mode="HTML",
                        disable_web_page_preview=True,
                    )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER_RETRY_OK",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="send_ok",
                )
            except Exception as exc:
                logger.warning(
                    "MENU_RENDER_RETRY_FAILED source=%s correlation_id=%s error=%s",
                    source,
                    correlation_id,
                    exc,
                )

        try:
            reply_markup, header_text = await _build_menu_payload(timeout=MAIN_MENU_TOTAL_TIMEOUT_SECONDS)
        except (asyncio.TimeoutError, MenuDependencyTimeout):
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="MENU_BUILD_TIMEOUT",
                action_path=f"menu:{source}",
                stage="UI_ROUTER",
                outcome="timeout",
                error_code="MENU_BUILD_TIMEOUT",
                fix_hint="menu_build_timeout",
            )
            await _send_menu_error_notice(update, context, correlation_id=correlation_id)
            result = await _show_minimal_menu(
                update,
                context,
                source=source,
                correlation_id=correlation_id,
                prefer_edit=prefer_edit,
            )
            _create_background_task(
                _retry_render_full_menu(),
                action="menu_render_retry",
            )
            return result

        menu_build_ms = int((time.monotonic() - menu_start_ts) * 1000)
        welcome_hash = _safe_text_hash(header_text)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="MENU_RENDER",
            action_path=f"menu:{source}",
            stage="UI_ROUTER",
            outcome="render",
            text_length=len(header_text) if header_text else 0,
            text_hash=welcome_hash,
            param={
                "ui_context": UI_CONTEXT_MAIN_MENU,
                "welcome_version": welcome_hash,
            },
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="MENU_BUILT",
            action_path=f"menu:{source}",
            stage="UI_ROUTER",
            outcome="ok",
            param={"duration_ms": menu_build_ms},
        )
        if source == "/start":
            logger.info(
                "START_MENU_BUILT correlation_id=%s user_id=%s chat_id=%s duration_ms=%s",
                correlation_id,
                user_id,
                chat_id,
                menu_build_ms,
            )
        logger.info("MAIN_MENU_SHOWN source=%s user_id=%s", source, user_id)

        used_edit = False
        fallback_send = False
        message_id = None

        if (
            previous_welcome_version == welcome_hash
            and update.callback_query
            and prefer_edit
        ):
            try:
                await update.callback_query.answer()
            except Exception:
                logger.debug("menu dedupe callback answer failed", exc_info=True)
            if user_id:
                user_sessions.ensure(user_id)["welcome_version"] = welcome_hash
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="MENU_RENDER_SKIP",
                action_path=f"menu:{source}",
                stage="UI_ROUTER",
                outcome="same_version",
                text_hash=welcome_hash,
                param={
                    "ui_context": UI_CONTEXT_MAIN_MENU,
                    "welcome_version": welcome_hash,
                },
            )
            result = {
                "correlation_id": correlation_id,
                "user_id": user_id,
                "chat_id": chat_id,
                "update_id": update.update_id,
                "ui_context_before": ui_context_before,
                "ui_context_after": UI_CONTEXT_MAIN_MENU,
                "used_edit": used_edit,
                "fallback_send": fallback_send,
                "message_id": update.callback_query.message.message_id
                if update.callback_query.message
                else None,
            }
            return result

        if (
            edit_message_id
            and prefer_edit
            and chat_id
            and len(header_text) <= TELEGRAM_TEXT_LIMIT
        ):
            try:
                if is_start_flow:
                    edit_result, edit_timeout = await _run_telegram_request(
                        "start_menu_edit",
                        correlation_id=correlation_id,
                        timeout_s=_resolve_start_send_timeout(),
                        retry_attempts=START_TELEGRAM_RETRY_ATTEMPTS,
                        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
                        request_fn=lambda: context.bot.edit_message_text(
                            chat_id=chat_id,
                            message_id=edit_message_id,
                            text=header_text,
                            reply_markup=reply_markup,
                            parse_mode="HTML",
                            disable_web_page_preview=True,
                            **telegram_timeouts,
                        ),
                        update_id=update.update_id,
                        chat_id=chat_id,
                        message_id=edit_message_id,
                    )
                    start_timeout_seen = start_timeout_seen or edit_timeout
                    if edit_result is None:
                        raise RuntimeError("start_menu_edit_failed")
                else:
                    edit_result = await context.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=edit_message_id,
                        text=header_text,
                        reply_markup=reply_markup,
                        parse_mode="HTML",
                        disable_web_page_preview=True,
                    )
                used_edit = True
                message_id = getattr(edit_result, "message_id", None) or edit_message_id
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="edit_ok",
                    text_hash=welcome_hash,
                    param={
                        "ui_context": UI_CONTEXT_MAIN_MENU,
                        "welcome_version": welcome_hash,
                        "edit_message_id": edit_message_id,
                    },
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER_OK",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="ok",
                    text_hash=welcome_hash,
                )
                logger.info(
                    "MENU_RENDER_DELIVERED corr_id=%s method=edit_message_id source=%s user_id=%s chat_id=%s",
                    correlation_id,
                    source,
                    user_id,
                    chat_id,
                )
                increment_update_metric("send_message")
            except Exception as exc:
                fallback_send = True
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="edit_failed",
                    error_code="MENU_EDIT_FAIL",
                    fix_hint=str(exc),
                    text_hash=welcome_hash,
                    param={
                        "ui_context": UI_CONTEXT_MAIN_MENU,
                        "welcome_version": welcome_hash,
                        "edit_message_id": edit_message_id,
                    },
                )

        if not used_edit and update.callback_query and prefer_edit and len(header_text) <= TELEGRAM_TEXT_LIMIT:
            query = update.callback_query
            try:
                if is_start_flow:
                    edit_result, edit_timeout = await _run_telegram_request(
                        "start_menu_edit_query",
                        correlation_id=correlation_id,
                        timeout_s=_resolve_start_send_timeout(),
                        retry_attempts=START_TELEGRAM_RETRY_ATTEMPTS,
                        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
                        request_fn=lambda: query.edit_message_text(
                            header_text,
                            reply_markup=reply_markup,
                            parse_mode="HTML",
                            **telegram_timeouts,
                        ),
                        update_id=update.update_id,
                        chat_id=chat_id,
                        message_id=query.message.message_id if query.message else None,
                    )
                    start_timeout_seen = start_timeout_seen or edit_timeout
                    if edit_result is None:
                        raise RuntimeError("start_menu_edit_query_failed")
                else:
                    edit_result = await query.edit_message_text(
                        header_text,
                        reply_markup=reply_markup,
                        parse_mode="HTML",
                    )
                used_edit = True
                message_id = getattr(edit_result, "message_id", None) or (
                    query.message.message_id if query.message else None
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="edit_ok",
                    text_hash=welcome_hash,
                    param={
                        "ui_context": UI_CONTEXT_MAIN_MENU,
                        "welcome_version": welcome_hash,
                    },
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER_OK",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="ok",
                    text_hash=welcome_hash,
                )
                logger.info(
                    "MENU_RENDER_DELIVERED corr_id=%s method=edit source=%s user_id=%s chat_id=%s",
                    correlation_id,
                    source,
                    user_id,
                    chat_id,
                )
                increment_update_metric("send_message")
            except Exception as exc:
                fallback_send = True
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="edit_failed",
                    error_code="MENU_EDIT_FAIL",
                    fix_hint=str(exc),
                    text_hash=welcome_hash,
                    param={
                        "ui_context": UI_CONTEXT_MAIN_MENU,
                        "welcome_version": welcome_hash,
                    },
                )

        if chat_id and not used_edit:
            try:
                if is_start_flow:
                    send_result, send_timeout = await _run_telegram_request(
                        "start_menu_send",
                        correlation_id=correlation_id,
                        timeout_s=_resolve_start_send_timeout(),
                        retry_attempts=START_TELEGRAM_RETRY_ATTEMPTS,
                        retry_backoff_s=TELEGRAM_SEND_RETRY_BACKOFF_SECONDS,
                        request_fn=lambda: context.bot.send_message(
                            chat_id=chat_id,
                            text=header_text,
                            reply_markup=reply_markup,
                            parse_mode="HTML",
                            disable_web_page_preview=True,
                            **telegram_timeouts,
                        ),
                        update_id=update.update_id,
                        chat_id=chat_id,
                    )
                    start_timeout_seen = start_timeout_seen or send_timeout
                    if send_result is None:
                        raise RuntimeError("start_menu_send_failed")
                else:
                    send_result = await context.bot.send_message(
                        chat_id=chat_id,
                        text=header_text,
                        reply_markup=reply_markup,
                        parse_mode="HTML",
                        disable_web_page_preview=True,
                    )
                message_id = getattr(send_result, "message_id", None)
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="send_ok",
                    text_hash=welcome_hash,
                    param={
                        "ui_context": UI_CONTEXT_MAIN_MENU,
                        "welcome_version": welcome_hash,
                    },
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="MENU_RENDER_OK",
                    action_path=f"menu:{source}",
                    stage="UI_ROUTER",
                    outcome="ok",
                    text_hash=welcome_hash,
                )
                logger.info(
                    "MENU_RENDER_DELIVERED corr_id=%s method=send source=%s user_id=%s chat_id=%s",
                    correlation_id,
                    source,
                    user_id,
                    chat_id,
                )
                increment_update_metric("send_message")
            except Exception as exc:
                logger.error(
                    "MAIN_MENU_SEND_FAILED source=%s correlation_id=%s error=%s",
                    source,
                    correlation_id,
                    exc,
                    exc_info=True,
                )
                if is_start_flow and start_timeout_seen:
                    ultra_ok = await _send_ultra_minimal_menu(
                        update,
                        context,
                        correlation_id=correlation_id,
                        user_lang=user_lang,
                        action_prefix="start_menu",
                    )
                    if ultra_ok:
                        return {
                            "correlation_id": correlation_id,
                            "user_id": user_id,
                            "chat_id": chat_id,
                            "update_id": update.update_id,
                            "ui_context_before": ui_context_before,
                            "ui_context_after": UI_CONTEXT_MAIN_MENU,
                            "used_edit": False,
                            "fallback_send": False,
                            "message_id": None,
                        }
                result = await _show_minimal_menu(
                    update,
                    context,
                    source=source,
                    correlation_id=correlation_id,
                    prefer_edit=prefer_edit,
                    include_refresh=_is_storage_degraded(),
                )
                return result

        reply_sent_ms = int((time.monotonic() - menu_start_ts) * 1000)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="MENU_REPLY_SENT",
            action_path=f"menu:{source}",
            stage="UI_ROUTER",
            outcome="ok",
            param={"duration_ms": reply_sent_ms},
        )
        if source == "/start":
            logger.info(
                "START_REPLY_SENT correlation_id=%s user_id=%s chat_id=%s duration_ms=%s",
                correlation_id,
                user_id,
                chat_id,
                reply_sent_ms,
            )
        if user_id:
            user_sessions.ensure(user_id)["welcome_version"] = welcome_hash
        result = {
            "correlation_id": correlation_id,
            "user_id": user_id,
            "chat_id": chat_id,
            "update_id": update.update_id,
            "ui_context_before": ui_context_before,
            "ui_context_after": UI_CONTEXT_MAIN_MENU,
            "used_edit": used_edit,
            "fallback_send": fallback_send,
            "message_id": message_id,
        }
        return result
    except Exception as exc:
        logger.error(
            "MAIN_MENU_DEGRADED source=%s correlation_id=%s error=%s",
            source,
            correlation_id,
            exc,
            exc_info=True,
        )
        await _send_menu_error_notice(update, context, correlation_id=correlation_id)
        result = await _show_minimal_menu(
            update,
            context,
            source=source,
            correlation_id=correlation_id,
            prefer_edit=prefer_edit,
            include_refresh=_is_storage_degraded(),
        )
        return result
    finally:
        if result is None:
            result = await _show_minimal_menu(
                update,
                context,
                source=source,
                correlation_id=correlation_id,
                prefer_edit=prefer_edit,
                include_refresh=_is_storage_degraded(),
            )
        _safe_menu_renderer.record(correlation_id, update.update_id, result)


async def respond_price_undefined(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    session: dict,
    user_lang: str,
    model_id: Optional[str],
    gen_type: Optional[str],
    sku_id: Optional[str],
    price_quote: Optional[dict],
    free_remaining: Optional[int],
    correlation_id: Optional[str],
    action_path: str,
    source: str = "price_undefined",
    prefer_edit: bool = True,
) -> None:
    """Respond to price undefined guard-block with warning logs and anchored main menu."""
    from app.pricing.free_policy import is_sku_free_daily

    user_id = update.effective_user.id if update.effective_user else None
    chat_id = update.effective_chat.id if update.effective_chat else user_id
    storage_mode = os.getenv("STORAGE_MODE", "unknown")
    free_remaining_value = free_remaining if free_remaining is not None else 0
    free_eligible = bool(sku_id and is_sku_free_daily(sku_id))
    price_quote_missing = price_quote is None

    if free_remaining_value > 0 and free_eligible and price_quote_missing:
        reason_code = "FREE_BYPASS_EXPECTED_BUT_MISSING_QUOTE"
        fix_hint = (
            "BUG: free_should_bypass_price=true but price_quote_missing=true; "
            "price_quote is None; run quote resolve; check YAML price mapping."
        )
    elif not sku_id:
        reason_code = "MODEL_HAS_NO_SKU"
        fix_hint = "model_id/gen_type did not resolve sku_id; check catalog mapping."
    elif "price_quote" not in session:
        reason_code = "QUOTE_RESOLVER_NOT_CALLED"
        fix_hint = "price_quote missing in session; ensure quote resolver is invoked."
    elif free_remaining_value == 0 and price_quote_missing:
        reason_code = "PAID_NO_QUOTE"
        fix_hint = "paid flow missing quote; check pricing resolver and YAML mappings."
    else:
        reason_code = "PRICE_MAP_MISSING_FOR_SKU"
        fix_hint = "price mapping missing for sku_id; check pricing catalog."

    param_snapshot = {
        "gen_type": gen_type,
        "model_id": model_id,
        "sku_id": sku_id,
        "ui_context": session.get("ui_context"),
        "waiting_for": session.get("waiting_for"),
        "free_remaining": free_remaining_value,
        "storage_mode": storage_mode,
    }
    welcome_version = session.get("welcome_version") if isinstance(session, dict) else None

    _log_structured_warning(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="PRICE_UNDEFINED",
        action_path=action_path,
        model_id=model_id,
        gen_type=gen_type,
        sku_id=sku_id,
        stage="PRICE_RESOLVE",
        outcome="blocked",
        error_code=reason_code,
        fix_hint=fix_hint,
        param={
            "reason_code": reason_code,
            "param_snapshot": param_snapshot,
            "free_eligible": free_eligible,
            "free_remaining": free_remaining_value,
            "storage_mode": storage_mode,
            "welcome_version": welcome_version,
        },
    )
    _log_structured_warning(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="GUARD_BLOCK",
        action_path=action_path,
        model_id=model_id,
        gen_type=gen_type,
        sku_id=sku_id,
        stage="PRICE_RESOLVE",
        outcome="blocked",
        error_code=reason_code,
        fix_hint=fix_hint,
        param={
            "reason_code": reason_code,
            "reason": "price_undefined",
            "param_snapshot": param_snapshot,
        },
    )

    pricing_error_code = (
        "NO_PRICE_FOR_PARAMS"
        if reason_code in {"MODEL_HAS_NO_SKU", "PAID_NO_QUOTE", "PRICE_MAP_MISSING_FOR_SKU"}
        else reason_code
    )
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="pricing_miss",
        action_path=action_path,
        model_id=model_id,
        gen_type=gen_type,
        sku_id=sku_id,
        stage="PRICE_RESOLVE",
        outcome="blocked",
        error_code=pricing_error_code,
        fix_hint=fix_hint,
        param={
            "reason_code": reason_code,
            "param_snapshot": param_snapshot,
            "free_remaining": free_remaining_value,
        },
    )

    message_text = (
        format_pricing_blocked_message(model_id, user_lang=user_lang)
        if model_id
        else (
            "‚ùå <b>–¶–µ–Ω–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞</b>\n\n"
            "–ü—Ä–∏—á–∏–Ω–∞: —Ü–µ–Ω–∞ –¥–ª—è –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            if user_lang == "ru"
            else (
                "‚ùå <b>Price is unavailable</b>\n\n"
                "Reason: pricing for this model is missing.\n"
                "Please select another model or try again later."
            )
        )
    )
    if correlation_id:
        message_text = (
            f"{message_text}\n\nüîé corr_id: <code>{correlation_id}</code>"
            if user_lang == "ru"
            else f"{message_text}\n\nüîé corr_id: <code>{correlation_id}</code>"
        )

    sent = False
    if update.callback_query and prefer_edit:
        try:
            await update.callback_query.edit_message_text(message_text, parse_mode="HTML")
            sent = True
        except Exception as exc:
            logger.warning("Price undefined edit failed: %s", exc)
    if not sent:
        if update.message:
            await update.message.reply_text(message_text, parse_mode="HTML")
        elif chat_id:
            await context.bot.send_message(chat_id=chat_id, text=message_text, parse_mode="HTML")

    await ensure_main_menu(
        update,
        context,
        source=source,
        correlation_id=correlation_id,
        prefer_edit=False,
    )


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ï–¥–∏–Ω—ã–π —Å—Ç–∞—Ä—Ç–æ–≤—ã–π UX: –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."""
    # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
    logger.info("üöÄ /start command received! user_id=%s chat_id=%s update_id=%s", 
                update.effective_user.id if update.effective_user else "unknown",
                update.effective_chat.id if update.effective_chat else "unknown", 
                update.update_id if hasattr(update, 'update_id') else "unknown")
    
    start_ts = time.monotonic()
    increment_update_metric("handler_enter")
    correlation_id: Optional[str] = None
    user_id: Optional[int] = None
    chat_id: Optional[int] = None
    start_ack_message_id: Optional[int] = None
    start_job_id: Optional[str] = None
    start_job_claimed = False
    partner_id = (os.getenv("PARTNER_ID") or os.getenv("BOT_INSTANCE_ID") or "default").strip() or "default"
    try:
        user_id = update.effective_user.id if update.effective_user else None
        chat_id = update.effective_chat.id if update.effective_chat else None
        try:
            correlation_id = ensure_correlation_id(update, context)
        except Exception as exc:
            correlation_id = uuid.uuid4().hex
            logger.error("‚ùå Failed to build correlation_id in /start: %s", exc, exc_info=True)
        if os.getenv("START_SKIP_ACK", "").strip().lower() not in {"1", "true", "yes", "on"}:
            try:
                start_ack_message_id = await _send_start_ack(
                    update,
                    context,
                    correlation_id=correlation_id,
                )
            except Exception as exc:
                logger.debug("START_ACK_FAILED correlation_id=%s error=%s", correlation_id, exc)
        try:
            _create_background_task(
                upsert_user_registry_entry(update.effective_user, correlation_id=correlation_id),
                action="user_registry_upsert",
            )
        except Exception as exc:
            logger.error("‚ùå Failed to queue user registry update in /start: %s", exc, exc_info=True)
        if user_id:
            start_job_claimed, start_job_id = _claim_start_inflight_job(user_id)
            if not start_job_claimed:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="START_DEDUP_HIT",
                    action_path="command:/start",
                    stage="HANDLER",
                    outcome="coalesced",
                    job_id=start_job_id,
                    param={"reason": "inflight_guard"},
                )
                if start_ack_message_id is None:
                    await _send_start_ack(
                        update,
                        context,
                        correlation_id=correlation_id,
                    )
                return
        try:
            logger.info(
                "START_HANDLER_ENTER correlation_id=%s user_id=%s chat_id=%s",
                correlation_id,
                user_id,
                chat_id,
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="START_ENTER",
                action_path="command:/start",
                stage="HANDLER",
                outcome="enter",
                job_id=start_job_id,
                param={"duration_ms": 0},
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="COMMAND_START",
                action_path="command:/start",
                outcome="received",
                job_id=start_job_id,
            )
        except Exception as exc:
            logger.error("‚ùå /start structured log failed: %s", exc, exc_info=True)
        ref_param = context.args[0] if context.args else None
        referral_parse = parse_referral_param(ref_param)
        if ref_param is not None:
            try:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="REFERRAL_PARSED",
                    action_path="command:/start",
                    outcome="valid" if referral_parse.valid else "invalid",
                    param={
                        "referrer_id": referral_parse.referrer_id,
                        "referred_user_id": user_id,
                        "partner_id": partner_id,
                        "ref_param": ref_param,
                        "valid": referral_parse.valid,
                    },
                )
            except Exception as exc:
                logger.error("‚ùå /start referral log failed: %s", exc, exc_info=True)
        if _should_dedupe_update(
            update,
            context,
            action="COMMAND_START",
            action_path="command:/start",
            user_id=user_id,
            chat_id=chat_id,
        ):
            logger.info(
                "START_DEDUP_REPLAY correlation_id=%s user_id=%s chat_id=%s",
                correlation_id,
                user_id,
                chat_id,
            )
            await _start_menu_with_fallback(
                update,
                context,
                source="/start-dedup",
                correlation_id=correlation_id,
                edit_message_id=start_ack_message_id,
            )
            return
        logger.info(f"üî• /start command received from user_id={user_id if user_id else 'None'}")
        try:
            if user_id:
                reset_session_context(
                    user_id,
                    reason="command:/start",
                    clear_gen_type=True,
                    correlation_id=correlation_id,
                    update_id=update.update_id,
                    chat_id=chat_id,
                )
            budget_ms = max(0, int(START_HANDLER_BUDGET_MS))
            start_budget_timeout = False
            try:
                if budget_ms > 0:
                    await asyncio.wait_for(
                        _start_menu_with_fallback(
                            update,
                            context,
                            source="/start",
                            correlation_id=correlation_id,
                            edit_message_id=start_ack_message_id,
                        ),
                        timeout=budget_ms / 1000,
                    )
                else:
                    await _start_menu_with_fallback(
                        update,
                        context,
                        source="/start",
                        correlation_id=correlation_id,
                        edit_message_id=start_ack_message_id,
                    )
            except asyncio.TimeoutError:
                start_budget_timeout = True
                logger.warning(
                    "START_BUDGET_TIMEOUT source=/start correlation_id=%s budget_ms=%s",
                    correlation_id,
                    budget_ms,
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="START_BUDGET_TIMEOUT",
                    action_path="command:/start",
                    stage="UI_ROUTER",
                    outcome="timeout",
                    param={"budget_ms": budget_ms},
                )
                _create_background_task(
                    _start_menu_with_fallback(
                        update,
                        context,
                        source="/start",
                        correlation_id=correlation_id,
                        edit_message_id=start_ack_message_id,
                    ),
                    action="start_budget_fallback",
                )
            if not start_budget_timeout:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="START_OK",
                    action_path="command:/start",
                    stage="UI_ROUTER",
                    outcome="ok",
                )
            if referral_parse.valid and referral_parse.referrer_id and user_id:
                _create_background_task(
                    _award_referral_bonus_with_timeout(
                        referrer_id=referral_parse.referrer_id,
                        referred_user_id=user_id,
                        ref_param=ref_param,
                        correlation_id=correlation_id,
                        partner_id=partner_id,
                        bonus=REFERRAL_BONUS_GENERATIONS,
                    ),
                    action="referral_bonus",
                )
            if start_budget_timeout:
                return
        except Exception as exc:
            logger.error(
                "‚ùå /start handler failed handler=start user_id=%s partner_id=%s correlation_id=%s error=%s",
                user_id,
                partner_id,
                correlation_id,
                exc,
                exc_info=True,
            )
            trace_error(
                correlation_id or uuid.uuid4().hex,
                "ERR_TG_START_HANDLER",
                ERROR_CATALOG.get("ERR_TG_START_HANDLER", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ /start –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–µ–Ω—é."),
                exc,
                force_stacktrace=True,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="COMMAND_START",
                action_path="command:/start",
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="COMMAND_START",
                action_path="command:/start",
                stage="UI_ROUTER",
                outcome="failed",
                error_code="ERR_TG_START_HANDLER",
                fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ /start –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–µ–Ω—é.",
                param={"handler": "start", "partner_id": partner_id},
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="START_DEGRADED",
                action_path="command:/start",
                stage="UI_ROUTER",
                outcome="degraded",
                param={"handler": "start", "partner_id": partner_id},
            )
            try:
                fallback_text = f"‚ö†Ô∏è –í—Ä–µ–º–µ–Ω–Ω—ã–π —Å–±–æ–π, –≤–µ—Ä–Ω—É–ª –≤ –º–µ–Ω—é. –õ–æ–≥: {correlation_id}."
                if update.message:
                    await update.message.reply_text(fallback_text)
                elif update.callback_query and update.callback_query.message:
                    await update.callback_query.message.reply_text(fallback_text)
            except Exception:
                logger.debug("start fallback message failed", exc_info=True)
            await _show_minimal_menu(
                update,
                context,
                source="/start",
                correlation_id=correlation_id,
                prefer_edit=False,
                include_refresh=_is_storage_degraded(),
            )
    except Exception as exc:
        fallback_correlation_id = correlation_id or uuid.uuid4().hex
        logger.error(
            "‚ùå /start unexpected failure handler=start user_id=%s partner_id=%s correlation_id=%s error=%s",
            user_id,
            partner_id,
            fallback_correlation_id,
            exc,
            exc_info=True,
        )
        trace_error(
            fallback_correlation_id,
            "INTERNAL_EXCEPTION",
            ERROR_CATALOG.get("INTERNAL_EXCEPTION", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ stacktrace –∏ –ª–æ–≥–∏."),
            exc,
            force_stacktrace=True,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="COMMAND_START",
            action_path="command:/start",
        )
        try:
            fallback_text = f"‚ö†Ô∏è –í—Ä–µ–º–µ–Ω–Ω—ã–π —Å–±–æ–π, –≤–µ—Ä–Ω—É–ª –≤ –º–µ–Ω—é. –õ–æ–≥: {fallback_correlation_id}."
            if update.message:
                await update.message.reply_text(fallback_text)
            elif update.callback_query and update.callback_query.message:
                await update.callback_query.message.reply_text(fallback_text)
        except Exception:
            logger.debug("start fallback message failed", exc_info=True)
        try:
            await _show_minimal_menu(
                update,
                context,
                source="/start",
                correlation_id=fallback_correlation_id,
                prefer_edit=False,
                include_refresh=_is_storage_degraded(),
            )
        except Exception:
            logger.debug("start minimal menu fallback failed", exc_info=True)
    finally:
        increment_update_metric("handler_exit")
        _log_handler_latency("start", start_ts, update)
        handler_total_ms = int((time.monotonic() - start_ts) * 1000)
        if correlation_id:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="HANDLER_TOTAL",
                action_path="command:/start",
                stage="HANDLER",
                outcome="done",
                param={"handler_total_ms": handler_total_ms},
            )
        if user_id and start_job_claimed:
            _release_start_inflight_job(user_id, start_job_id)


async def reset_wizard_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Safely reset wizard state and return to main menu."""
    user_id = update.effective_user.id if update.effective_user else None
    chat_id = update.effective_chat.id if update.effective_chat else None
    correlation_id = ensure_correlation_id(update, context)
    if user_id:
        clear_user_session(user_id, reason="command:/reset")
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="COMMAND_RESET",
        action_path="command:/reset",
        outcome="processed",
    )
    await show_main_menu(update, context, source="/reset")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send a message when the command /help is issued."""
    await update.message.reply_text(
        'üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n\n'
        '/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n'
        '/models - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π\n'
        '/generate - –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
        '/cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é\n'
        '/search [–∑–∞–ø—Ä–æ—Å] - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
        '/ask [–≤–æ–ø—Ä–æ—Å] - –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å\n'
        '/add [–∑–Ω–∞–Ω–∏–µ] - –î–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞–Ω–∏–µ –≤ –±–∞–∑—É\n\n'
        'üí° <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>\n'
        '1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /models —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏\n'
        '2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /balance —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
        '3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /generate —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
        '4. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞\n'
        '5. –í–≤–µ–¥–∏—Ç–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n'
        '6. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!',
        parse_mode='HTML'
    )


async def list_models(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """List available models from static menu."""
    user_id = update.effective_user.id
    
    # Get models grouped by category
    categories = get_categories_from_registry()
    
    # Create category selection keyboard
    keyboard = []
    for category in categories:
        models_in_category = get_models_by_category_from_registry(category)
        emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
        keyboard.append([InlineKeyboardButton(
            f"{emoji} {category} ({len(models_in_category)})",
            callback_data=f"category:{category}"
        )])
    
    user_lang = get_user_language(update.effective_user.id)
    keyboard.append([InlineKeyboardButton(t('btn_all_models_short', lang=user_lang), callback_data="all_models")])
    keyboard.append([
        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
    ])
    keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    models_text = "üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n\n"
    models_text += "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤—Å–µ –º–æ–¥–µ–ª–∏:\n\n"
    for category in categories:
        models_in_category = get_models_by_category_from_registry(category)
        models_text += f"<b>{category}</b>: {len(models_in_category)} –º–æ–¥–µ–ª–µ–π\n"
    
    await update.message.reply_text(
        models_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def start_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start the generation process."""
    start_ts = time.monotonic()
    try:
        global kie
        user_id = update.effective_user.id
        
        # Check if KIE API is configured (initialize if needed)
        if kie is None:
            kie = get_client()
        if not kie.api_key:
            await update.message.reply_text(
                '‚ùå API –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –£–∫–∞–∂–∏—Ç–µ API –∫–ª—é—á –≤ —Ñ–∞–π–ª–µ .env'
            )
            return
        
        await update.message.reply_text(
            'üöÄ –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é!\n\n'
            '–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞:',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üìã –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–µ–ª–∏", callback_data="show_models")
            ]])
        )
        
        return SELECTING_MODEL
    finally:
        _log_handler_latency("start_generation", start_ts, update)


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Latency wrapper for button callbacks."""
    start_ts = time.monotonic()
    query = update.callback_query
    update_id = getattr(update, "update_id", None)
    callback_answered = False
    try:
        _create_background_task(
            _check_and_deliver_pending_results(update, context),
            action="pending_result_check",
        )
        if query:
            user_id = query.from_user.id if query.from_user else None
            user_lang = get_user_language(user_id) if user_id else "ru"
            data = query.data
            if data == "back_to_menu":
                pass
            elif data == "check_balance":
                pass
            elif data == "show_models":
                pass
            elif data == "all_models":
                pass
            elif data == "cancel":
                pass
            try:
                await _answer_callback_early(
                    query,
                    user_lang=user_lang,
                    callback_data=query.data,
                )
                callback_answered = True
                if update_id is not None:
                    track_outgoing_action(update_id, action_type="answerCallbackQuery")
            except Exception as answer_error:
                logger.warning("Could not answer callback query quickly: %s", answer_error)

        acquired = False
        if _callback_semaphore:
            try:
                await asyncio.wait_for(
                    _callback_semaphore.acquire(),
                    timeout=CALLBACK_CONCURRENCY_TIMEOUT_SECONDS,
                )
                acquired = True
            except asyncio.TimeoutError:
                user_id = update.effective_user.id if update.effective_user else None
                user_lang = get_user_language(user_id) if user_id else "ru"
                busy_text = (
                    "‚è≥ <b>–°–µ—Ä–≤–µ—Ä –∑–∞–Ω—è—Ç</b>\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥."
                    if user_lang == "ru"
                    else "‚è≥ <b>Server busy</b>\n\nPlease try again in a few seconds."
                )
                reply_markup = build_back_to_menu_keyboard(user_lang)
                if query and query.message:
                    try:
                        await query.message.reply_text(
                            busy_text,
                            parse_mode="HTML",
                            reply_markup=reply_markup,
                        )
                        if update_id is not None:
                            track_outgoing_action(update_id, action_type="send_message")
                    except Exception:
                        logger.warning("Failed to send busy response to user", exc_info=True)
                return ConversationHandler.END
        try:
            return await _button_callback_impl(update, context, callback_answered=callback_answered)
        finally:
            if acquired and _callback_semaphore:
                _callback_semaphore.release()
    finally:
        _log_handler_latency("button_callback", start_ts, update)


async def show_admin_generation(query, context, gen: dict, current_index: int, total_count: int):
    """Show admin generation with navigation."""
    try:
        from datetime import datetime
        
        gen_id = gen.get('id', 0)
        user_id = gen.get('user_id', 0)
        model_id = gen.get('model_id', 'Unknown')
        model_name = gen.get('model_name', model_id)
        timestamp = gen.get('timestamp', 0)
        price = gen.get('price', 0)
        is_free = gen.get('is_free', False)
        result_urls = gen.get('result_urls', [])
        params = gen.get('params', {})
        
        if timestamp:
            dt = datetime.fromtimestamp(timestamp)
            date_str = dt.strftime("%d.%m.%Y %H:%M")
        else:
            date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        
        user_link = f"tg://user?id={user_id}"
        user_lang = get_user_language(query.from_user.id)
        
        if user_lang == 'ru':
            gen_text = (
                f"üìö <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen_id}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üë§ <a href=\"{user_link}\">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id}</a>\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {date_str}\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else format_rub_amount(price)}\n"
                f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
            )
            
            if params:
                params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in list(params.items())[:5]])
                gen_text += f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
            
            gen_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            gen_text += f"üìÑ {current_index + 1} –∏–∑ {total_count}"
        else:
            gen_text = (
                f"üìö <b>Generation #{gen_id}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üë§ <a href=\"{user_link}\">User {user_id}</a>\n"
                f"üìÖ <b>Date:</b> {date_str}\n"
                f"ü§ñ <b>Model:</b> {model_name}\n"
                f"üí∞ <b>Cost:</b> {'üéÅ Free' if is_free else format_rub_amount(price)}\n"
                f"üì¶ <b>Results:</b> {len(result_urls)}\n\n"
            )
            
            if params:
                params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in list(params.items())[:5]])
                gen_text += f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
            
            gen_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            gen_text += f"üìÑ {current_index + 1} of {total_count}"
        
        keyboard = []
        
        # Navigation buttons
        if total_count > 1:
            keyboard.append([
                InlineKeyboardButton(t('btn_previous', lang=user_lang), callback_data=f"admin_gen_nav:prev"),
                InlineKeyboardButton(t('btn_next', lang=user_lang), callback_data=f"admin_gen_nav:next")
            ])
        
        # View result button
        if result_urls:
            keyboard.append([
                InlineKeyboardButton(t('btn_view_result', lang=user_lang), callback_data=f"admin_gen_view:{current_index}")
            ])
        
        # Back button
        keyboard.append([
            InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")
        ])
        
        await query.edit_message_text(
            gen_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML',
            disable_web_page_preview=False
        )
    except Exception as e:
        logger.error(f"Error showing admin generation: {e}", exc_info=True)
        user_lang = get_user_language(query.from_user.id)
        await query.answer(t('error_display_generation', lang=user_lang), show_alert=True)


async def show_payment_screenshot(query, payment: dict, current_index: int, total_count: int):
    """Show payment screenshot with navigation."""
    try:
        import datetime
        
        payment_id = payment.get('id', 0)
        user_id = payment.get('user_id', 0)
        amount = payment.get('amount', 0)
        timestamp = payment.get('timestamp', 0)
        screenshot_file_id = payment.get('screenshot_file_id')
        
        if not screenshot_file_id:
            await query.edit_message_text("‚ùå –°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —ç—Ç–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞.")
            return
        
        # Format payment info
        amount_str = format_rub_amount(amount)
        if timestamp:
            dt = datetime.datetime.fromtimestamp(timestamp)
            date_str = dt.strftime("%d.%m.%Y %H:%M")
        else:
            date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        
        user_link = f"tg://user?id={user_id}"
        caption = (
            f"üì∏ <b>–°–∫—Ä–∏–Ω—à–æ—Ç –ø–ª–∞—Ç–µ–∂–∞ #{payment_id}</b>\n\n"
            f"üë§ <a href=\"{user_link}\">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id}</a>\n"
            f"üíµ –°—É–º–º–∞: {amount_str}\n"
            f"üìÖ –î–∞—Ç–∞: {date_str}\n\n"
            f"üìÑ {current_index + 1} –∏–∑ {total_count}"
        )
        
        # Create navigation keyboard
        keyboard = []
        nav_row = []
        
        if total_count > 1:
            if current_index > 0:
                nav_row.append(InlineKeyboardButton("‚óÄÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∏–π", callback_data="payment_screenshot_nav:prev"))
            if current_index < total_count - 1:
                nav_row.append(InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∏–π ‚ñ∂Ô∏è", callback_data="payment_screenshot_nav:next"))
            
            if nav_row:
                keyboard.append(nav_row)
        
        keyboard.append([InlineKeyboardButton("üìä –ù–∞–∑–∞–¥ –∫ –ø–ª–∞—Ç–µ–∂–∞–º", callback_data="admin_payments_back")])
        
        reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
        
        # Send photo with caption
        try:
            # Edit original message first to show we're loading
            await query.edit_message_text(
                f"üì∏ <b>–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞...</b>\n\n"
                f"–ü–ª–∞—Ç–µ–∂ #{payment_id}",
                parse_mode='HTML'
            )
            
            # Send photo as new message
            await query.message.reply_photo(
                photo=screenshot_file_id,
                caption=caption,
                parse_mode='HTML',
                reply_markup=reply_markup
            )
        except Exception as e:
            logger.error(f"Error sending payment screenshot: {e}")
            await query.edit_message_text(
                f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞</b>\n\n"
                f"–ü–ª–∞—Ç–µ–∂ #{payment_id}\n"
                f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id}\n"
                f"–°—É–º–º–∞: {amount_str} ‚ÇΩ\n"
                f"–î–∞—Ç–∞: {date_str}\n\n"
                f"‚ö†Ô∏è –°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–≤–æ–∑–º–æ–∂–Ω–æ, —Ñ–∞–π–ª —É–¥–∞–ª–µ–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)",
                parse_mode='HTML',
                reply_markup=reply_markup
            )
    except Exception as e:
        logger.error(f"Error in show_payment_screenshot: {e}", exc_info=True)
        try:
            await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞.")
        except:
            pass


async def _button_callback_impl(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    *,
    callback_answered: bool = False,
):
    """Handle button callbacks. CRITICAL: Always calls query.answer() to prevent button hanging."""
    import time
    start_time = time.time()
    query = None
    user_id = None
    data = None
    user_lang = 'ru'
    is_admin_user = False
    session_store = get_session_store(context)
    
    # ==================== NO-SILENCE GUARD: Track outgoing actions ====================
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
    guard = get_no_silence_guard()
    _create_background_task(
        _check_and_deliver_pending_results(update, context),
        action="pending_result_check",
    )
    update_id = update.update_id
    correlation_id = ensure_correlation_id(update, context)
    # ==================== END NO-SILENCE GUARD ====================
    
    # üî• MAXIMUM LOGGING: Log entry point
    try:
        query = update.callback_query
        user_id = query.from_user.id if query and query.from_user else None
        data = query.data if query else None
        if query and query.from_user:
            _create_background_task(
                upsert_user_registry_entry(query.from_user),
                action="user_registry_upsert",
            )
        correlation_id = ensure_correlation_id(update, context)
        chat_id = query.message.chat_id if query and query.message else None
        message_id = query.message.message_id if query and query.message else None
        guard.set_trace_context(
            update,
            context,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            message_id=message_id,
            update_type="callback",
            correlation_id=correlation_id,
            action="CALLBACK",
            action_path=build_action_path(data),
            stage="UI_ROUTER",
        )
        trace_event(
            "info",
            correlation_id,
            event="TRACE_IN",
            stage="UI_ROUTER",
            update_type="callback",
            action="CALLBACK",
            action_path=build_action_path(data),
            user_id=user_id,
            chat_id=chat_id,
            message_id=message_id,
            callback_data=data,
            route_decision="button_callback",
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="CALLBACK",
            action_path=build_action_path(data),
            outcome="received",
        )
        session = get_session_cached(context, session_store, user_id, update_id, default={}) if user_id is not None else {}
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="UX_CLICK",
            action_path=build_action_path(data),
            model_id=session.get("model_id") if isinstance(session, dict) else None,
            param={
                "waiting_for": session.get("waiting_for") if isinstance(session, dict) else None,
                "current_param": session.get("current_param") if isinstance(session, dict) else None,
                "callback_data": data,
            },
            outcome="received",
            error_code="UX_CLICK_OK",
            fix_hint="–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏.",
        )
        session_get_count = get_session_get_count(context, update_id)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="SESSION_GET_COUNT",
            action_path=build_action_path(data),
            stage="SESSION_CACHE",
            outcome="count",
            param={"count": session_get_count},
        )
        logger.debug(f"üî•üî•üî• BUTTON_CALLBACK ENTRY: user_id={user_id}, data={data}, query_id={query.id if query else 'None'}, message_id={query.message.message_id if query and query.message else 'None'}")
    except Exception as e:
        logger.error(f"‚ùå‚ùå‚ùå ERROR in button_callback entry logging: {e}", exc_info=True)
    
    # CRITICAL: Always answer callback query to prevent button hanging
    # This must be done FIRST, before any other operations
    try:
        query = update.callback_query
        if not query:
            logger.error("No callback_query in update")
            return ConversationHandler.END
        
        user_id = update.effective_user.id if update.effective_user else None
        data = query.data if query else None
        is_admin_user = get_is_admin(user_id) if user_id else False
        
        # ALWAYS answer callback immediately to prevent button hanging
        # This is critical - if we don't answer, button will hang
        if not callback_answered:
            try:
                await query.answer()
                callback_answered = True
                # NO-SILENCE GUARD: Track outgoing action
                track_outgoing_action(update_id, action_type="answerCallbackQuery")
            except Exception as answer_error:
                logger.warning(f"Could not answer callback query: {answer_error}")
                try:
                    if context and query and query.id:
                        await context.bot.answer_callback_query(query.id)
                except Exception:
                    pass
                # Continue anyway - better to process than to fail completely
        
        if _should_dedupe_update(
            update,
            context,
            action="CALLBACK",
            action_path=build_action_path(data),
            user_id=user_id,
            chat_id=query.message.chat_id if query and query.message else None,
        ):
            return ConversationHandler.END

        logger.info(f"Button callback received: user_id={user_id}, data='{data}'")
        
        if not data:
            logger.error("No data in callback_query")
            try:
                user_lang = get_user_language(user_id) if user_id else 'ru'
                await query.answer(t('error_no_data', lang=user_lang), show_alert=True)
            except:
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤ –∫–Ω–æ–ø–∫–µ", show_alert=True)
                except:
                    pass
            return ConversationHandler.END
        
        # Get user language early for error messages
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
        except:
            user_lang = 'ru'

        if context and getattr(context, "user_data", None) is not None:
            context.user_data["last_callback_handled_update_id"] = update_id

        if data.startswith("type_header:"):
            model_type = data.split(":", 1)[1] if ":" in data else ""
            user_lang = get_user_language(user_id) if user_id else "ru"
            from app.helpers.models_menu import build_models_menu_for_type, get_type_label

            keyboard_markup, models_count = build_models_menu_for_type(user_lang, model_type)
            type_label = get_type_label(model_type, user_lang)
            if user_lang == "ru":
                header_text = (
                    f"üìÇ <b>–†–∞–∑–¥–µ–ª:</b> {type_label}\n\n"
                    f"–î–æ—Å—Ç—É–ø–Ω–æ –º–æ–¥–µ–ª–µ–π: <b>{models_count}</b>\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –Ω–∏–∂–µ."
                )
            else:
                header_text = (
                    f"üìÇ <b>Section:</b> {type_label}\n\n"
                    f"Available models: <b>{models_count}</b>\n\n"
                    "Select a model below."
                )
            try:
                await query.edit_message_text(
                    header_text,
                    reply_markup=keyboard_markup,
                    parse_mode="HTML",
                )
            except Exception as exc:
                logger.warning("Failed to render type filter menu: %s", exc)
                try:
                    await query.message.reply_text(
                        header_text,
                        reply_markup=keyboard_markup,
                        parse_mode="HTML",
                    )
                except Exception:
                    await query.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ä–∞–∑–¥–µ–ª", show_alert=True)
            return SELECTING_MODEL

        if data == "other_models":
            try:
                await query.answer()
            except Exception as exc:
                logger.warning("Error answering callback for other_models: %s", exc)
            user_lang = get_user_language(user_id) if user_id else "ru"
            reset_session_context(
                user_id,
                reason="other_models",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            set_session_context(
                user_id,
                to_context=UI_CONTEXT_MODEL_MENU,
                reason="other_models",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            try:
                from app.helpers.models_menu_handlers import handle_model_callback
                await handle_model_callback(
                    query,
                    user_id,
                    user_lang,
                    "model:sora-watermark-remover",
                )
                return SELECTING_MODEL
            except Exception as exc:
                logger.error("Error in other_models handler: %s", exc, exc_info=True)
                fallback_text = (
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –º–æ–¥–µ–ª—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                    if user_lang == "ru"
                    else "‚ùå Unable to open model. Please try again later."
                )
                try:
                    await query.answer(fallback_text, show_alert=True)
                except Exception:
                    pass
                await show_main_menu(update, context, source="other_models_error")
                return ConversationHandler.END

        if data == "cancel_command":
            session = user_sessions.get(user_id, {}) if user_id else {}
            job_id = session.get("job_id") if isinstance(session, dict) else None
            if job_id and user_id is not None:
                now_ms = _now_ms()
                _set_user_ui_action(user_id, "cancel_click", now_ms)
                if isinstance(session, dict):
                    session["last_ui_action"] = "cancel_click"
                    session["last_ui_ts_ms"] = now_ms
                accepted = await _request_job_cancel(
                    update=update,
                    context=context,
                    job_id=job_id,
                    user_id=user_id,
                    user_lang=user_lang,
                    callback_data="cancel_command",
                    query=query,
                    correlation_id=correlation_id,
                    state_source="callback",
                )
                if accepted:
                    _clear_user_task_context(
                        user_id,
                        reason="cancel_accepted",
                        task_id=session.get("task_id"),
                        allow_mismatch=True,
                    )
                    await ensure_main_menu(
                        update,
                        context,
                        source="cancel_generation",
                        prefer_edit=False,
                    )
                    return ConversationHandler.END
            try:
                await query.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞" if user_lang == "ru" else "Cancelled")
            except Exception:
                pass
            if user_id is not None:
                _clear_user_task_context(
                    user_id,
                    reason="cancel_callback",
                    task_id=session.get("task_id") if isinstance(session, dict) else None,
                    allow_mismatch=True,
                )
            await ensure_main_menu(update, context, source="cancel", prefer_edit=False)
            return ConversationHandler.END

        if data == "reset_step":
            session_store.clear(user_id)
            await show_main_menu(update, context, source="reset_step")
            track_outgoing_action(update_id, action_type="edit_message_text")
            return ConversationHandler.END

        if data == "reset_wizard":
            session_store.clear(user_id)
            await show_main_menu(update, context, source="reset_wizard")
            track_outgoing_action(update_id, action_type="edit_message_text")
            return ConversationHandler.END

        # üî•üî•üî• SUPER-DETAILED CONTEXT LOGGING
        try:
            session = get_session_cached(context, session_store, user_id, update_id, default=None) if user_id else None
            session_keys = list(session.keys()) if session else []
            session_model_id = session.get('model_id') if session else None
            session_waiting_for = session.get('waiting_for') if session else None
            session_current_param = session.get('current_param') if session else None
            session_params_keys = list(session.get('params', {}).keys()) if session else []
            session_required = session.get('required', []) if session else []
            session_properties_keys = list(session.get('properties', {}).keys()) if session else []
            chat_id = query.message.chat_id if query and query.message else None
            message_id = query.message.message_id if query and query.message else None
            if DEBUG_VERBOSE_LOGS:
                logger.info(
                    "BUTTON_CALLBACK_CONTEXT "
                    "user_id=%s data=%s chat_id=%s message_id=%s update_id=%s user_lang=%s "
                    "session_exists=%s model_id=%s waiting_for=%s current_param=%s "
                    "params_keys=%s required=%s properties_keys=%s session_keys=%s",
                    user_id,
                    data,
                    chat_id,
                    message_id,
                    update_id,
                    user_lang,
                    bool(session),
                    session_model_id,
                    session_waiting_for,
                    session_current_param,
                    session_params_keys[:15],
                    session_required[:15],
                    session_properties_keys[:15],
                    session_keys[:15],
                )
            try:
                trace_event(
                    "info",
                    correlation_id,
                    event="TRACE_IN",
                    stage="SESSION_LOAD",
                    update_type="callback",
                    action="CALLBACK",
                    action_path=build_action_path(data),
                    user_id=user_id,
                    chat_id=chat_id,
                    session_exists=bool(session),
                    model_id=session_model_id,
                    waiting_for=session_waiting_for,
                    current_param=session_current_param,
                    params_keys=session_params_keys[:15],
                    required=session_required[:15],
                    param_order=session.get("param_order")[:15] if session and session.get("param_order") else None,
                )
            except Exception as trace_exc:
                logger.warning("TRACE session load failed: %s", trace_exc, exc_info=True)
            try:
                correlation_id = None
                if context and getattr(context, "user_data", None) is not None:
                    if context.user_data.get("correlation_update_id") == update_id:
                        correlation_id = context.user_data.get("correlation_id")
                    if not correlation_id:
                        correlation_id = get_correlation_id(update_id, user_id)
                        context.user_data["correlation_id"] = correlation_id
                        context.user_data["correlation_update_id"] = update_id
                else:
                    correlation_id = get_correlation_id(update_id, user_id)

                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update_id,
                    action="CALLBACK",
                    action_path=build_action_path(data),
                    model_id=session_model_id,
                    gen_type=session.get('gen_type') if session else None,
                    stage="router",
                    waiting_for=session_waiting_for,
                    param=session_current_param,
                    outcome="received",
                    duration_ms=int((time.time() - start_time) * 1000),
                    error_code=None,
                    fix_hint=None,
                )
            except Exception as structured_log_error:
                logger.warning(
                    f"STRUCTURED_LOG error: {structured_log_error}",
                    exc_info=True,
                )
        except Exception as log_error:
            logger.error(f"‚ùå‚ùå‚ùå ERROR in BUTTON_CALLBACK CONTEXT logging: {log_error}", exc_info=True)
            
    except Exception as e:
        logger.error(f"Error in button_callback setup: {e}", exc_info=True)
        # Try to answer anyway if we have query
        if query:
            try:
                await query.answer("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–Ω–æ–ø–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start", show_alert=True)
            except:
                pass
        return ConversationHandler.END
    
    # Wrap all callback handling in try-except for error handling
    try:
        # Initialize common variables that might be used in multiple handlers
        # This prevents UnboundLocalError if variable is assigned in one branch but used in another
        categories = None
        total_models = None
        tutorial_text = None
        help_text = None
        referral_text = None
        history_text = None
        model_info_text = None
        prompt_text = None
        admin_text = None
        settings_text = None
        promocodes_text = None
        broadcast_text = None
        stats_text = None
        
        # Handle claim gift
        if data == "claim_gift":
            if has_claimed_gift(user_id):
                user_lang = get_user_language(user_id)
                await query.answer(t('error_already_claimed', lang=user_lang), show_alert=True)
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            # Show initial spinning message
            await query.answer(t('msg_spinning_wheel', lang=user_lang))
            if user_lang == 'ru':
                spin_message = await query.edit_message_text(
                    "üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üé≤ <b>–ö—Ä—É—Ç–∏–º –∫–æ–ª–µ—Å–æ...</b>\n\n"
                    "‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                    parse_mode='HTML'
                )
            else:
                spin_message = await query.edit_message_text(
                    "üé∞ <b>WHEEL OF FORTUNE</b> üé∞\n\n"
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üé≤ <b>Spinning the wheel...</b>\n\n"
                    "‚è≥ Please wait, determining your prize...",
                    parse_mode='HTML'
                )
            
            # Animate wheel spinning with different sectors
            wheel_sectors = [
                ("üéØ", "üé™", "üé®", "üé≠", "üé™", "üéØ"),
                ("üí∞", "üíé", "üéÅ", "‚≠ê", "üíé", "üí∞"),
                ("üé∞", "üé≤", "üéØ", "üé™", "üé≤", "üé∞"),
                ("üí´", "‚ú®", "üåü", "‚≠ê", "‚ú®", "üí´"),
                ("üéä", "üéâ", "üéà", "üéÅ", "üéâ", "üéä")
            ]
            
            progress_steps = [
                ("üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ", "üîÑ"),
                ("‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°", "‚ö°"),
                ("‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®", "‚ú®"),
                ("üí´", "üí´", "üí´", "üí´", "üí´", "üí´"),
                ("üéØ", "üéØ", "üéØ", "üéØ", "üéØ", "üéØ")
            ]
            
            # Show spinning animation
            for i in range(8):
                await asyncio.sleep(0.25)
                sector_idx = i % len(wheel_sectors)
                progress_idx = min(i, len(progress_steps) - 1)
                
                wheel_display = " ".join(wheel_sectors[sector_idx])
                progress_display = " ".join(progress_steps[progress_idx])
                
                # Progress bar simulation
                progress_percent = min((i + 1) * 12.5, 100)
                progress_bar = "‚ñà" * int(progress_percent / 5) + "‚ñë" * (20 - int(progress_percent / 5))
                
                try:
                    if user_lang == 'ru':
                        await spin_message.edit_text(
                            f"üé∞ <b>–ö–û–õ–ï–°–û –§–û–†–¢–£–ù–´</b> üé∞\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{wheel_display}\n\n"
                            f"<b>–ö—Ä—É—Ç–∏–º...</b> {progress_display}\n\n"
                            f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                            f"‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞—à –≤—ã–∏–≥—Ä—ã—à...",
                            parse_mode='HTML'
                        )
                    else:
                        await spin_message.edit_text(
                            f"üé∞ <b>WHEEL OF FORTUNE</b> üé∞\n\n"
                            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"{wheel_display}\n\n"
                            f"<b>Spinning...</b> {progress_display}\n\n"
                            f"üìä [{progress_bar}] {progress_percent:.0f}%\n\n"
                            f"‚è≥ Please wait, determining your prize...",
                            parse_mode='HTML'
                        )
                except:
                    pass
            
            # Final spin - slow down
            await asyncio.sleep(0.4)
            
            # Get the gift amount
            amount = spin_gift_wheel()
            await add_user_balance_async(user_id, amount)
            set_gift_claimed(user_id)
            
            # Show result with celebration
            if user_lang == 'ru':
                gift_text = (
                    f'üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üé∞ <b>–ö–û–õ–ï–°–û –û–°–¢–ê–ù–û–í–ò–õ–û–°–¨!</b> üé∞\n\n'
                    f'üéÅ <b>–í–∞—à –≤—ã–∏–≥—Ä—ã—à:</b>\n\n'
                    f'üí∞ <b>{format_rub_amount(amount)}</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚úÖ <b>–°—É–º–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞—á–∏—Å–ª–µ–Ω–∞ –Ω–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å!</b>\n\n'
                    f'üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n'
                    f'‚Ä¢ –ù–∞—á–Ω–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å\n'
                    f'‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ª—é–±—É—é –º–æ–¥–µ–ª—å –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞\n'
                    f'‚Ä¢ –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –ø—Ä–µ–º–∏—É–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏!\n\n'
                    f'‚ú® <b>–£–¥–∞—á–∏ –≤ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞!</b>'
                )
            else:
                gift_text = (
                    f'üéâ <b>CONGRATULATIONS!</b> üéâ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üé∞ <b>WHEEL STOPPED!</b> üé∞\n\n'
                    f'üéÅ <b>Your prize:</b>\n\n'
                    f'üí∞ <b>{format_rub_amount(amount)}</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚úÖ <b>Amount automatically added to your balance!</b>\n\n'
                    f'üí° <b>What\'s next:</b>\n'
                    f'‚Ä¢ Start content generation right now\n'
                    f'‚Ä¢ Use any model from the catalog\n'
                    f'‚Ä¢ Enjoy premium features!\n\n'
                    f'‚ú® <b>Good luck creating content!</b>'
                )
            
            keyboard = [
                [InlineKeyboardButton(t('btn_check_balance', lang=user_lang), callback_data="check_balance")],
                [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            await spin_message.edit_text(
                gift_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle admin user mode toggle (MUST be first, before any other checks)
        if data == "admin_user_mode":
            # Toggle user mode for admin
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            session = ensure_session_cached(context, session_store, user_id, update_id)
            
            current_mode = session.get('admin_user_mode', False)
            session['admin_user_mode'] = not current_mode
            
            if not current_mode:
                # Switching to user mode - send new message directly
                user_lang = get_user_language(user_id)
                await query.answer(t('msg_user_mode_enabled', lang=user_lang))
                user = update.effective_user
                categories = get_categories_from_registry()
                total_models = len(get_models_sync())
                
                remaining_free = await get_user_free_generations_remaining(user_id)
                free_info = ""
                if remaining_free > 0:
                    free_info = f"\nüéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π\n"
                
                welcome_text = (
                    f'‚ú® <b>–ü–†–ï–ú–ò–£–ú AI MARKETPLACE</b> ‚ú®\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üëã –ü—Ä–∏–≤–µ—Ç, {user.mention_html()}!\n\n'
                    f'üöÄ <b>–¢–æ–ø–æ–≤—ã–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ –±–µ–∑ VPN</b>\n'
                    f'üì¶ <b>{total_models} –º–æ–¥–µ–ª–µ–π</b> | <b>{len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>{free_info}\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíé <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n'
                    f'‚Ä¢ –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –º–∏—Ä–æ–≤—ã–º AI\n'
                    f'‚Ä¢ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ 2K/4K\n'
                    f'‚Ä¢ –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n\n'
                    f'üéØ <b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ –≤—Å–µ –º–æ–¥–µ–ª–∏</b>'
                )
                
                keyboard = []
                # All models button first
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                
                keyboard.append([])
                for category in categories:
                    models_in_category = get_models_by_category_from_registry(category)
                    emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {category} ({len(models_in_category)})",
                        callback_data=f"category:{category}"
                    )])
                
                keyboard.append([
                    InlineKeyboardButton("üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="topup_balance")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîô –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="admin_back_to_admin")
                ])
                keyboard.append([
                    InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu"),
                    InlineKeyboardButton("üí¨ –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support_contact")
                ])
                
                await query.message.reply_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            else:
                # Switching back to admin mode - send new message with full admin panel
                session = ensure_session_cached(context, session_store, user_id, update_id)
                session['admin_user_mode'] = False
                user_lang = get_user_language(user_id)
                await query.answer(t('msg_returning_to_admin', lang=user_lang))
                user = update.effective_user
                generation_types = get_generation_types()
                total_models = len(get_models_sync())
                
                welcome_text = (
                    f'üëë ‚ú® <b>–ü–ê–ù–ï–õ–¨ –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–ê</b> ‚ú®\n\n'
                    f'–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n'
                    f'üéØ <b>–ü–û–õ–ù–´–ô –ö–û–ù–¢–†–û–õ–¨ –ù–ê–î AI MARKETPLACE</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üìä <b>–°–¢–ê–¢–ò–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´:</b>\n\n'
                    f'‚úÖ <b>{total_models} –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–µ–π</b> –≤ –∞—Ä—Å–µ–Ω–∞–ª–µ\n'
                    f'‚úÖ <b>{len(generation_types)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b> –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n'
                    f'‚úÖ –ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üî• <b>–¢–û–ü–û–í–´–ï –ú–û–î–ï–õ–ò –í –°–ò–°–¢–ï–ú–ï:</b>\n\n'
                    f'üé® <b>Google Imagen 4 Ultra</b> - –§–ª–∞–≥–º–∞–Ω –æ—Ç Google DeepMind\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: 4.63 ‚ÇΩ)\n'
                    f'   ‚≠êÔ∏è –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è\n\n'
                    f'üçå <b>Nano Banana Pro</b> - 4K –æ—Ç Google\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (1K/2K: 6.95 ‚ÇΩ, 4K: 9.27 ‚ÇΩ)\n'
                    f'   üéØ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 2K/4K\n\n'
                    f'üé• <b>Sora 2</b> - –í–∏–¥–µ–æ –æ—Ç OpenAI\n'
                    f'   üí∞ –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: 11.58 ‚ÇΩ) –∑–∞ 10-—Å–µ–∫—É–Ω–¥–Ω–æ–µ –≤–∏–¥–µ–æ\n'
                    f'   üé¨ –ö–∏–Ω–µ–º–∞—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –≤–∏–¥–µ–æ —Å –∞—É–¥–∏–æ\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'‚öôÔ∏è <b>–ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–´–ï –í–û–ó–ú–û–ñ–ù–û–°–¢–ò:</b>\n\n'
                    f'üìà –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏\n'
                    f'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'üéÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏\n'
                    f'üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ OCR —Å–∏—Å—Ç–µ–º—ã\n'
                    f'üíº –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –±–æ—Ç–æ–º\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí´ <b>–ù–ê–ß–ù–ò–¢–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–õ–ò –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï!</b>'
                )
                
                keyboard = []
                # All models button first
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                
                keyboard.append([])
                for category in categories:
                    models_in_category = get_models_by_category_from_registry(category)
                    emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {category} ({len(models_in_category)})",
                        callback_data=f"category:{category}"
                    )])
                
                keyboard.append([
                    InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
                ])
                keyboard.append([
                    InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats"),
                    InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search"),
                    InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")
                ])
                keyboard.append([
                    InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")
                ])
                keyboard.append([
                    InlineKeyboardButton("üë§ –†–µ–∂–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", callback_data="admin_user_mode")
                ])
                keyboard.append([InlineKeyboardButton("üÜò –ü–æ–º–æ—â—å", callback_data="help_menu")])
                
                await query.message.reply_text(
                    welcome_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        if data == "admin_back_to_admin":
            # Return to admin mode - send new message directly
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            session = ensure_session_cached(context, session_store, user_id, update_id)
            session['admin_user_mode'] = False
            await query.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")
            user = update.effective_user
            categories = get_categories_from_registry()
            total_models = len(KIE_MODELS)
            
            welcome_text = (
                f'üëë <b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n'
                f'–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}! üëã\n\n'
                f'üöÄ <b>–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</b>\n\n'
                f'üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n'
                f'‚úÖ <b>{total_models} –º–æ–¥–µ–ª–µ–π</b> –¥–æ—Å—Ç—É–ø–Ω–æ\n'
                f'‚úÖ <b>{len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>\n\n'
                f'‚öôÔ∏è <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã</b>'
            )
            
            keyboard = []
            
            # All models button first
            keyboard.append([
                InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")
            ])
            
            keyboard.append([])
            for category in categories:
                models_in_category = get_models_by_category_from_registry(category)
                emoji = models_in_category[0]["emoji"] if models_in_category else "üì¶"
                keyboard.append([InlineKeyboardButton(
                    f"{emoji} {category} ({len(models_in_category)})",
                    callback_data=f"category:{category}"
                )])
            
            keyboard.append([
                InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats"),
                InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="admin_settings")
            ])
            keyboard.append([
                InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="admin_search"),
                InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add")
            ])
            keyboard.append([
                InlineKeyboardButton("üß™ –¢–µ—Å—Ç OCR", callback_data="admin_test_ocr")
            ])
            keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
            
            await query.message.reply_text(
                welcome_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "back_to_menu":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            correlation_id = ensure_correlation_id(update, context)
            partner_id = (os.getenv("PARTNER_ID") or os.getenv("BOT_INSTANCE_ID") or "default").strip() or "default"
            try:
                session = ensure_session_cached(context, session_store, user_id, update_id)
                for key in ("waiting_for", "current_param", "param_history", "params"):
                    session.pop(key, None)
                _clear_user_task_context(user_id, reason="back_to_menu", allow_mismatch=True)
                await ensure_main_menu(update, context, source="back", correlation_id=correlation_id, prefer_edit=True)
            except Exception as exc:
                logger.error(
                    "BACK_TO_MENU_FAILED handler=back_to_menu user_id=%s partner_id=%s correlation_id=%s error=%s",
                    user_id,
                    partner_id,
                    correlation_id,
                    exc,
                    exc_info=True,
                )
                await _send_menu_error_notice(update, context, correlation_id=correlation_id)
                await _show_minimal_menu(
                    update,
                    context,
                    source="back",
                    correlation_id=correlation_id,
                    prefer_edit=False,
                )
            return ConversationHandler.END
        
    
        if data == "generate_again":
            # Generate again - restore model and show model info, then ask for new prompt
            await query.answer()  # Acknowledge the callback
            
            logger.info(f"Generate again requested by user {user_id}")
            
            if user_id not in saved_generations:
                logger.warning(f"No saved generation data for user {user_id}")
                await query.edit_message_text(
                    "‚ùå <b>–î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                    "–ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —á–µ—Ä–µ–∑ –º–µ–Ω—é.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            saved_data = saved_generations[user_id]
            logger.info(f"Restoring generation data for user {user_id}, model: {saved_data.get('model_id')}")
            
            # Restore session with model info, but clear params to start fresh
            session = ensure_session_cached(context, session_store, user_id, update_id)
            
            model_id = saved_data['model_id']
            model_info = saved_data['model_info']
            
            # Restore model info but clear params - user will enter new prompt
            session.update({
                'model_id': model_id,
                'model_info': model_info,
                'properties': saved_data['properties'].copy(),
                'required': saved_data['required'].copy(),
                'params': {}  # Clear params - start fresh
            })
            
            # Get user balance and calculate available generations (same as select_model)
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            
            # Calculate price for default parameters (minimum price)
            default_params = {}
            if model_id == "nano-banana-pro":
                default_params = {"resolution": "1K"}  # Cheapest option
            elif model_id == "seedream/4.5-text-to-image" or model_id == "seedream/4.5-edit":
                default_params = {"quality": "basic"}  # Basic quality (same price, but for consistency)
            
            min_price = get_from_price_value(model_id)
            price_text = format_price_rub(min_price, is_admin) if min_price is not None else "üí∞ <b>–æ—Ç ‚Äî ‚ÇΩ</b>"
            
            # Calculate how many generations available
            if is_admin:
                available_count = "–ë–µ–∑–ª–∏–º–∏—Ç"
            elif min_price and user_balance >= min_price:
                available_count = int(user_balance / min_price)
            else:
                available_count = 0
            
            # Show model info with price and available generations (improved format)
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –º–æ–¥–µ–ª–∏ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            model_category = model_info.get('category', '')
            gen_type = model_info.get('generation_type', '')

            model_info_text = (
                f"{model_emoji} <b>{model_name}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if model_category:
                model_info_text += f"üìÅ <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {model_category}\n"
            if gen_type:
                gen_type_display = gen_type.replace('_', ' ').replace('-', ' ').title()
                model_info_text += f"üéØ <b>–¢–∏–ø:</b> {gen_type_display}\n"
            
            if model_category or gen_type:
                model_info_text += "\n"
            
            if model_desc:
                model_info_text += f"‚ÑπÔ∏è <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{model_desc}\n\n"
            
            model_info_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            model_info_text += f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {price_text}\n"
            
            if is_admin:
                model_info_text += t('msg_unlimited_available', lang=user_lang) + "\n\n"
            else:
                if available_count > 0:
                    model_info_text += t('msg_available_generations', lang=user_lang, 
                                        count=available_count, 
                                        balance=format_price_rub(user_balance, is_admin)) + "\n\n"
                else:
                    # Not enough balance - show warning
                    model_info_text += t('msg_insufficient_funds', lang=user_lang,
                                        balance=format_price_rub(user_balance, is_admin),
                                        required=price_text)
                    
                    keyboard = _build_topup_menu_keyboard(user_lang)
                    
                    await query.edit_message_text(
                        model_info_text,
                        reply_markup=keyboard,
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
            
            # Check balance before starting generation
            if not is_admin and user_balance < min_price:
                user_lang = get_user_language(user_id)
                keyboard = _build_topup_menu_keyboard(user_lang)
                
                needed = min_price - user_balance
                needed_str = format_rub_amount(needed)
                remaining_free = await get_user_free_generations_remaining(user_id)
                
                if user_lang == 'ru':
                    insufficient_msg = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {format_price_rub(user_balance, is_admin)}\n"
                        f"üíµ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º:</b> {price_text}\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                        f"‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π ({remaining_free} –¥–æ—Å—Ç—É–ø–Ω–æ)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å—ã\n\n"
                        f"üîÑ –ü–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–Ω–æ–≤–∞."
                    )
                else:
                    insufficient_msg = (
                        f"‚ùå <b>Insufficient Funds for Generation</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí≥ <b>Your balance:</b> {format_price_rub(user_balance, is_admin)}\n"
                        f"üíµ <b>Minimum required:</b> {price_text}\n"
                        f"‚ùå <b>Need:</b> {needed_str}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>What to do:</b>\n"
                        f"‚Ä¢ Top up balance via button below\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ Use free models generations ({remaining_free} available)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ Invite a friend and get bonuses\n\n"
                        f"üîÑ After topping up, try generation again."
                    )
                
                await query.edit_message_text(
                    _append_free_counter_text(insufficient_msg, free_counter_line),
                    reply_markup=keyboard,
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get input parameters from model info
            input_params = model_info.get('input_params', {})
            from app.kie_catalog import get_model
            model_spec = get_model(model_id) if model_id else None
            forced_media_required: List[str] = []
            if model_spec:
                input_params, required_params, forced_media_required = _apply_media_required_overrides(
                    model_spec,
                    input_params,
                )
            else:
                required_params = [p for p, info in input_params.items() if info.get('required', False)]
            input_params = _apply_unified_param_defaults(
                input_params,
                model_spec=model_spec,
                session_gen_type=session.get("gen_type") or model_info.get("generation_type"),
            )
            
            if not input_params:
                # If no params defined, ask for simple text input
                await query.edit_message_text(
                    f"{model_info_text}"
                    f"–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
                    parse_mode='HTML'
                )
                session['params'] = {}
                session['waiting_for'] = 'text'
                return INPUTTING_PARAMS
            
            # Store session data
            prefill_params = session.pop("prefill_params", {}) if isinstance(session, dict) else {}
            session['params'] = dict(prefill_params or {})
            session['properties'] = input_params
            session['required'] = required_params
            session['required_forced_media'] = forced_media_required
            session['skipped_params'] = set()
            session['current_param'] = None
            if model_spec:
                session['model_type'] = model_spec.model_type or model_spec.model_mode
                session['model_mode'] = model_spec.model_mode
            # NOTE: model_id and model_info are already stored above at lines 8449-8450
            
            primary_input = _determine_primary_input(model_info, input_params)
            logger.info(
                "üî•üî•üî• SELECT_MODEL CHECK: model_id=%s primary_input=%s input_params_keys=%s user_id=%s",
                model_id,
                primary_input,
                list(input_params.keys()),
                user_id,
            )

            if primary_input and primary_input["type"] == "image":
                logger.debug("üî•üî•üî• SELECT_MODEL: Model requires image first! user_id=%s", user_id)
                image_param_name = primary_input["param"]
                user_lang = get_user_language(user_id)
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                if user_lang == 'en':
                    step_text = "üì∑ <b>Step 1: Upload image</b>\n\n"
                    if model_id == "recraft/remove-background":
                        step_text += "Send a photo to remove the background.\n\n"
                    elif model_id == "recraft/crisp-upscale":
                        step_text += "Send a photo to enhance quality.\n\n"
                    elif model_id == "ideogram/v3-reframe":
                        step_text += "Send a photo to reframe and change aspect ratio.\n\n"
                    elif model_id == "topaz/image-upscale":
                        step_text += "Send a photo to upscale and enhance resolution.\n\n"
                    else:
                        step_text += "Send a photo to use as reference or for transformation.\n\n"
                    if 'prompt' in input_params:
                        step_text += "üí° <i>After uploading the image, you can enter a prompt</i>"
                else:
                    step_text = (
                        "üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏.\n"
                        "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã: PNG, JPG, JPEG, WEBP\n"
                        "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB"
                    )
                    if 'prompt' in input_params:
                        step_text += "\n\n‚úÖ <b>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:</b> –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç"

                free_counter_line = await _resolve_free_counter_line(
                    user_id,
                    user_lang,
                    correlation_id,
                    action_path=f"param_prompt:{image_param_name}",
                    sku_id=session.get("sku_id"),
                )
                step_text = _append_free_counter_text(step_text, free_counter_line)
                await query.edit_message_text(
                    f"{model_info_text}\n\n{step_text}",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['current_param'] = image_param_name
                session['waiting_for'] = image_param_name
                if image_param_name not in session:
                    session[image_param_name] = []
                await query.answer()
                logger.info(
                    "üî•üî•üî• SELECT_MODEL: Image input setup complete! model_id=%s user_id=%s waiting_for=%s",
                    model_id,
                    user_id,
                    image_param_name,
                )
                elapsed = time.time() - start_time
                logger.debug("üî•üî•üî• SELECT_MODEL: Total time=%0.3fs user_id=%s", elapsed, user_id)
                return INPUTTING_PARAMS

            if primary_input and primary_input["type"] == "audio":
                logger.debug("üî•üî•üî• SELECT_MODEL: Model requires audio first! user_id=%s", user_id)
                audio_param_name = primary_input["param"]
                user_lang = get_user_language(user_id)
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                if user_lang == 'en':
                    audio_text = (
                        f"{model_info_text}\n\n"
                        f"üé§ <b>Step 1: Upload audio</b>\n\n"
                        f"Send an audio file (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                        f"Maximum size: 200 MB"
                    )
                else:
                    audio_text = (
                        f"{model_info_text}\n\n"
                        f"üé§ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ</b>\n\n"
                        f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                        f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB"
                    )
                price_line = _build_current_price_line(
                    session,
                    user_lang=user_lang,
                    model_id=model_id,
                    mode_index=_resolve_mode_index(model_id, session.get("params", {}), user_id),
                    gen_type=session.get("gen_type"),
                    params=session.get("params", {}),
                    correlation_id=correlation_id,
                    update_id=update_id,
                    action_path=f"param_prompt:{audio_param_name}",
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    is_admin=get_is_admin(user_id),
                )
                audio_text += f"\n\n{price_line}"
                free_counter_line = await _resolve_free_counter_line(
                    user_id,
                    user_lang,
                    correlation_id,
                    action_path=f"param_prompt:{audio_param_name}",
                    sku_id=session.get("sku_id"),
                )
                audio_text = _append_free_counter_text(audio_text, free_counter_line)
                await query.edit_message_text(
                    audio_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['current_param'] = audio_param_name
                session['waiting_for'] = audio_param_name
                await query.answer()
                return INPUTTING_PARAMS
            
            # Special case: sora-2-pro-image-to-video starts with image_urls first
            if model_id == "sora-2-pro-image-to-video" and 'image_urls' in input_params and input_params['image_urls'].get('required', False):
                # Start with image_urls first for sora-2-pro-image-to-video
                has_image_input = True
                image_param_name = 'image_urls'
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                image_text = (
                    f"{model_info_text}\n\n"
                    f"üì∑ <b>–®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                    f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫–∞–∫ –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –≤–∏–¥–µ–æ.\n\n"
                    f"üí° <i>–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–ø—Ç</i>"
                )
                price_line = _build_current_price_line(
                    session,
                    user_lang=user_lang,
                    model_id=model_id,
                    mode_index=_resolve_mode_index(model_id, session.get("params", {}), user_id),
                    gen_type=session.get("gen_type"),
                    params=session.get("params", {}),
                    correlation_id=correlation_id,
                    update_id=update_id,
                    action_path=f"param_prompt:{image_param_name}",
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    is_admin=get_is_admin(user_id),
                )
                image_text += f"\n\n{price_line}"
                free_counter_line = await _resolve_free_counter_line(
                    user_id,
                    user_lang,
                    correlation_id,
                    action_path=f"param_prompt:{image_param_name}",
                    sku_id=session.get("sku_id"),
                )
                image_text = _append_free_counter_text(image_text, free_counter_line)
                await query.edit_message_text(
                    image_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['current_param'] = 'image_urls'
                session['waiting_for'] = 'image_urls'
                if 'image_urls' not in session:
                    session['image_urls'] = []  # Initialize as array
                await query.answer()
                return INPUTTING_PARAMS
            
            # Start with prompt parameter first (default behavior)
            if 'prompt' in input_params:
                # Check if model supports image input (image_input or image_urls)
                # BUT: z-image does NOT support image input (text-to-image only)
                # AND: text-to-video models do NOT require image input (text-to-video only)
                is_text_to_video = "text-to-video" in model_id.lower()
                has_image_input = (model_id != "z-image" and 
                                 not is_text_to_video and
                                 ('image_input' in input_params or 'image_urls' in input_params))
                
                prompt_text = (
                    f"{model_info_text}"
                )
                
                # Determine if this is a video or audio model
                is_video = is_video_model(model_id)
                is_audio = is_audio_model(model_id)
                
                if has_image_input:
                    ref_hint = "—Ä–µ—Ñ-–∫–∞—Ä—Ç–∏–Ω–∫—É" if session.get("image_ref_prompt") else "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
                    if is_video:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å.\n\n"
                            f"üí° <i>–ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å {ref_hint} (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</i>"
                        )
                    else:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å.\n\n"
                            f"üí° <i>–ü–æ—Å–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–ø—Ç–∞ –≤—ã —Å–º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å {ref_hint} (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</i>"
                        )
                else:
                    if is_video:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å:"
                        )
                    elif is_audio:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:"
                        )
                    else:
                        prompt_text += (
                            f"üìù <b>–®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç</b>\n\n"
                            f"–û–ø–∏—à–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å:"
                        )
                price_line = _build_current_price_line(
                    session,
                    user_lang=user_lang,
                    model_id=model_id,
                    mode_index=_resolve_mode_index(model_id, session.get("params", {}), user_id),
                    gen_type=session.get("gen_type"),
                    params=session.get("params", {}),
                    correlation_id=correlation_id,
                    update_id=update_id,
                    action_path="param_prompt:prompt",
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    is_admin=get_is_admin(user_id),
                )
                prompt_text += f"\n\n{price_line}"
                
                # Add keyboard with "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é" and "–û—Ç–º–µ–Ω–∞" buttons
                free_counter_line = await _resolve_free_counter_line(
                    user_id,
                    user_lang,
                    correlation_id,
                    action_path="param_prompt:prompt",
                    sku_id=session.get("sku_id"),
                )
                prompt_text = _append_free_counter_text(prompt_text, free_counter_line)
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                await query.edit_message_text(
                    prompt_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                session['current_param'] = 'prompt'
                session['waiting_for'] = 'prompt'
                session['has_image_input'] = has_image_input
            else:
                # If no prompt, start with first required parameter
                await start_next_parameter(update, context, user_id)
            
            return INPUTTING_PARAMS
        
        if data.startswith("set_language:"):
            # Handle language selection
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(query.from_user.id)
                await query.answer(t('error_invalid_format', lang=user_lang), show_alert=True)
                return ConversationHandler.END
            lang = parts[1]
            if lang in ['ru', 'en']:
                set_user_language(user_id, lang)
                await query.answer(t('language_set', lang))
                # Show main menu after language selection
                await start(update, context)
                return ConversationHandler.END
            else:
                await query.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —è–∑—ã–∫ / Invalid language")
            return ConversationHandler.END
        
        if data.startswith("cancel:"):
            user_lang = get_user_language(user_id)
            now_ms = _now_ms()
            _set_user_ui_action(user_id, "cancel_click", now_ms)
            session = get_session_cached(context, session_store, user_id, update_id, default={})
            if isinstance(session, dict):
                session["last_ui_action"] = "cancel_click"
                session["last_ui_ts_ms"] = now_ms
            job_id = _parse_cancel_callback(data)
            await _request_job_cancel(
                update=update,
                context=context,
                job_id=job_id,
                user_id=user_id,
                user_lang=user_lang,
                callback_data=data,
                query=query,
                correlation_id=correlation_id,
                state_source="callback",
            )
            return ConversationHandler.END

        if data == "cancel":
            user_lang = get_user_language(user_id)
            session = get_session_cached(context, session_store, user_id, update_id, default={})
            active_job_id = session.get("job_id") if isinstance(session, dict) else None
            active_state = session.get("job_state") if isinstance(session, dict) else None
            if active_job_id and active_state in ACTIVE_JOB_STATES_ACTIVE:
                increment_cancel_metric("cancel_without_job_total")
                _log_cancel_update(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query and query.message else None,
                    message_id=query.message.message_id if query and query.message else None,
                    callback_query_id=query.id if query else None,
                    callback_data=data,
                    job_id=active_job_id,
                    state_before=active_state,
                    state_after="ignored",
                    action="CANCEL_MISSING_JOB_ID",
                )
                try:
                    await query.answer()
                except Exception:
                    pass
                return ConversationHandler.END
            await query.answer(t('btn_cancel', lang=user_lang).replace('‚ùå ', ''))
            session_store.clear(user_id)
            try:
                await query.edit_message_text(
                    t('msg_operation_cancelled', lang=user_lang),
                    parse_mode="HTML",
                )
            except Exception as e:
                logger.error(f"Error editing message on cancel: {e}")
                try:
                    await query.message.reply_text(
                        t('msg_operation_cancelled', lang=user_lang),
                        parse_mode="HTML",
                    )
                except:
                    pass
            await ensure_main_menu(update, context, source="cancel", prefer_edit=False)
            return ConversationHandler.END
        
        if data.startswith("retry_generate:"):
            # Retry generation with same parameters
            await query.answer("–ü–æ–≤—Ç–æ—Ä—è—é –ø–æ–ø—ã—Ç–∫—É...")
            
            session = get_session_cached(context, session_store, user_id, update_id, default=None)
            if not session:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            # Show confirmation again with same parameters
            model_name = session.get('model_info', {}).get('name', 'Unknown')
            params = session.get('params', {})
            params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
            
            user_lang = get_user_language(user_id)
            keyboard = [
                [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            
            await query.edit_message_text(
                f"üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞:</b>\n\n"
                f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return CONFIRMING_GENERATION

        if data.startswith("open_result:"):
            task_id = data.split(":", 1)[1].strip() if ":" in data else ""
            await query.answer("–ü—Ä–æ–≤–µ—Ä—è—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç..." if user_lang == "ru" else "Checking result...")
            if not task_id:
                await query.edit_message_text(
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å task_id. –û—Ç–∫—Ä–æ–π—Ç–µ —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ –º–µ–Ω—é."
                    if user_lang == "ru"
                    else "‚ùå Could not determine task_id. Open status from the menu.",
                    parse_mode="HTML",
                    reply_markup=build_back_to_menu_keyboard(user_lang),
                )
                return ConversationHandler.END

            from app.delivery.reconciler import FAILED_STATES, SUCCESS_STATES, deliver_job_result
            from app.integrations.kie_stub import get_kie_client_or_stub
            from app.storage import get_storage

            storage_instance = get_storage()
            job = await _find_job_by_task_id(storage_instance, task_id)
            if not job:
                await query.edit_message_text(
                    "‚ùå –ù–µ –Ω–∞—à—ë–ª –∑–∞–¥–∞—á—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å –≤ –º–µ–Ω—é ¬´–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏¬ª."
                    if user_lang == "ru"
                    else "‚ùå Task not found. Check status in ‚ÄúMy generations‚Äù.",
                    parse_mode="HTML",
                    reply_markup=build_back_to_menu_keyboard(user_lang),
                )
                return ConversationHandler.END
            job_user_id = job.get("user_id")
            if job_user_id is not None and job_user_id != user_id and not get_is_admin(user_id):
                await query.edit_message_text(
                    "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞–¥–∞—á–µ."
                    if user_lang == "ru"
                    else "‚ùå You don't have access to this task.",
                    parse_mode="HTML",
                    reply_markup=build_back_to_menu_keyboard(user_lang),
                )
                return ConversationHandler.END

            job_id_value = job.get("job_id") or task_id
            job_id_for_keyboard = job.get("job_id")
            status_record: Dict[str, Any] = {}
            provider_state = "unknown"
            try:
                status_record = await get_kie_client_or_stub().get_task_status(task_id)
                provider_state = (status_record.get("state") or "unknown").lower()
            except Exception as exc:
                logger.warning("open_result_status_fetch_failed task_id=%s error=%s", task_id, exc)
            status_record["taskId"] = task_id
            task_keyboard = _build_task_already_started_keyboard(
                user_lang,
                task_id=task_id,
                job_id=job_id_for_keyboard,
            )

            if provider_state in SUCCESS_STATES:
                delivered = await deliver_job_result(
                    context.bot,
                    storage_instance,
                    job=job,
                    status_record=status_record,
                    notify_user=True,
                    source="open_result",
                    get_user_language=get_user_language,
                )
                if delivered:
                    _clear_user_task_context(
                        user_id,
                        reason="terminal_success_open_result",
                        task_id=task_id,
                        allow_mismatch=True,
                    )
                await query.edit_message_text(
                    (
                        "‚úÖ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤</b>\n\n"
                        "–Ø –æ—Ç–ø—Ä–∞–≤–∏–ª –µ–≥–æ –≤—ã—à–µ –≤ —á–∞—Ç–µ."
                        if user_lang == "ru"
                        else "‚úÖ <b>Result is ready</b>\n\nI've sent it above in the chat."
                    ),
                    parse_mode="HTML",
                    reply_markup=task_keyboard,
                )
                return ConversationHandler.END

            if provider_state in FAILED_STATES:
                await storage_instance.update_job_status(
                    job_id_value,
                    "failed",
                    error_message=status_record.get("failMsg"),
                    error_code=status_record.get("failCode") or "KIE_FAIL_STATE",
                )
                _clear_user_task_context(
                    user_id,
                    reason="terminal_fail_open_result",
                    task_id=task_id,
                    allow_mismatch=True,
                )
                await query.edit_message_text(
                    (
                        "‚ùå <b>–ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π</b>\n\n"
                        "–ú–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é."
                        if user_lang == "ru"
                        else "‚ùå <b>The task failed</b>\n\nYou can start a new generation."
                    ),
                    parse_mode="HTML",
                    reply_markup=build_back_to_menu_keyboard(user_lang),
                )
                return ConversationHandler.END

            wait_text = (
                "‚è≥ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –µ—â—ë –≥–æ—Ç–æ–≤–∏—Ç—Å—è</b>\n\n"
                f"–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: <b>{provider_state}</b>\n"
                "–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ–∑–∂–µ –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–¥–∞—á—É."
                if user_lang == "ru"
                else (
                    "‚è≥ <b>The result is still processing</b>\n\n"
                    f"Current status: <b>{provider_state}</b>\n"
                    "You can check again later or cancel the task."
                )
            )
            await query.edit_message_text(wait_text, parse_mode="HTML", reply_markup=task_keyboard)
            return ConversationHandler.END

        if data.startswith("retry_delivery:"):
            task_id = data.split(":", 1)[1] if ":" in data else ""
            await query.answer("–ü–æ–≤—Ç–æ—Ä—è—é –¥–æ—Å—Ç–∞–≤–∫—É...")

            async with pending_deliveries_lock:
                payload = pending_deliveries.get((user_id, task_id))

            if not payload:
                await query.edit_message_text(
                    "‚ùå –ù–µ –Ω–∞—à—ë–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –¥–æ—Å—Ç–∞–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ –º–µ–Ω—é.",
                    parse_mode="HTML",
                )
                return ConversationHandler.END

            from app.generations.telegram_sender import send_result_file
            from app.storage import get_storage
            storage_instance = get_storage()

            delivered = False
            try:
                delivered = bool(
                    await send_result_file(
                        context.bot,
                        payload["chat_id"],
                        payload["media_type"],
                        payload["urls"],
                        payload.get("text"),
                        model_id=payload.get("model_id"),
                        gen_type=payload.get("gen_type"),
                        correlation_id=payload.get("correlation_id"),
                        request_id=payload.get("request_id"),
                        prompt_hash=payload.get("prompt_hash"),
                        params=payload.get("params"),
                        model_label=payload.get("model_label"),
                        task_id=payload.get("task_id"),
                        job_id=payload.get("job_id"),
                    )
                )
            except Exception as exc:
                log_structured_event(
                    correlation_id=payload.get("correlation_id"),
                    user_id=user_id,
                    chat_id=payload.get("chat_id"),
                    action="DELIVERY_FAIL",
                    action_path="retry_delivery",
                    model_id=payload.get("model_id"),
                    stage="TG_DELIVER",
                    outcome="failed",
                    error_code="TG_DELIVER_EXCEPTION",
                    fix_hint=str(exc),
                    param={"task_id": task_id},
                )

            if delivered:
                async with pending_deliveries_lock:
                    pending_deliveries.pop((user_id, task_id), None)
                try:
                    await storage_instance.update_json_file(
                        "delivery_records.json",
                        lambda data: {
                            **data,
                            f"{user_id}:{task_id}": {
                                **data.get(f"{user_id}:{task_id}", {}),
                                "status": "delivered",
                                "updated_at": datetime.now().isoformat(),
                                "delivered_at": datetime.now().isoformat(),
                            },
                        },
                    )
                except Exception as exc:
                    logger.warning("Failed to persist delivery record: %s", exc)
                log_task_lifecycle(
                    state="delivered",
                    user_id=user_id,
                    task_id=task_id,
                    job_id=payload.get("job_id"),
                    model_id=payload.get("model_id"),
                    correlation_id=payload.get("correlation_id"),
                    source="retry_delivery",
                )
                dry_run = is_dry_run() or not allow_real_generation()
                if not dry_run:
                    await _commit_post_delivery_charge(
                        session=payload.get("session", {}),
                        user_id=user_id,
                        chat_id=payload.get("chat_id"),
                        task_id=payload.get("task_id"),
                        sku_id=payload.get("sku_id", ""),
                        price=float(payload.get("price", 0)),
                        is_free=bool(payload.get("is_free")),
                        is_admin_user=bool(payload.get("is_admin_user")),
                        correlation_id=payload.get("correlation_id"),
                        model_id=payload.get("model_id"),
                    )
                await query.edit_message_text(
                    "‚úÖ <b>–î–æ—Å—Ç–∞–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.",
                    reply_markup=InlineKeyboardMarkup(
                        [[InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]]
                    ),
                    parse_mode="HTML",
                )
                return ConversationHandler.END

            retry_keyboard = InlineKeyboardMarkup(
                [
                    [InlineKeyboardButton("üîÅ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É", callback_data=f"retry_delivery:{task_id}")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")],
                ]
            )
            await query.edit_message_text(
                "‚ö†Ô∏è <b>–î–æ—Å—Ç–∞–≤–∫–∞ —Å–Ω–æ–≤–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å</b>\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ —á—É—Ç—å –ø–æ–∑–∂–µ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
                reply_markup=retry_keyboard,
                parse_mode="HTML",
            )
            return ConversationHandler.END
        
        # Handle category selection (can be called from main menu)
        if data.startswith("gen_type:"):
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            reset_session_context(
                user_id,
                reason="gen_type",
                clear_gen_type=False,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            
            # User selected a generation type
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                try:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                except:
                    try:
                        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                    except:
                        pass
                return ConversationHandler.END
            gen_type = parts[1]
            session = ensure_session_cached(context, session_store, user_id, update_id)
            session["active_gen_type"] = gen_type
            session["gen_type"] = gen_type
            set_session_context(
                user_id,
                to_context=UI_CONTEXT_MODEL_MENU,
                reason="gen_type",
                active_gen_type=gen_type,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            user_lang = get_user_language(user_id)
            loading_text = (
                "‚è≥ <b>–ó–∞–≥—Ä—É–∂–∞—é –º–µ–Ω—é...</b>\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥."
                if user_lang == "ru"
                else "‚è≥ <b>Loading menu...</b>\n\nPlease wait a moment."
            )
            await _safe_edit_or_reply(query, loading_text, parse_mode="HTML")
            _create_background_task(
                _render_gen_type_menu(
                    query=query,
                    user_id=user_id,
                    gen_type=gen_type,
                    correlation_id=correlation_id,
                    update_id=update_id,
                ),
                action="render_gen_type_menu",
            )
            return SELECTING_MODEL
        
        if data.startswith("category:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                try:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                except:
                    try:
                        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                    except:
                        pass
                return ConversationHandler.END
            category = parts[1]
            models = get_models_by_category_from_registry(category)
            
            if not models:
                try:
                    await query.edit_message_text(f"‚ùå –í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category} –Ω–µ—Ç –º–æ–¥–µ–ª–µ–π.")
                except:
                    try:
                        await query.message.reply_text(f"‚ùå –í –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ {category} –Ω–µ—Ç –º–æ–¥–µ–ª–µ–π.")
                    except:
                        pass
                return ConversationHandler.END
            
            keyboard = []
            for model in models:
                model_name = model.get('name', model.get('id', 'Unknown'))
                model_emoji = model.get('emoji', 'ü§ñ')
                model_id = model.get('id')
                button_text = f"{model_emoji} {model_name}"
                if len(button_text.encode("utf-8")) > 60:
                    truncated = model_name[:40].rstrip()
                    button_text = f"{model_emoji} {truncated}..."
                
                # Ensure callback_data is not too long (Telegram limit: 64 bytes)
                callback_data = f"select_model:{model_id}"
                if len(callback_data.encode('utf-8')) > 64:
                    logger.error(f"Callback data too long for model {model_id}: {len(callback_data.encode('utf-8'))} bytes")
                    callback_data = f"sel:{model_id[:50]}"
                
                keyboard.append([InlineKeyboardButton(
                    button_text,
                    callback_data=callback_data
                )])
            user_lang = get_user_language(query.from_user.id)
            keyboard.append([InlineKeyboardButton(t('btn_back_to_categories', lang=user_lang), callback_data="show_models")])
            keyboard.append([InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")])
            
            # Premium formatted header
            category_emoji = {
                "–í–∏–¥–µ–æ": "üé¨",
                "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è": "üñºÔ∏è",
                "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ": "‚úèÔ∏è"
            }.get(category, "üìÅ")
            
            models_text = (
                f"‚ú® <b>–ü–†–ï–ú–ò–£–ú –ö–ê–¢–ê–õ–û–ì</b> ‚ú®\n\n"
                f"{category_emoji} <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}</b>\n"
                f"üì¶ <b>–î–æ—Å—Ç—É–ø–Ω–æ –º–æ–¥–µ–ª–µ–π:</b> {len(models)}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí° <i>–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ</i>\n"
                f"<i>–ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—Å—è –ø—Ä–∏ –≤—ã–±–æ—Ä–µ</i>"
            )
            
            await query.edit_message_text(
                models_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_MODEL
        
        if data == "free_tools":
            # Answer callback immediately
            try:
                await query.answer()
            except Exception as e:
                logger.error(f"Error answering callback for free_tools: {e}")
                pass
            reset_session_context(
                user_id,
                reason="free_tools",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            set_session_context(
                user_id,
                to_context=UI_CONTEXT_FREE_TOOLS_MENU,
                reason="free_tools",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            logger.info(f"User {user_id} clicked 'free_tools' button")
            
            # Get free tools from pricing SSOT (fixed order)
            free_sku_ids = get_free_tools_model_ids()
            from app.pricing.ssot_catalog import (
                get_sku_by_id,
            )
            models_map = {model.get('id'): model for model in get_models_sync()}
            unique_sku_ids = []
            seen_sku_ids = set()
            for sku_id in free_sku_ids:
                if sku_id in seen_sku_ids:
                    continue
                seen_sku_ids.add(sku_id)
                unique_sku_ids.append(sku_id)
            free_skus = [get_sku_by_id(sku_id) for sku_id in unique_sku_ids]
            free_skus = [sku for sku in free_skus if sku and sku.model_id in models_map]

            if not free_skus:
                user_lang = get_user_language(user_id)
                keyboard = [[InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]]
                if user_lang == 'ru':
                    await query.edit_message_text(
                        "‚ÑπÔ∏è <b>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö SKU</b>\n\n"
                        "–í –ø—Ä–∞–π—Å-SSOT –ø–æ–∫–∞ –Ω–µ—Ç –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.\n\n"
                        "–ü–æ–∫–∞ –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞.",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                else:
                    await query.edit_message_text(
                        "‚ÑπÔ∏è <b>No free SKUs available</b>\n\n"
                        "Pricing SSOT does not include free variants yet.\n\n"
                        "You can pick a model from the catalog.",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            free_counter_line = ""
            try:
                free_counter_line = await _await_with_timeout(
                    get_free_counter_line(
                        user_id,
                        user_lang=user_lang,
                        correlation_id=correlation_id,
                        action_path="free_tools_menu",
                        sku_id=free_sku_ids[0] if free_sku_ids else None,
                    ),
                    timeout=MAIN_MENU_DEP_TIMEOUT_SECONDS,
                    label="free_tools_counter",
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update_id,
                    default="",
                )
            except Exception as exc:
                logger.warning("Failed to resolve free counter line: %s", exc)
            if free_counter_line:
                if user_lang == "en":
                    free_counter_line = f"{free_counter_line}\nüîÑ Limit refreshes once per day."
                else:
                    free_counter_line = f"{free_counter_line}\nüîÑ –õ–∏–º–∏—Ç –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —Ä–∞–∑ –≤ –¥–µ–Ω—å."
            if user_lang == 'ru':
                free_tools_text = (
                    f"üÜì <b>–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–´</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>–í—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã!</b>\n\n"
                    f"ü§ñ <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã:</b>\n\n"
                    f"üí° <b>–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –Ω–∏–∂–µ</b>"
                )
            else:
                free_tools_text = (
                    f"üÜì <b>FAST TOOLS</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>All tools in this section are completely free!</b>\n\n"
                    f"ü§ñ <b>Available tools:</b>\n\n"
                    f"üí° <b>Select a tool below</b>"
                )
            free_tools_text = _append_free_counter_text(free_tools_text, free_counter_line)
            keyboard_markup, unique_buttons = _build_free_tools_keyboard(
                free_skus=free_skus,
                models_map=models_map,
                user_lang=user_lang,
            )
            if unique_buttons:
                if user_lang == "en":
                    free_tools_text = free_tools_text.replace(
                        "<b>Available tools:</b>",
                        f"<b>Available tools ({unique_buttons}):</b>",
                    )
                else:
                    free_tools_text = free_tools_text.replace(
                        "<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã:</b>",
                        f"<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ({unique_buttons}):</b>",
                    )
            if unique_buttons < len(free_skus):
                logger.warning(
                    "FREE_TOOLS_KEYBOARD_DEDUPED user_id=%s removed=%s",
                    user_id,
                    len(free_skus) - unique_buttons,
                )
            
            try:
                await query.edit_message_text(
                    free_tools_text,
                    reply_markup=keyboard_markup,
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in free_tools: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        free_tools_text,
                        reply_markup=keyboard_markup,
                        parse_mode='HTML'
                    )
                except Exception as e2:
                    logger.error(f"Error sending new message in free_tools: {e2}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
            
            # Return SELECTING_MODEL state so that select_model: buttons work
            return SELECTING_MODEL
        
        if data == "show_models" or data == "all_models":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except Exception as e:
                logger.error(f"Error answering callback for show_models/all_models: {e}")
                pass
            
            logger.info(f"User {user_id} clicked 'show_models' or 'all_models' button (data: {data})")
            reset_session_context(
                user_id,
                reason="show_models",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            set_session_context(
                user_id,
                to_context=UI_CONTEXT_GEN_TYPE_MENU,
                reason="show_models",
                clear_gen_type=True,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            
            # Show generation types instead of all models with marketing text
            generation_types = get_generation_types()
            visible_models_by_type = {
                gen_type: len(get_visible_models_by_generation_type(gen_type))
                for gen_type in generation_types
            }
            visible_generation_types = [
                gen_type for gen_type, count in visible_models_by_type.items() if count > 0
            ]
            remaining_free = await get_user_free_generations_remaining(user_id)
            user_lang = get_user_language(user_id)
            free_counter_line = ""
            try:
                free_counter_line = await _await_with_timeout(
                    get_free_counter_line(
                        user_id,
                        user_lang=user_lang,
                        correlation_id=correlation_id,
                        action_path="models_menu",
                    ),
                    timeout=MAIN_MENU_DEP_TIMEOUT_SECONDS,
                    label="models_menu_counter",
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update_id,
                    default="",
                )
            except Exception as exc:
                logger.warning("Failed to resolve free counter line: %s", exc)
            
            models_text = (
                f"ü§ñ <b>–í–´–ë–ï–†–ò–¢–ï –ù–ï–ô–†–û–°–ï–¢–¨</b> ü§ñ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí° <b>–ö–ê–ö –≠–¢–û –†–ê–ë–û–¢–ê–ï–¢:</b>\n"
                f"1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (—Ç–µ–∫—Å—Ç‚Üí—Ñ–æ—Ç–æ, —Ñ–æ—Ç–æ‚Üí–≤–∏–¥–µ–æ –∏ —Ç.–¥.)\n"
                f"2Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å –∏–∑ —Å–ø–∏—Å–∫–∞\n"
                f"3Ô∏è‚É£ –°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ–Ω—Ç–µ–Ω—Ç! üöÄ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if remaining_free > 0:
                models_text += (
                    f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–û:</b> {remaining_free} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π –¥–æ—Å—Ç—É–ø–Ω–æ!\n\n"
                )
            
            visible_models_count = len(_get_visible_model_ids())
            models_text += (
                f"üì¶ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {len(visible_generation_types)} —Ç–∏–ø–æ–≤ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n"
                f"ü§ñ <b>–ú–æ–¥–µ–ª–µ–π:</b> {visible_models_count} —Ç–æ–ø–æ–≤—ã—Ö –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π"
            )
            models_text = _append_free_counter_text(models_text, free_counter_line)
            
            keyboard = []
            
            if user_lang == 'ru':
                button_text = f"üÜì FAST TOOLS ({remaining_free}/{FREE_GENERATIONS_PER_DAY})"
            else:
                button_text = f"üÜì FAST TOOLS ({remaining_free}/{FREE_GENERATIONS_PER_DAY})"
            keyboard.append([
                InlineKeyboardButton(button_text, callback_data="free_tools")
            ])
            
            keyboard.append([])  # Empty row
            
            # Generation types buttons (2 per row for compact display)
            # Find text-to-image type and add it after free generation button
            text_to_image_type = None
            gen_type_rows = []
            gen_type_index = 0  # Separate index for non-text-to-image types
            
            for gen_type in generation_types:
                gen_info = get_generation_type_info(gen_type)
                models_count = visible_models_by_type.get(gen_type, 0)
                
                # Skip if no models in this type
                if models_count == 0:
                    logger.debug("No models found for generation type: %s", gen_type)
                    continue
                
                # Identify text-to-image type (will be added separately)
                if gen_type == 'text-to-image':
                    text_to_image_type = gen_type
                    continue
                
                # Get translated name for generation type
                gen_type_key = f'gen_type_{gen_type.replace("-", "_")}'
                gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', gen_type))
                button_text = f"{gen_type_name} ({models_count})"
                
                # Add buttons in pairs (2 per row)
                if gen_type_index % 2 == 0:
                    gen_type_rows.append([InlineKeyboardButton(
                        button_text,
                        callback_data=f"gen_type:{gen_type}"
                    )])
                else:
                    if gen_type_rows:
                        gen_type_rows[-1].append(InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        ))
                    else:
                        gen_type_rows.append([InlineKeyboardButton(
                            button_text,
                            callback_data=f"gen_type:{gen_type}"
                        )])
                
                gen_type_index += 1
            
            # Add text-to-image button after free generation (if it exists and has models)
            if text_to_image_type:
                gen_info = get_generation_type_info(text_to_image_type)
                models_count = visible_models_by_type.get(text_to_image_type, 0)
                if models_count > 0:
                    gen_type_key = f'gen_type_{text_to_image_type.replace("-", "_")}'
                    gen_type_name = t(gen_type_key, lang=user_lang, default=gen_info.get('name', text_to_image_type))
                    button_text = f"{gen_type_name} ({models_count})"
                    keyboard.append([
                        InlineKeyboardButton(button_text, callback_data=f"gen_type:{text_to_image_type}")
                    ])
                    keyboard.append([])  # Empty row for spacing
            
            # Add other generation types
            keyboard.extend(gen_type_rows)

            # Add free tools button (always visible, prominent)
            keyboard.append([])  # Empty row for spacing
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton("üÜì FAST TOOLS", callback_data="free_tools")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton("üÜì FAST TOOLS", callback_data="free_tools")
                ])

            # Add "Other models" shortcut
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton("üß© –î—Ä—É–≥–∏–µ –º–æ–¥–µ–ª–∏", callback_data="other_models")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton("üß© Other models", callback_data="other_models")
                ])

            # Add button to show all models directly (without grouping by type)
            keyboard.append([])  # Empty row for spacing
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton(f"üìã –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ {visible_models_count} –º–æ–¥–µ–ª–µ–π", callback_data="show_all_models_list")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton(f"üìã Show all {visible_models_count} models", callback_data="show_all_models_list")
                ])
            
            user_lang = get_user_language(user_id)
            keyboard.append([
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
            
            try:
                await query.edit_message_text(
                    models_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except BadRequest as exc:
                if "Message is not modified" in str(exc):
                    await query.answer()
                    return SELECTING_MODEL
                logger.error(f"Error editing message in show_models: {exc}", exc_info=True)
                try:
                    await query.message.reply_text(
                        models_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return SELECTING_MODEL
        
        if data == "show_all_models_list":
            # Answer callback immediately
            try:
                await query.answer()
            except Exception as e:
                logger.error(f"Error answering callback for show_all_models_list: {e}")
            
            logger.info(f"User {user_id} clicked 'show_all_models_list' button")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
            try:
                from app.helpers.models_menu_handlers import handle_show_all_models_list
                user_lang = get_user_language(user_id)
                reset_session_context(
                    user_id,
                    reason="show_all_models_list",
                    clear_gen_type=True,
                    correlation_id=correlation_id,
                    update_id=update_id,
                    chat_id=query.message.chat_id if query.message else None,
                )
                set_session_context(
                    user_id,
                    to_context=UI_CONTEXT_MODEL_MENU,
                    reason="show_all_models_list",
                    clear_gen_type=True,
                    correlation_id=correlation_id,
                    update_id=update_id,
                    chat_id=query.message.chat_id if query.message else None,
                )
                loading_text = (
                    "‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π‚Ä¶" if user_lang == 'ru' else "‚è≥ Loading models list‚Ä¶"
                )
                try:
                    await query.edit_message_text(loading_text, parse_mode='HTML')
                except Exception as edit_exc:
                    logger.debug("Could not show loading state for show_all_models_list: %s", edit_exc)
                
                async def _render_all_models_list():
                    try:
                        await asyncio.wait_for(
                            handle_show_all_models_list(
                                query,
                                user_id,
                                user_lang,
                                skip_answer=True,
                            ),
                            timeout=10,
                        )
                    except asyncio.TimeoutError:
                        fallback = (
                            "‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑." if user_lang == 'ru' else "‚ö†Ô∏è Too slow. Please try again."
                        )
                        try:
                            await query.edit_message_text(fallback, parse_mode='HTML')
                        except Exception:
                            pass
                    except Exception as exc:
                        logger.error("Error in handle_show_all_models_list: %s", exc, exc_info=True)
                        fallback = (
                            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ." if user_lang == 'ru' else "‚ùå Error loading models. Please try later."
                        )
                        try:
                            await query.edit_message_text(fallback, parse_mode='HTML')
                        except Exception:
                            try:
                                await query.answer(fallback, show_alert=True)
                            except Exception:
                                pass
                
                if context and getattr(context, "application", None):
                    task = context.application.create_task(_render_all_models_list())
                    _register_background_task(task, action="render_all_models_list")
                else:
                    await _render_all_models_list()
                return SELECTING_MODEL
            except Exception as e:
                logger.error(f"Error in handle_show_all_models_list: {e}", exc_info=True)
                user_lang = get_user_language(user_id)
                if user_lang == 'ru':
                    error_msg = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                else:
                    error_msg = "‚ùå Error loading models. Please try later."
                await query.answer(error_msg, show_alert=True)
                return SELECTING_MODEL
            
            return SELECTING_MODEL
        
        if data == "add_image":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            session = user_sessions.get(user_id, {})
            # Determine which parameter name to use (image_input or image_urls)
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            if 'image_urls' in input_params:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'
            session['waiting_for'] = image_param_name
            session['current_param'] = image_param_name
            if image_param_name not in session:
                session[image_param_name] = []  # Initialize as array
            free_counter_line = await _resolve_free_counter_line(
                user_id,
                user_lang,
                correlation_id,
                action_path=f"param_prompt:{image_param_name}",
                sku_id=session.get("sku_id"),
            )
            prompt_text = _append_free_counter_text(
                "üì∑ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n"
                "–ú–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ 8 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.",
                free_counter_line,
            )
            keyboard = [
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            await query.edit_message_text(
                prompt_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
        
        if data == "image_done":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return ConversationHandler.END
            session = user_sessions[user_id]
            waiting_for = session.get('waiting_for', 'image_input')
            # Normalize: if waiting_for is 'image', use the actual parameter name from properties
            if waiting_for == 'image':
                properties = session.get('properties', {})
                if 'image_input' in properties:
                    image_param_name = 'image_input'
                elif 'image_urls' in properties:
                    image_param_name = 'image_urls'
                else:
                    image_param_name = 'image_input'  # Default fallback
            else:
                image_param_name = waiting_for
            
            if image_param_name in session and session[image_param_name]:
                if 'params' not in session:
                    session['params'] = {}
                session['params'][image_param_name] = session[image_param_name]
                await query.edit_message_text(
                    f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(session[image_param_name])}\n\n"
                    f"–ü—Ä–æ–¥–æ–ª–∂–∞—é..."
                )
            session['waiting_for'] = None
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    # Calculate price for confirmation message
                    is_admin_user = get_is_admin(user_id)
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if price is None:
                        blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                        await query.edit_message_text(blocked_text, parse_mode="HTML")
                        return ConversationHandler.END
                    sku_id = session.get("sku_id", "")
                    is_free = await is_free_generation_available(user_id, sku_id)
                    if price is None:
                        blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                        await query.edit_message_text(blocked_text, parse_mode="HTML")
                        return ConversationHandler.END
                    if is_free:
                        price = 0.0
                    price_str = format_rub_amount(price)
                    
                    # Prepare price info
                    if is_free:
                        remaining = await get_user_free_generations_remaining(user_id)
                        price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}"

                    free_counter_line = ""
                    try:
                        free_counter_line = await get_free_counter_line(
                            user_id,
                            user_lang=user_lang,
                            correlation_id=correlation_id,
                            action_path="confirm_screen",
                            sku_id=sku_id,
                        )
                    except Exception as exc:
                        logger.warning("Failed to resolve free counter line: %s", exc)

                    free_counter_line = ""
                    try:
                        free_counter_line = await get_free_counter_line(
                            user_id,
                            user_lang=user_lang,
                            correlation_id=correlation_id,
                            action_path="confirm_screen",
                            sku_id=sku_id,
                        )
                    except Exception as exc:
                        logger.warning("Failed to resolve free counter line: %s", exc)
                    
                    user_balance = await get_user_balance_async(user_id)
                    # Build enhanced confirmation message
                    confirm_msg_base = build_confirmation_text(
                        model_id=model_id,
                        model_name=model_name,
                        params=params,
                        price=price,
                        user_id=user_id,
                        lang=user_lang,
                        is_free=is_free,
                        bonus_available=0.0,
                        discount=None,
                        user_balance=user_balance,
                        correlation_id=correlation_id,
                    )
                    confirm_msg = _append_free_counter_text(confirm_msg_base, free_counter_line)
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved confirmation message to user {user_id}")
                    await query.edit_message_text(
                        confirm_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after image done: {e}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                return INPUTTING_PARAMS
        
        if data == "add_audio":
            # User wants to add audio file
            await query.answer()
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions.get(user_id, {})
            if not session:
                user_lang = get_user_language(query.from_user.id)
                await query.edit_message_text(t('error_session_empty', lang=user_lang))
                return ConversationHandler.END
            model_info = session.get('model_info', {})
            input_params = model_info.get('input_params', {})
            
            audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
            user_lang = get_user_language(query.from_user.id)
            
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton(t('btn_skip', lang=user_lang), callback_data="skip_audio")]
            ]
            
            await query.edit_message_text(
                "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏.\n\n"
                "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG\n"
                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            
            session['waiting_for'] = audio_param_name
            session['current_param'] = audio_param_name
            return INPUTTING_PARAMS
        
        if data == "skip_audio":
            # User wants to skip audio upload
            await query.answer("–ê—É–¥–∏–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            session['waiting_for'] = None
            session['current_param'] = None
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    # Calculate price for confirmation message
                    is_admin_user = get_is_admin(user_id)
                    sku_id = session.get("sku_id", "")
                    is_free = await is_free_generation_available(user_id, sku_id)
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if is_free:
                        price = 0.0
                    price_str = format_rub_amount(price)
                    
                    # Prepare price info
                    if is_free:
                        remaining = await get_user_free_generations_remaining(user_id)
                        price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}"
                    
                    user_balance = await get_user_balance_async(user_id)
                    # Build enhanced confirmation message
                    confirm_msg_base = build_confirmation_text(
                        model_id=model_id,
                        model_name=model_name,
                        params=params,
                        price=price,
                        user_id=user_id,
                        lang=user_lang,
                        is_free=is_free,
                        bonus_available=0.0,
                        discount=None,
                        user_balance=user_balance,
                        correlation_id=correlation_id,
                    )
                    confirm_msg = _append_free_counter_text(confirm_msg_base, free_counter_line)
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved confirmation message to user {user_id}")
                    await query.edit_message_text(
                        confirm_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after skipping audio: {e}", exc_info=True)
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
            
            return INPUTTING_PARAMS
        
        if data == "skip_image":
            await query.answer("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected
                    if user_id not in user_sessions:
                        await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                        return ConversationHandler.END
                    session = user_sessions[user_id]
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    sku_id = session.get("sku_id")
                    free_counter_line = ""
                    try:
                        free_counter_line = await get_free_counter_line(
                            user_id,
                            user_lang=user_lang,
                            correlation_id=correlation_id,
                            action_path="confirm_screen",
                            sku_id=sku_id,
                        )
                    except Exception as exc:
                        logger.warning("Failed to resolve free counter line: %s", exc)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                
                await query.edit_message_text(
                    _append_free_counter_text(
                        (
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                            f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                            f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?"
                        ),
                        free_counter_line,
                    ),
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after skipping image: {e}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                return INPUTTING_PARAMS

        if data == "show_parameters":
            await query.answer()
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return ConversationHandler.END

            session = user_sessions[user_id]
            properties = session.get('properties', {})
            params = session.get('params', {})
            param_order = session.get('param_order', list(properties.keys()))
            skipped_params = session.get('skipped_params', set())
            user_lang = get_user_language(user_id)
            from app.kie_catalog import get_model

            model_spec = session.get("model_spec") or get_model(session.get("model_id"))
            session_gen_type = session.get("gen_type") or (model_spec.model_type if model_spec else None)
            keyboard = []

            for param_name in param_order:
                if param_name not in properties:
                    continue
                param_info = properties.get(param_name, {})
                default_value = _resolve_unified_default(
                    param_name,
                    param_info,
                    model_spec=model_spec,
                    session_gen_type=session_gen_type,
                )
                if param_name in params:
                    value_text = str(params[param_name])
                elif param_name in skipped_params:
                    value_text = "–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é" if user_lang == "ru" else "default"
                elif default_value is not None:
                    value_text = f"{default_value}"
                else:
                    value_text = "‚Äî"
                if len(value_text) > 30:
                    value_text = value_text[:30] + "‚Ä¶"
                keyboard.append([
                    InlineKeyboardButton(
                        f"{param_name}: {value_text}",
                        callback_data=f"edit_param:{param_name}"
                    )
                ])

            back_label = "‚óÄÔ∏è –ù–∞–∑–∞–¥" if user_lang == 'ru' else "‚óÄÔ∏è Back"
            keyboard.append([InlineKeyboardButton(back_label, callback_data="back_to_confirmation")])
            keyboard.append([InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])

            text = (
                "‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏</b>\n\n"
                "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ."
                if user_lang == 'ru'
                else "‚öôÔ∏è <b>Model parameters</b>\n\nTap a parameter to change its value."
            )
            await query.edit_message_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            logger.info(
                "üß≠ PARAMS_MENU: action_path=show_parameters model_id=%s waiting_for=%s current_param=%s outcome=shown",
                session.get('model_id'),
                session.get('waiting_for'),
                session.get('current_param'),
            )
            return INPUTTING_PARAMS

        if data.startswith("edit_param:"):
            await query.answer()
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return ConversationHandler.END
            session = user_sessions[user_id]
            param_name = data.split(":", 1)[1]
            session.setdefault('param_history', [])
            skipped_params = session.get("skipped_params", set())
            if param_name in skipped_params:
                skipped_params.discard(param_name)
            if 'params' in session:
                session['params'].pop(param_name, None)
            session['waiting_for'] = param_name
            session['current_param'] = param_name
            return await prompt_for_specific_param(update, context, user_id, param_name, source="edit_param")

        if data.startswith("confirm_param:"):
            parts = data.split(":", 2)
            if len(parts) != 3:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∞", show_alert=True)
                return ConversationHandler.END
            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return ConversationHandler.END
            session = user_sessions[user_id]
            param_name = parts[1]
            pending = session.pop("pending_param", None)
            pending_params = session.pop("pending_params", None)
            session.pop("pending_price", None)
            if not pending or pending.get("name") != param_name or not isinstance(pending_params, dict):
                await query.edit_message_text("‚ùå –ü–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
                return ConversationHandler.END
            skip_param = pending.get("skip", False)
            session['params'] = pending_params
            skipped_params = session.setdefault("skipped_params", set())
            if skip_param:
                skipped_params.add(param_name)
            else:
                skipped_params.discard(param_name)
            _record_param_history(session, param_name)
            session['current_param'] = None
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
                update_id=update_id,
                action="PARAM_CONFIRM",
                action_path="button_callback.confirm_param",
                param={"param_name": param_name, "source": "callback"},
                outcome="confirmed",
            )
            model_id = session.get("model_id", "")
            mode_index = _resolve_mode_index(model_id, session.get("params", {}), user_id)
            price_quote = _update_price_quote(
                session,
                model_id=model_id,
                mode_index=mode_index,
                gen_type=session.get("gen_type"),
                params=session.get("params", {}),
                correlation_id=correlation_id,
                update_id=update_id,
                action_path="button_callback.confirm_param",
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
                is_admin=get_is_admin(user_id),
            )
            if not price_quote:
                blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                await query.edit_message_text(blocked_text, parse_mode="HTML")
                return ConversationHandler.END

            required = session.get('required', [])
            params = session.get('params', {})
            missing = [p for p in required if p not in params]

            if missing:
                price_line = _build_current_price_line(
                    session,
                    user_lang=user_lang,
                    model_id=model_id,
                    mode_index=mode_index,
                    gen_type=session.get("gen_type"),
                    params=session.get("params", {}),
                    correlation_id=correlation_id,
                    update_id=update_id,
                    action_path="button_callback.confirm_param",
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    is_admin=get_is_admin(user_id),
                )
                await query.edit_message_text(f"‚úÖ {param_name} —Å–æ—Ö—Ä–∞–Ω—ë–Ω.\n{price_line}")
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                return INPUTTING_PARAMS

            session['waiting_for'] = None
            if not model_id:
                logger.error(f"‚ùå model_id not found in session for user_id={user_id}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–µ—Å—Å–∏–∏.")
                return ConversationHandler.END
            return await send_confirmation_message(update, context, user_id, source="confirm_param_complete")

        if data == "back_to_confirmation":
            await query.answer()
            return await send_confirmation_message(update, context, user_id, source="back_to_confirmation")
        
        if data.startswith("set_param:"):
            # Handle parameter setting via button
            parts = data.split(":", 2)
            if len(parts) != 3:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∞", show_alert=True)
                return ConversationHandler.END

            param_name = parts[1]
            param_value = parts[2]
            skip_param = False

            if user_id not in user_sessions:
                await query.edit_message_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return ConversationHandler.END

            session = user_sessions[user_id]
            properties = session.get('properties', {})
            param_info = properties.get(param_name, {})
            param_type = param_info.get('type', 'string')

            # üî¥ –í–ê–õ–ò–î–ê–¶–ò–Ø ENUM –ó–ù–ê–ß–ï–ù–ò–ô: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å–ø–∏—Å–∫–µ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö
            enum_values = _normalize_enum_values(param_info)
            if enum_values and param_value not in enum_values and param_value not in {SKIP_PARAM_VALUE, "custom"}:
                # –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ enum –∑–Ω–∞—á–µ–Ω–∏–µ
                user_lang = get_user_language(user_id) if user_id else 'ru'
                error_text = (
                    f"‚ùå <b>–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ</b>\n\n"
                    f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: {', '.join(enum_values)}\n"
                    f"–í–≤–µ–¥–µ–Ω–æ: {param_value}"
                ) if user_lang == 'ru' else (
                    f"‚ùå <b>Invalid value</b>\n\n"
                    f"Allowed values: {', '.join(enum_values)}\n"
                    f"Entered: {param_value}"
                )
                await query.answer(error_text, show_alert=True)
                return ConversationHandler.END

            if param_value == SKIP_PARAM_VALUE:
                if param_info.get('required', False):
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_text = (
                        "‚ùå –≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω."
                        if user_lang == 'ru'
                        else "‚ùå This parameter is required and cannot be skipped."
                    )
                    await query.answer(error_text, show_alert=True)
                    return INPUTTING_PARAMS
                user_lang = get_user_language(user_id) if user_id else 'ru'
                if 'params' in session and param_name in session['params']:
                    session['params'].pop(param_name, None)
                skipped_params = session.setdefault("skipped_params", set())
                skipped_params.add(param_name)
                session['current_param'] = None
                session['waiting_for'] = None
                _record_param_history(session, param_name)
                skip_param = True
                param_label = _humanize_param_name(param_name, user_lang)
                skip_text = (
                    f"‚úÖ {param_label}: –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"
                    if user_lang == "ru"
                    else f"‚úÖ {param_label}: default applied"
                )
                mode_index = _resolve_mode_index(session.get("model_id", ""), session.get("params", {}), user_id)
                price_line = _build_current_price_line(
                    session,
                    user_lang=user_lang,
                    model_id=session.get("model_id", ""),
                    mode_index=mode_index,
                    gen_type=session.get("gen_type"),
                    params=session.get("params", {}),
                    correlation_id=correlation_id,
                    update_id=update_id,
                    action_path="button_callback.set_param",
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    is_admin=get_is_admin(user_id),
                )
                await query.edit_message_text(f"{skip_text}\n{price_line}")
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update_id,
                    action="PARAM_SKIPPED",
                    action_path="button_callback.set_param",
                    param={"param_name": param_name, "source": "callback"},
                    outcome="skipped",
                )
                try:
                    next_param_result = await start_next_parameter(update, context, user_id)
                    if next_param_result:
                        return next_param_result
                    return INPUTTING_PARAMS
                except Exception as e:
                    logger.error(f"Error starting next parameter after skip: {e}")
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                    return INPUTTING_PARAMS

            if param_value == "custom" and param_name == "language_code":
                session['current_param'] = param_name
                session['waiting_for'] = param_name
                session['language_code_custom'] = True
                await query.edit_message_text(
                    "‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ —è–∑—ã–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: en, ru, de, fr).",
                )
                return INPUTTING_PARAMS

            # Convert boolean string to actual boolean
            if param_type == 'boolean':
                if param_value.lower() == 'true':
                    param_value = True
                elif param_value.lower() == 'false':
                    param_value = False
                else:
                    # Use default if invalid
                    param_value = param_info.get('default', True)

            if 'params' not in session:
                session['params'] = {}
            candidate_params = dict(session.get("params", {}))
            display_value = param_value
            if skip_param:
                default_value = param_info.get("default")
                if default_value is not None:
                    candidate_params[param_name] = default_value
                    display_value = default_value
                else:
                    candidate_params.pop(param_name, None)
            else:
                candidate_params[param_name] = param_value

            from app.pricing.price_resolver import resolve_price_quote
            from app.config import get_settings
            model_id = session.get("model_id", "")
            mode_index = _resolve_mode_index(model_id, candidate_params, user_id)
            quote = resolve_price_quote(
                model_id=model_id,
                mode_index=mode_index,
                gen_type=session.get("gen_type"),
                selected_params=candidate_params,
                settings=get_settings(),
                is_admin=get_is_admin(user_id),
            )
            if quote is None:
                user_lang = get_user_language(user_id) if user_id else 'ru'
                blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                await query.edit_message_text(blocked_text, parse_mode="HTML")
                return ConversationHandler.END

            session["pending_param"] = {
                "name": param_name,
                "value": param_value,
                "skip": skip_param,
            }
            session["pending_params"] = candidate_params
            session["pending_price"] = float(quote.price_rub)
            option_label = _humanize_param_name(param_name, user_lang)
            confirm_text = build_option_confirm_text(
                user_lang,
                option_label,
                str(display_value),
                float(quote.price_rub),
            )
            confirm_button = "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å" if user_lang == "ru" else "‚úÖ Confirm"
            back_button = "‚Ü©Ô∏è –ù–∞–∑–∞–¥" if user_lang == "ru" else "‚Ü©Ô∏è Back"
            keyboard = InlineKeyboardMarkup(
                [
                    [InlineKeyboardButton(confirm_button, callback_data=f"confirm_param:{param_name}:{param_value}")],
                    [InlineKeyboardButton(back_button, callback_data=f"edit_param:{param_name}")],
                ]
            )
            await query.edit_message_text(confirm_text, reply_markup=keyboard, parse_mode="HTML")
            return INPUTTING_PARAMS

            # Check if there are more parameters
            required = session.get('required', [])
            params = session.get('params', {})
            missing = [p for p in required if p not in params]

            if missing:
                mode_index = _resolve_mode_index(model_id, session.get("params", {}), user_id)
                price_line = _build_current_price_line(
                    session,
                    user_lang=user_lang,
                    model_id=model_id,
                    mode_index=mode_index,
                    gen_type=session.get("gen_type"),
                    params=session.get("params", {}),
                    correlation_id=correlation_id,
                    update_id=update_id,
                    action_path="button_callback.set_param",
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    is_admin=get_is_admin(user_id),
                )
                await query.edit_message_text(f"‚úÖ {param_name} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {param_value}\n{price_line}")
                # Move to next parameter
                try:
                    next_param_result = await start_next_parameter(update, context, user_id)
                    if next_param_result:
                        return next_param_result
                    return INPUTTING_PARAMS
                except Exception as e:
                    logger.error(f"Error starting next parameter: {e}")
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
                    return INPUTTING_PARAMS

            # All parameters collected
            session['waiting_for'] = None
            # Get model_id from session (CRITICAL: must be defined before use)
            model_id = session.get('model_id', '')
            if not model_id:
                logger.error(f"‚ùå model_id not found in session for user_id={user_id}")
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–µ—Å—Å–∏–∏.")
                return ConversationHandler.END
            return await send_confirmation_message(update, context, user_id, source="set_param_complete")
        
        # Handle back to previous step
        if data == "back_to_previous_step":
            await query.answer("‚óÄÔ∏è –í–æ–∑–≤—Ä–∞—â–∞—é—Å—å –Ω–∞–∑–∞–¥...")
            user_lang = get_user_language(user_id)
            
            if user_id not in user_sessions:
                await query.edit_message_text(
                    t('error_try_start', lang=user_lang),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            session = user_sessions[user_id]
            try:
                history = session.setdefault('param_history', [])
                params = session.get('params', {})
                if not history:
                    logger.info(
                        "üß≠ BACK: action_path=back_to_previous_step model_id=%s waiting_for=%s current_param=%s outcome=no_history",
                        session.get('model_id'),
                        session.get('waiting_for'),
                        session.get('current_param'),
                    )
                    log_structured_event(
                        correlation_id=ensure_correlation_id(update, context),
                        user_id=user_id,
                        chat_id=query.message.chat_id if query and query.message else None,
                        update_id=update.update_id,
                        action="BACK_TO_PREVIOUS_STEP",
                        action_path="back_to_previous_step",
                        model_id=session.get("model_id"),
                        stage="UI_ROUTER",
                        outcome="no_history",
                        error_code="UX_NO_HISTORY",
                        fix_hint="No previous steps in history; show menu options or continue current step.",
                        param={"waiting_for": session.get("waiting_for"), "current_param": session.get("current_param")},
                    )
                    no_history_text = (
                        "‚ÑπÔ∏è <b>–ù–µ—á–µ–≥–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å</b>\n\n"
                        "–í—ã –Ω–∞ –ø–µ—Ä–≤–æ–º —à–∞–≥–µ.\n"
                        "–ö–æ–¥: <code>UX_NO_HISTORY</code>\n\n"
                        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ."
                        if user_lang == "ru"
                        else (
                            "‚ÑπÔ∏è <b>Nothing to return</b>\n\n"
                            "You are on the first step.\n"
                            "Code: <code>UX_NO_HISTORY</code>\n\n"
                            "Choose an action below."
                        )
                    )
                    keyboard = InlineKeyboardMarkup(
                        [
                            [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")],
                            [InlineKeyboardButton(t('btn_all_models_short', lang=user_lang), callback_data="show_models")],
                            [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")],
                        ]
                    )
                    await query.edit_message_text(
                        no_history_text,
                        reply_markup=keyboard,
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS

                previous_param = history.pop()
                if previous_param in params:
                    params.pop(previous_param, None)
                session['params'] = params
                session['waiting_for'] = previous_param
                session['current_param'] = previous_param
                logger.info(
                    "üß≠ BACK: action_path=back_to_previous_step model_id=%s waiting_for=%s current_param=%s outcome=rewind",
                    session.get('model_id'),
                    session.get('waiting_for'),
                    session.get('current_param'),
                )
                next_param_result = await prompt_for_specific_param(
                    update,
                    context,
                    user_id,
                    previous_param,
                    source="back_to_previous_step",
                )
                if next_param_result:
                    return next_param_result
                return INPUTTING_PARAMS
            except Exception as e:
                logger.error(f"Error in back_to_previous_step: {e}", exc_info=True)
                # Fallback: return to model selection
                await query.edit_message_text(
                    t('error_try_start', lang=user_lang),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
        
        if data == "check_balance":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            reset_session_on_navigation(user_id, reason="check_balance")
            
            # Check user's personal balance (–∏—Å–ø–æ–ª—å–∑—É–µ–º helpers –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
            try:
                user_lang = get_user_language(user_id)
                balance_info = await get_balance_info(user_id, user_lang)
                balance_text = await format_balance_message(balance_info, user_lang)
                keyboard = get_balance_keyboard(balance_info, user_lang)
                
                try:
                    await query.edit_message_text(
                        balance_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error editing message in check_balance: {e}", exc_info=True)
                    try:
                        await query.message.reply_text(
                            balance_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except:
                        pass
            except Exception as e:
                logger.error(f"Error in check_balance: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –±–∞–ª–∞–Ω—Å–∞", show_alert=True)
                except:
                    pass
            return ConversationHandler.END
        
        if data == "topup_balance":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Check if user is blocked
            if is_user_blocked(user_id):
                await query.edit_message_text(
                    "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
                    "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Get payment details to show immediately
            payment_details = get_payment_details()
            user_lang = get_user_language(user_id)
            
            # Show amount selection - focus on small amounts with marketing
            keyboard = [
                [
                    InlineKeyboardButton("üíé 50 ‚ÇΩ", callback_data="topup_amount:50"),
                    InlineKeyboardButton("üíé 100 ‚ÇΩ", callback_data="topup_amount:100"),
                    InlineKeyboardButton("üíé 150 ‚ÇΩ", callback_data="topup_amount:150")
                ],
                [
                    InlineKeyboardButton(t('btn_custom_amount', lang=user_lang), callback_data="topup_custom")
                ],
                [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            current_balance = await get_user_balance_async(user_id)
            balance_str = format_rub_amount(current_balance)
            
            await query.edit_message_text(
                f'üí≥ <b>–ü–û–ü–û–õ–ù–ï–ù–ò–ï –ë–ê–õ–ê–ù–°–ê</b> üí≥\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí∞ <b>–¢–≤–æ–π —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {balance_str}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'{payment_details}\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n'
                f'‚Ä¢ –û—Ç 4 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ –û—Ç 1 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n'
                f'‚Ä¢ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç 1 ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üöÄ <b>–í–´–ë–ï–†–ò –°–£–ú–ú–£:</b>\n'
                f'‚Ä¢ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä: 50, 100, 150 ‚ÇΩ\n'
                f'‚Ä¢ –ò–ª–∏ —É–∫–∞–∂–∏ —Å–≤–æ—é —Å—É–º–º—É\n\n'
                f'üìù <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</b>\n'
                f'–ú–∏–Ω–∏–º—É–º: 50 ‚ÇΩ | –ú–∞–∫—Å–∏–º—É–º: 50000 ‚ÇΩ',
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        
        if data.startswith("topup_amount:"):
            # User selected a preset amount
            parts = data.split(":", 1)
            if len(parts) < 2:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã", show_alert=True)
                return ConversationHandler.END
            try:
                amount = float(parts[1])
            except (ValueError, TypeError):
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞", show_alert=True)
                return ConversationHandler.END
            user_lang = get_user_language(user_id)
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # free tools price
            video_count = int(amount / 3.86)  # Basic video price
            
            # Show payment method selection
            amount_display = format_rub_amount(amount)
            if user_lang == 'ru':
                payment_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount_display}</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount_display}\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (free tools)\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê –¢–û–õ–¨–ö–û –ü–û –°–ë–ü:</b>'
                )
            else:
                payment_text = (
                    f'üí≥ <b>PAYMENT {amount_display}</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount_display}\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} images (free tools)\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>PAYMENT ONLY VIA SBP:</b>'
                )
            
            # Store amount in session
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_method'
            }
            
            keyboard = [
                [InlineKeyboardButton("üí≥ –°–ë–ü / SBP", callback_data=f"pay_sbp:{amount}")],
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [
                    InlineKeyboardButton(t('btn_support', lang=user_lang), callback_data="support_contact"),
                    InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")
                ]
            ]
            
            await query.edit_message_text(
                payment_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        
        # Handle payment method selection
        if data.startswith("pay_stars:"):
            await query.answer("–°–µ–π—á–∞—Å –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –æ–ø–ª–∞—Ç–∞ –ø–æ –°–ë–ü.", show_alert=True)
            return SELECTING_AMOUNT
        
        if data.startswith("pay_sbp:"):
            # User chose SBP payment
            parts = data.split(":", 1)
            if len(parts) < 2:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã", show_alert=True)
                return ConversationHandler.END
            try:
                amount = float(parts[1])
            except (ValueError, TypeError):
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞", show_alert=True)
                return ConversationHandler.END
            user_lang = get_user_language(user_id)
            session = user_sessions.get(user_id, {})
            if session.get("waiting_for") != "payment_method" or session.get("topup_amount") is None:
                await query.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è.", show_alert=True)
                return ConversationHandler.END

            amount = session.get("topup_amount", amount)
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_screenshot',
                'payment_method': 'sbp'
            }
            
            payment_details = get_payment_details()
            keyboard = [
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [
                    InlineKeyboardButton(t('btn_support', lang=user_lang), callback_data="support_contact"),
                    InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")
                ]
            ]

            sbp_text = build_manual_payment_instructions(
                amount=amount,
                user_lang=user_lang,
                payment_details=payment_details,
                method_label="–°–ë–ü" if user_lang == "ru" else "SBP",
            )
            
            await query.edit_message_text(
                sbp_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return WAITING_PAYMENT_SCREENSHOT

        if data.startswith("pay_card:"):
            await query.answer("–°–µ–π—á–∞—Å –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –æ–ø–ª–∞—Ç–∞ –ø–æ –°–ë–ü.", show_alert=True)
            return SELECTING_AMOUNT
        
        if data == "topup_custom":
            # User wants to enter custom amount
            await query.edit_message_text(
                f'üí∞ <b>–í–í–ï–î–ò –°–í–û–Æ –°–£–ú–ú–£</b> üí∞\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìù <b>–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å —á–∏—Å–ª–æ</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: 250)\n\n'
                f'üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n'
                f'‚Ä¢ –û—Ç 3.86 ‚ÇΩ –∑–∞ –≤–∏–¥–µ–æ\n'
                f'‚Ä¢ –û—Ç 0.62 ‚ÇΩ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n'
                f'‚Ä¢ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç 0.5 ‚ÇΩ\n\n'
                f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                f'üìã <b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</b>\n'
                f'‚Ä¢ –ú–∏–Ω–∏–º—É–º: 50 ‚ÇΩ\n'
                f'‚Ä¢ –ú–∞–∫—Å–∏–º—É–º: 50000 ‚ÇΩ\n\n'
                f'üí¨ <b>–û—Ç–ø—Ä–∞–≤—å —Å—É–º–º—É —Ü–∏—Ñ—Ä–∞–º–∏</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä: 250)',
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'topup_amount_input'
            }
            return SELECTING_AMOUNT
        
        # Admin functions (only for admin)
        if get_is_admin(user_id):
            if data.startswith("admin_user_info:"):
                await query.answer()
                parts = data.split(":", 1)
                if len(parts) < 2:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", show_alert=True)
                    return ConversationHandler.END
                try:
                    target_user_id = int(parts[1])
                except ValueError:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π user_id", show_alert=True)
                    return ConversationHandler.END
                text, keyboard = await build_admin_user_overview(target_user_id)
                await query.edit_message_text(text, reply_markup=keyboard, parse_mode='HTML')
                return ConversationHandler.END

            if data.startswith("admin_topup_user:"):
                await query.answer()
                parts = data.split(":", 1)
                if len(parts) < 2:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", show_alert=True)
                    return ConversationHandler.END
                try:
                    target_user_id = int(parts[1])
                except ValueError:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π user_id", show_alert=True)
                    return ConversationHandler.END
                user_sessions[user_id] = {
                    "waiting_for": "admin_manual_topup_amount",
                    "admin_target_user_id": target_user_id,
                }
                await query.edit_message_text(
                    f"‚ûï <b>–ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞</b>\n\n"
                    f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <code>{target_user_id}</code>\n"
                    f"üí¨ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—É–º–º—É –¥–ª—è –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: 150)\n\n"
                    f"–û—Ç–º–µ–Ω–∞: /cancel",
                    parse_mode='HTML'
                )
                return ConversationHandler.END

            if data == "admin_stats":
                await render_admin_panel(query, context, is_callback=True)
                return ConversationHandler.END
            
            # Handle payment screenshots viewing
            if data == "view_payment_screenshots":
                await query.answer()
                
                # Get all payments with screenshots
                payments = get_all_payments()
                payments_with_screenshots = [p for p in payments if p.get('screenshot_file_id')]
                
                if not payments_with_screenshots:
                    await query.edit_message_text(
                        "üì∏ <b>–°–∫—Ä–∏–Ω—à–æ—Ç—ã –ø–ª–∞—Ç–µ–∂–µ–π</b>\n\n"
                        "–ù–µ—Ç –ø–ª–∞—Ç–µ–∂–µ–π —Å–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞–º–∏.",
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END
                
                # Show first payment screenshot
                first_payment = payments_with_screenshots[0]
                payment_index = 0
                
                # Store current index in context for navigation
                context.user_data['payment_screenshot_index'] = 0
                context.user_data['payment_screenshots_list'] = [p.get('id') for p in payments_with_screenshots]
                
                await show_payment_screenshot(query, first_payment, payment_index, len(payments_with_screenshots))
                return ConversationHandler.END
            
            # Handle navigation between payment screenshots
            if data.startswith("payment_screenshot_nav:"):
                await query.answer()
                
                parts = data.split(":", 1)
                if len(parts) < 2:
                    await query.answer("–û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏", show_alert=True)
                    return ConversationHandler.END
                
                direction = parts[1]  # "prev" or "next"
                current_index = context.user_data.get('payment_screenshot_index', 0)
                payment_ids = context.user_data.get('payment_screenshots_list', [])
                
                if not payment_ids:
                    await query.answer("–°–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                    return ConversationHandler.END
                
                # Navigate
                if direction == "prev":
                    current_index = (current_index - 1) % len(payment_ids)
                elif direction == "next":
                    current_index = (current_index + 1) % len(payment_ids)
                else:
                    await query.answer("–ù–µ–≤–µ—Ä–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", show_alert=True)
                    return ConversationHandler.END
                
                context.user_data['payment_screenshot_index'] = current_index
                
                # Get payment by ID
                payment_id = payment_ids[current_index]
                payments = get_all_payments()
                payment = next((p for p in payments if p.get('id') == payment_id), None)
                
                if not payment:
                    await query.answer("–ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                    return ConversationHandler.END
                
                await show_payment_screenshot(query, payment, current_index, len(payment_ids))
                return ConversationHandler.END
            
            # Handle back to payments list
            if data == "admin_payments_back":
                await query.answer()
                await show_admin_payments(query, context, is_callback=True)
                return ConversationHandler.END
        
        # Handle admin view all generations
        if data == "admin_view_generations":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É." if get_user_language(user_id) == 'ru' else "This function is available only to administrator.")
                return ConversationHandler.END
            
            await query.answer()
            user_lang = get_user_language(user_id)
            
            # Load all generations from all users
            history = load_json_file(GENERATIONS_HISTORY_FILE, {})
            
            if not history:
                if user_lang == 'ru':
                    message_text = (
                        "üìö <b>–ü—Ä–æ—Å–º–æ—Ç—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                        "‚ùå –í —Å–∏—Å—Ç–µ–º–µ –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n\n"
                        "üí° –ì–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –∏—Ö —Å–æ–∑–¥–∞–Ω–∏—è."
                    )
                else:
                    message_text = (
                        "üìö <b>View Generations</b>\n\n"
                        "‚ùå No saved generations in the system yet.\n\n"
                        "üí° User generations will appear here after they are created."
                    )
                
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")]
                ]
                await query.edit_message_text(
                    message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Collect all generations with user info
            all_generations = []
            for user_key, user_history in history.items():
                try:
                    user_id_int = int(user_key) if user_key.isdigit() else None
                    if user_id_int:
                        for gen in user_history:
                            gen_with_user = gen.copy()
                            gen_with_user['user_id'] = user_id_int
                            all_generations.append(gen_with_user)
                except (ValueError, TypeError):
                    continue
            
            # Sort by timestamp (newest first)
            all_generations.sort(key=lambda x: x.get('timestamp', 0), reverse=True)
            
            if not all_generations:
                if user_lang == 'ru':
                    message_text = (
                        "üìö <b>–ü—Ä–æ—Å–º–æ—Ç—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–π</b>\n\n"
                        "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è."
                    )
                else:
                    message_text = (
                        "üìö <b>View Generations</b>\n\n"
                        "‚ùå No generations found to display."
                    )
                
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")]
                ]
                await query.edit_message_text(
                    message_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Store in context for navigation
            context.user_data['admin_generations_list'] = all_generations
            context.user_data['admin_generation_index'] = 0
            
            # Show first generation
            await show_admin_generation(query, context, all_generations[0], 0, len(all_generations))
            return ConversationHandler.END
        
        # Handle admin generation navigation
        if data.startswith("admin_gen_nav:"):
            if not is_admin(user_id):
                await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω", show_alert=True)
                return ConversationHandler.END
            
            await query.answer()
            parts = data.split(":", 1)
            if len(parts) < 2:
                return ConversationHandler.END
            
            direction = parts[1]  # "prev" or "next"
            all_generations = context.user_data.get('admin_generations_list', [])
            current_index = context.user_data.get('admin_generation_index', 0)
            
            if not all_generations:
                await query.answer("–°–ø–∏—Å–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
                return ConversationHandler.END
            
            # Navigate
            if direction == "prev":
                current_index = (current_index - 1) % len(all_generations)
            elif direction == "next":
                current_index = (current_index + 1) % len(all_generations)
            else:
                return ConversationHandler.END
            
            context.user_data['admin_generation_index'] = current_index
            gen = all_generations[current_index]
            
            await show_admin_generation(query, context, gen, current_index, len(all_generations))
            return ConversationHandler.END
        
        # Handle admin view generation result
        if data.startswith("admin_gen_view:"):
            if not is_admin(user_id):
                await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω", show_alert=True)
                return ConversationHandler.END
            
            await query.answer()
            parts = data.split(":", 1)
            if len(parts) < 2:
                return ConversationHandler.END
            
            try:
                gen_index = int(parts[1])
            except (ValueError, TypeError):
                return ConversationHandler.END
            
            all_generations = context.user_data.get('admin_generations_list', [])
            if gen_index < 0 or gen_index >= len(all_generations):
                await query.answer("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                return ConversationHandler.END
            
            gen = all_generations[gen_index]
            result_urls = gen.get('result_urls', [])
            
            if not result_urls:
                await query.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
                return ConversationHandler.END
            
            # Send media
            user_lang = get_user_language(user_id)
            session_http = await get_http_client()
            for i, url in enumerate(result_urls[:5]):
                try:
                    async with session_http.get(url) as resp:
                        if resp.status == 200:
                            media_data = await resp.read()
                            
                            is_last = (i == len(result_urls[:5]) - 1)
                            is_video = gen.get('model_id', '') in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard']
                            
                            keyboard = []
                            if is_last:
                                keyboard = [
                                    [InlineKeyboardButton(t('btn_back_to_list', lang=user_lang), callback_data="admin_view_generations")],
                                    [InlineKeyboardButton(t('btn_back_to_admin', lang=user_lang), callback_data="admin_stats")]
                                ]
                            
                            if is_video:
                                video_file = io.BytesIO(media_data)
                                video_file.name = f"generated_video_{i+1}.mp4"
                                await context.bot.send_video(
                                    chat_id=query.message.chat_id,
                                    video=video_file,
                                    reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                )
                            else:
                                photo_file = io.BytesIO(media_data)
                                photo_file.name = f"generated_image_{i+1}.png"
                                await context.bot.send_photo(
                                    chat_id=query.message.chat_id,
                                    photo=photo_file,
                                    reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                )
                except Exception as e:
                    logger.error(f"Error sending admin generation result: {e}")
            
            await query.answer("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")
            return ConversationHandler.END
        
        if data == "admin_settings":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É." if get_user_language(user_id) == 'ru' else "This function is available only to administrator.")
                return ConversationHandler.END
            
            # Get user language
            user_lang = get_user_language(user_id)
            
            # Get support contact info
            support_telegram = os.getenv('SUPPORT_TELEGRAM', '–ù–µ —É–∫–∞–∑–∞–Ω–æ' if user_lang == 'ru' else 'Not specified')
            
            if user_lang == 'ru':
                settings_text = (
                    f'‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n\n'
                    f'üîß <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n\n'
                    f'‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏\n'
                    f'‚úÖ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n'
                    f'‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n'
                    f'‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API\n\n'
                    f'üí° <b>–ö–æ–º–∞–Ω–¥—ã:</b>\n'
                    f'/models - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏\n'
                    f'/balance - –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞\n'
                    f'/search - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
                    f'/add - –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π\n'
                    f'/admin - –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏ —Ä—É—á–Ω—ã–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è\n'
                    f'/payments - –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–ª–∞—Ç–µ–∂–µ–π\n'
                    f'/block_user - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                    f'/unblock_user - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                    f'/user_balance - –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                    f'/config_check - –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏\n\n'
                    f'üí¨ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b>\n\n'
                    f'üí¨ Telegram: {support_telegram if support_telegram != "–ù–µ —É–∫–∞–∑–∞–Ω–æ" else "–ù–µ —É–∫–∞–∑–∞–Ω–æ"}\n\n'
                    f'üí° –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ —Ñ–∞–π–ª .env'
                )
            else:
                settings_text = (
                    f'‚öôÔ∏è <b>Administrator Settings:</b>\n\n'
                    f'üîß <b>Available Functions:</b>\n\n'
                    f'‚úÖ Model Management\n'
                    f'‚úÖ View Statistics\n'
                    f'‚úÖ User Management\n'
                    f'‚úÖ API Settings\n\n'
                    f'üí° <b>Commands:</b>\n'
                    f'/models - Model Management\n'
                    f'/balance - Check Balance\n'
                    f'/search - Search Knowledge Base\n'
                    f'/add - Add Knowledge\n'
                    f'/admin - User overview and manual top-ups\n'
                    f'/payments - View Payments\n'
                    f'/block_user - Block User\n'
                    f'/unblock_user - Unblock User\n'
                    f'/user_balance - User Balance\n'
                    f'/config_check - Config Check\n\n'
                    f'üí¨ <b>Support Settings:</b>\n\n'
                    f'üí¨ Telegram: {support_telegram if support_telegram != "Not specified" else "Not specified"}\n\n'
                    f'üí° To change support settings, edit the .env file'
                )
            
            # Get current exchange rate
            current_rate = get_usd_to_rub_rate()
            
            if user_lang == 'ru':
                settings_text += f'\nüí± <b>–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã:</b>\n'
                settings_text += f'1 USD = {current_rate:.2f} RUB\n\n'
                keyboard = [
                    [InlineKeyboardButton("üí± –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫—É—Ä—Å –≤–∞–ª—é—Ç—ã", callback_data="admin_set_currency_rate")],
                    [InlineKeyboardButton("üß© –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏", callback_data="admin_config_check")],
                    [InlineKeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin_broadcast")],
                    [InlineKeyboardButton("üéÅ –ü—Ä–æ–º–æ–∫–æ–¥—ã", callback_data="admin_promocodes")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_back_to_admin")]
                ]
            else:
                settings_text += f'\nüí± <b>Exchange Rate:</b>\n'
                settings_text += f'1 USD = {current_rate:.2f} RUB\n\n'
                keyboard = [
                    [InlineKeyboardButton("üí± Set Exchange Rate", callback_data="admin_set_currency_rate")],
                    [InlineKeyboardButton("üß© Config Check", callback_data="admin_config_check")],
                    [InlineKeyboardButton("üì¢ Broadcast", callback_data="admin_broadcast")],
                    [InlineKeyboardButton("üéÅ Promocodes", callback_data="admin_promocodes")],
                    [InlineKeyboardButton("‚óÄÔ∏è Back", callback_data="admin_back_to_admin")]
                ]
            
            await query.edit_message_text(
                settings_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END

        if data == "admin_config_check":
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END

            from app.config_env import build_config_self_check_report

            report = build_config_self_check_report()
            user_lang = get_user_language(user_id)
            back_label = "‚óÄÔ∏è –ù–∞–∑–∞–¥" if user_lang == "ru" else "‚óÄÔ∏è Back"
            keyboard = [[InlineKeyboardButton(back_label, callback_data="admin_settings")]]
            await query.edit_message_text(
                report,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="HTML",
            )
            return ConversationHandler.END
        
        if data == "admin_promocodes":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show promocodes menu
            promocodes = load_promocodes()
            active_promo = get_active_promocode()
            
            promocodes_text = "üéÅ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞–º–∏</b>\n\n"
            
            if active_promo:
                promo_code = active_promo.get('code', 'N/A')
                promo_value = active_promo.get('value', 0)
                promo_expires = active_promo.get('expires', 'N/A')
                promo_used = active_promo.get('used_count', 0)
                
                promocodes_text += (
                    f"‚úÖ <b>–ê–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥:</b>\n"
                    f"üîë <b>–ö–æ–¥:</b> <code>{promo_code}</code>\n"
                    f"üí∞ <b>–ó–Ω–∞—á–µ–Ω–∏–µ:</b> {promo_value} ‚ÇΩ\n"
                    f"üìÖ <b>–î–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –¥–æ:</b> {promo_expires}\n"
                    f"üë• <b>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ä–∞–∑:</b> {promo_used}\n\n"
                )
            else:
                promocodes_text += "‚ùå <b>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–º–æ–∫–æ–¥–∞</b>\n\n"
            
            # Show all promocodes
            if promocodes:
                promocodes_text += f"üìã <b>–í—Å–µ –ø—Ä–æ–º–æ–∫–æ–¥—ã ({len(promocodes)}):</b>\n\n"
                for i, promo in enumerate(promocodes, 1):
                    promo_code = promo.get('code', 'N/A')
                    promo_value = promo.get('value', 0)
                    promo_expires = promo.get('expires', 'N/A')
                    promo_used = promo.get('used_count', 0)
                    is_active = promo.get('active', False)
                    
                    status = "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω" if is_active else "‚ùå –ù–µ–∞–∫—Ç–∏–≤–µ–Ω"
                    
                    promocodes_text += (
                        f"{i}. <b>{status}</b>\n"
                        f"   üîë <code>{promo_code}</code>\n"
                        f"   üí∞ {promo_value} ‚ÇΩ | üë• {promo_used} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π\n"
                        f"   üìÖ –î–æ: {promo_expires}\n\n"
                    )
            else:
                promocodes_text += "üìã <b>–ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤</b>\n\n"
            
            promocodes_text += "üí° <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è:</b>\n"
            promocodes_text += "‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤\n"
            promocodes_text += "‚Ä¢ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫—Ç–∏–≤–Ω–æ–º –ø—Ä–æ–º–æ–∫–æ–¥–µ\n"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_promocodes")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_settings")]
            ]
            
            await query.edit_message_text(
                promocodes_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_broadcast":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show broadcast menu
            broadcasts = get_broadcasts()
            total_users = len(get_all_users())
            
            broadcast_text = "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
            broadcast_text += f"üë• <b>–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {total_users}\n\n"
            
            if broadcasts:
                broadcast_text += f"üìã <b>–ò—Å—Ç–æ—Ä–∏—è —Ä–∞—Å—Å—ã–ª–æ–∫ ({len(broadcasts)}):</b>\n\n"
                # Show last 5 broadcasts
                sorted_broadcasts = sorted(
                    broadcasts.items(),
                    key=lambda x: x[1].get('created_at', 0),
                    reverse=True
                )[:5]
                
                for broadcast_id, broadcast in sorted_broadcasts:
                    created_at = broadcast.get('created_at', 0)
                    sent = broadcast.get('sent', 0)
                    delivered = broadcast.get('delivered', 0)
                    failed = broadcast.get('failed', 0)
                    message_preview = broadcast.get('message', '')[:30] + '...' if len(broadcast.get('message', '')) > 30 else broadcast.get('message', '')
                    
                    from datetime import datetime
                    if created_at:
                        date_str = datetime.fromtimestamp(created_at).strftime('%Y-%m-%d %H:%M')
                    else:
                        date_str = 'N/A'
                    
                    broadcast_text += (
                        f"üì® <b>#{broadcast_id}</b> ({date_str})\n"
                        f"   üìù {message_preview}\n"
                        f"   ‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent} | üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {delivered} | ‚ùå –û—à–∏–±–æ–∫: {failed}\n\n"
                    )
            else:
                broadcast_text += "üìã <b>–ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
            
            broadcast_text += "üí° <b>–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Ä–∞—Å—Å—ã–ª–∫—É:</b>\n"
            broadcast_text += "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏."
            
            keyboard = [
                [InlineKeyboardButton("üì¢ –°–æ–∑–¥–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É", callback_data="admin_create_broadcast")],
                [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_broadcast_stats")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_settings")]
            ]
            
            await query.edit_message_text(
                broadcast_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_create_broadcast":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Start broadcast creation
            await query.edit_message_text(
                "üì¢ <b>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\n\n"
                "üí° <b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:</b>\n"
                "‚Ä¢ –¢–µ–∫—Å—Ç\n"
                "‚Ä¢ HTML —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ\n"
                "‚Ä¢ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'broadcast_message'
            }
            return WAITING_BROADCAST_MESSAGE
        
        if data == "admin_set_currency_rate":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Get current exchange rate
            current_rate = get_usd_to_rub_rate()
            
            currency_text = (
                f'üí± <b>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç—ã</b>\n\n'
                f'üìä <b>–¢–µ–∫—É—â–∏–π –∫—É—Ä—Å:</b>\n'
                f'1 USD = {current_rate:.2f} RUB\n\n'
                f'üí° <b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b>\n'
                f'–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç—ã.\n'
                f'–ù–∞–ø—Ä–∏–º–µ—Ä: <code>100</code> (–æ–∑–Ω–∞—á–∞–µ—Ç 1 USD = 100 RUB)\n\n'
                f'‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b>\n'
                f'‚Ä¢ –ö—É—Ä—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º\n'
                f'‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É –¥–ª—è –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä: 95.5)\n'
                f'‚Ä¢ –ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Å–µ —Ü–µ–Ω—ã –±—É–¥—É—Ç –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n\n'
                f'–î–ª—è –æ—Ç–º–µ–Ω—ã –Ω–∞–∂–º–∏—Ç–µ /cancel'
            )
            
            await query.edit_message_text(
                currency_text,
                parse_mode='HTML'
            )
            
            # Set session to wait for currency rate
            user_sessions[user_id] = {
                'waiting_for': 'currency_rate'
            }
            return WAITING_CURRENCY_RATE
        
        if data == "admin_broadcast_stats":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            # Show detailed broadcast statistics
            broadcasts = get_broadcasts()
            total_users = len(get_all_users())
            
            if not broadcasts:
                await query.edit_message_text(
                    "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
                    "‚ùå –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞—Å—Å—ã–ª–æ–∫",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_broadcast")]
                    ]),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Calculate totals
            total_sent = sum(b.get('sent', 0) for b in broadcasts.values())
            total_delivered = sum(b.get('delivered', 0) for b in broadcasts.values())
            total_failed = sum(b.get('failed', 0) for b in broadcasts.values())
            
            stats_text = (
                f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫</b>\n\n"
                f"üë• <b>–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {total_users}\n"
                f"üì® <b>–í—Å–µ–≥–æ —Ä–∞—Å—Å—ã–ª–æ–∫:</b> {len(broadcasts)}\n\n"
                f"üìà <b>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {total_sent}\n"
                f"üì¨ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {total_delivered}\n"
                f"‚ùå –û—à–∏–±–æ–∫: {total_failed}\n\n"
            )
            
            if total_sent > 0:
                success_rate = (total_delivered / total_sent) * 100
                stats_text += f"üìä <b>–£—Å–ø–µ—à–Ω–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏:</b> {success_rate:.1f}%\n"
            
            keyboard = [
                [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="admin_broadcast_stats")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_broadcast")]
            ]
            
            await query.edit_message_text(
                stats_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_search":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üîç <b>–ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π</b>\n\n'
                '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n'
                '<code>/search [–∑–∞–ø—Ä–æ—Å]</code>\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '<code>/search –Ω–µ–π—Ä–æ—Å–µ—Ç–∏</code>',
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_add":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üìù <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π</b>\n\n'
                '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n'
                '<code>/add [–∑–∞–≥–æ–ª–æ–≤–æ–∫] | [—Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ]</code>\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '<code>/add AI | –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç - —ç—Ç–æ...</code>',
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        if data == "admin_test_ocr":
            # Check admin access
            if not is_admin(user_id):
                await query.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
                return ConversationHandler.END
            
            if not OCR_AVAILABLE or not PIL_AVAILABLE:
                await query.edit_message_text(
                    '‚ùå <b>OCR –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</b>\n\n'
                    'Tesseract OCR –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.\n\n'
                    '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ:\n'
                    '1. pip install Pillow pytesseract\n'
                    '2. Tesseract OCR (—Å–º. TESSERACT_INSTALL.txt)',
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            await query.edit_message_text(
                'üß™ <b>–¢–µ—Å—Ç OCR</b>\n\n'
                '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–º –ø–ª–∞—Ç–µ–∂–∞.\n\n'
                '–°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç:\n'
                '‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞\n'
                '‚úÖ –ü–æ–∏—Å–∫ —Å—É–º–º\n'
                '‚úÖ –†–∞–±–æ—Ç–∞ Tesseract OCR\n\n'
                '–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.',
                parse_mode='HTML'
            )
            user_sessions[user_id] = {
                'waiting_for': 'admin_test_ocr'
            }
            return ADMIN_TEST_OCR
        
        if data == "tutorial_start":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                # Interactive tutorial for new users
                tutorial_text = (
                    'üéì <b>–ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –¢–£–¢–û–†–ò–ê–õ</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º—Å—è, –∫–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º.\n\n'
                    'üìö <b>–ß—Ç–æ –≤—ã —É–∑–Ω–∞–µ—Ç–µ:</b>\n'
                    '‚Ä¢ –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n'
                    '‚Ä¢ –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å\n'
                    '‚Ä¢ –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                    '‚Ä¢ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n\n'
                    'üí° <b>–≠—Ç–æ –∑–∞–π–º–µ—Ç 2 –º–∏–Ω—É—Ç—ã!</b>'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å —Ç—É—Ç–æ—Ä–∏–∞–ª", callback_data="tutorial_step1")],
                    [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_start: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_start: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_start: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step1":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                tutorial_text = (
                    'üìñ <b>–®–ê–ì 1: –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è?</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'ü§ñ <b>–ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç</b> –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å:\n\n'
                    'üé® <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n'
                    '–û–ø–∏—à–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É —Å–ª–æ–≤–∞–º–∏, –∏ AI —Å–æ–∑–¥–∞—Å—Ç –µ—ë!\n'
                    '–ü—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ, –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç"\n\n'
                    'üé¨ <b>–í–∏–¥–µ–æ</b>\n'
                    '–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞\n'
                    '–ü—Ä–∏–º–µ—Ä: "–õ–µ—Ç—è—â–∏–π –¥—Ä–∞–∫–æ–Ω –Ω–∞–¥ –≥–æ—Ä–æ–¥–æ–º"\n\n'
                    'üñºÔ∏è <b>–£–ª—É—á—à–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞</b>\n'
                    '–£–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ñ–æ—Ç–æ –≤ 4-8 —Ä–∞–∑\n\n'
                    'üí° <b>–í—Å–µ —ç—Ç–æ –±–µ–∑ VPN!</b> –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –ª—É—á—à–∏–º AI-–º–æ–¥–µ–ª—è–º.'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step2")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_start")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step1: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step1: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step1: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step2":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                categories = get_categories_from_registry()
                total_models = len(get_models_sync())
                tutorial_text = (
                    f'üìñ <b>–®–ê–ì 2: –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å?</b>\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üéØ <b>–£ –Ω–∞—Å {total_models} –º–æ–¥–µ–ª–µ–π –≤ {len(categories)} –∫–∞—Ç–µ–≥–æ—Ä–∏—è—Ö:</b>\n\n'
                    f'üñºÔ∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n'
                    f'‚Ä¢ free tools (FAST TOOLS) ‚Äî 5 —Ä–∞–∑ –≤ –¥–µ–Ω—å\n'
                    f'‚Ä¢ Nano Banana Pro - –∫–∞—á–µ—Å—Ç–≤–æ 2K/4K\n'
                    f'‚Ä¢ Imagen 4 Ultra - –Ω–æ–≤–µ–π—à–∞—è –æ—Ç Google\n\n'
                    f'üé¨ <b>–í–∏–¥–µ–æ</b>\n'
                    f'‚Ä¢ Sora 2 - —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –≤–∏–¥–µ–æ\n'
                    f'‚Ä¢ Grok Imagine - –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å\n\n'
                    f'üí° <b>–°–æ–≤–µ—Ç:</b> –ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π - —ç—Ç–æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ!'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step3")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step1")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step2: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step2: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step2: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step3":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                tutorial_text = (
                    'üìñ <b>–®–ê–ì 3: –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç?</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üìù <b>–ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ—Ü–µ—Å—Å:</b>\n\n'
                    '1Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ "üìã –í—Å–µ –º–æ–¥–µ–ª–∏"\n'
                    '2Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π\n'
                    '3Ô∏è‚É£ –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–ø—Ä–æ–º–ø—Ç)\n'
                    '   –ü—Ä–∏–º–µ—Ä: "–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"\n'
                    '4Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (—Ä–∞–∑–º–µ—Ä, —Å—Ç–∏–ª—å –∏ —Ç.–¥.)\n'
                    '5Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"\n'
                    '6Ô∏è‚É£ –ü–æ–¥–æ–∂–¥–∏—Ç–µ 10-60 —Å–µ–∫—É–Ω–¥\n'
                    '7Ô∏è‚É£ –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç! üéâ\n\n'
                    'üí° <b>–°–æ–≤–µ—Ç:</b> –ß–µ–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ, —Ç–µ–º –ª—É—á—à–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –î–∞–ª–µ–µ", callback_data="tutorial_step4")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step2")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step3: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step3: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step3: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_step4":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                remaining_free = await get_user_free_generations_remaining(user_id)
                tutorial_text = (
                    'üìñ <b>–®–ê–ì 4: –ë–∞–ª–∞–Ω—Å –∏ –æ–ø–ª–∞—Ç–∞</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'üí∞ <b>–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:</b>\n\n'
                    'üéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b>\n'
                    f'‚Ä¢ {remaining_free if remaining_free > 0 else FREE_GENERATIONS_PER_DAY} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ –¥–µ–Ω—å\n'
                    f'‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ - –ø–æ–ª—É—á–∏—Ç–µ –æ–±–∞ +{REFERRAL_BONUS_GENERATIONS} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ free tools!\n\n'
                    'üí≥ <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞:</b>\n'
                    '‚Ä¢ –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: 50 ‚ÇΩ\n'
                    '‚Ä¢ –ë—ã—Å—Ç—Ä—ã–π –≤—ã–±–æ—Ä: 50, 100, 150 ‚ÇΩ\n'
                    '‚Ä¢ –ò–ª–∏ —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ—é —Å—É–º–º—É\n'
                    '‚Ä¢ –û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –°–ë–ü (–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)\n\n'
                    'üí° <b>–°–æ–≤–µ—Ç:</b> –ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π!'
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚ñ∂Ô∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="tutorial_complete")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="tutorial_step3")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_step4: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_step4: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_step4: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "tutorial_complete":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            try:
                tutorial_text = (
                'üéâ <b>–¢–£–¢–û–†–ò–ê–õ –ó–ê–í–ï–†–®–ï–ù!</b>\n\n'
                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                '‚úÖ –¢–µ–ø–µ—Ä—å –≤—ã –∑–Ω–∞–µ—Ç–µ:\n'
                '‚Ä¢ –ß—Ç–æ —Ç–∞–∫–æ–µ AI-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n'
                '‚Ä¢ –ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å\n'
                '‚Ä¢ –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç\n'
                '‚Ä¢ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å\n\n'
                'üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>\n\n'
                'üí° <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:</b>\n'
                    '–ù–∞—á–Ω–∏—Ç–µ —Å –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª—è—Ö!\n'
                '–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏ –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å.'
            )
            
                keyboard = [
                    [InlineKeyboardButton("üìã –í—Å–µ –º–æ–¥–µ–ª–∏", callback_data="all_models")],
                    [InlineKeyboardButton("üÜì FAST TOOLS", callback_data="free_tools")],
                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]
                ]
                
                try:
                    await query.edit_message_text(
                        tutorial_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message in tutorial_complete: {edit_error}, sending new message")
                    try:
                        await query.message.reply_text(
                            tutorial_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except Exception as send_error:
                        logger.error(f"Could not send new message in tutorial_complete: {send_error}", exc_info=True)
                        await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in tutorial_complete: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
        
        if data == "help_menu":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language
            user_lang = get_user_language(user_id)
            is_new = await is_new_user_async(user_id)
            
            if is_new:
                if user_lang == 'ru':
                    help_text = (
                        'üìã <b>–ü–û–ú–û–©–¨ –î–õ–Ø –ù–û–í–´–• –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ô</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b>\n\n'
                        'üéØ <b>–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç:</b>\n'
                        '1. –ù–∞–∂–º–∏—Ç–µ "üìã –í—Å–µ –º–æ–¥–µ–ª–∏"\n'
                        '2. –í—ã–±–µ—Ä–∏—Ç–µ "üÜì FAST TOOLS" (—ç—Ç–æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ!)\n'
                        '3. –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä: "–ö–æ—Ç –≤ –∫–æ—Å–º–æ—Å–µ"\n'
                        '4. –ù–∞–∂–º–∏—Ç–µ "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"\n'
                        '5. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ 10-30 —Å–µ–∫—É–Ω–¥!\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üí° <b>–ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n'
                        '/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n'
                        '/models - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –º–æ–¥–µ–ª–∏\n'
                        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
                        '/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n'
                        '‚ùì <b>–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?</b>\n'
                        '–ù–∞–∂–º–∏—Ç–µ "‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?" –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—É—Ç–æ—Ä–∏–∞–ª–∞!'
                    )
                else:
                    help_text = (
                        'üìã <b>HELP FOR NEW USERS</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üëã <b>Welcome!</b>\n\n'
                        'üéØ <b>Quick Start:</b>\n'
                        '1. Click "üìã All Models"\n'
                        '2. Select "üÜì FAST TOOLS" (it\'s free!)\n'
                        '3. Enter description, e.g.: "Cat in space"\n'
                        '4. Click "‚úÖ Generate"\n'
                        '5. Get result in 10-30 seconds!\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üí° <b>Useful Commands:</b>\n'
                        '/start - Main menu\n'
                        '/models - Show all models\n'
                        '/balance - Check balance\n'
                        '/help - This help\n\n'
                        '‚ùì <b>Need help?</b>\n'
                        'Click "‚ùì How it works?" for interactive tutorial!'
                    )
            else:
                if user_lang == 'ru':
                    help_text = (
                        'üìã <b>–î–û–°–¢–£–ü–ù–´–ï –ö–û–ú–ê–ù–î–´</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üîπ <b>–û—Å–Ω–æ–≤–Ω—ã–µ:</b>\n'
                        '/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n'
                        '/models - –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–µ–ª–∏\n'
                        '/balance - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å\n'
                        '/generate - –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
                        '/help - –°–ø—Ä–∞–≤–∫–∞\n\n'
                    )
                else:
                    help_text = (
                        'üìã <b>AVAILABLE COMMANDS</b>\n\n'
                        '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                        'üîπ <b>Main:</b>\n'
                        '/start - Main menu\n'
                        '/models - Show models\n'
                        '/balance - Check balance\n'
                        '/generate - Start generation\n'
                        '/help - Help\n\n'
                    )
                
                if get_is_admin(user_id):
                    if user_lang == 'ru':
                        help_text += (
                            'üëë <b>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ:</b>\n'
                            '/search - –ü–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π\n'
                            '/add - –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π\n'
                            '/admin - –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏ —Ä—É—á–Ω—ã–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è\n'
                            '/payments - –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–ª–∞—Ç–µ–∂–µ–π\n'
                            '/block_user - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                            '/unblock_user - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                            '/user_balance - –ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n'
                        )
                    else:
                        help_text += (
                            'üëë <b>Administrative:</b>\n'
                            '/search - Search knowledge base\n'
                            '/add - Add knowledge\n'
                            '/admin - User overview and manual top-ups\n'
                            '/payments - View payments\n'
                            '/block_user - Block user\n'
                            '/unblock_user - Unblock user\n'
                            '/user_balance - User balance\n\n'
                        )
                
                if user_lang == 'ru':
                    help_text += (
                        'üí° <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</b>\n'
                        '1. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –º–µ–Ω—é\n'
                        '2. –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç (–æ–ø–∏—Å–∞–Ω–∏–µ)\n'
                        '3. –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏\n'
                        '4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n'
                        '5. –ü–æ–ª—É—á–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç!\n\n'
                        'üìö <b>–ü–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n'
                        '‚Ä¢ "üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏" - –ø—Ä–æ—Å–º–æ—Ç—Ä –∏—Å—Ç–æ—Ä–∏–∏\n'
                        '‚Ä¢ "üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å" - —Å–æ–∑–¥–∞—Ç—å —Å —Ç–µ–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏\n'
                        '‚Ä¢ "üí≥ –ü–æ–ø–æ–ª–Ω–∏—Ç—å" - –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞'
                    )
                else:
                    help_text += (
                        'üí° <b>How to use:</b>\n'
                        '1. Select model from menu\n'
                        '2. Enter prompt (description)\n'
                        '3. Select parameters via buttons\n'
                        '4. Confirm generation\n'
                        '5. Get result!\n\n'
                        'üìö <b>Useful features:</b>\n'
                        '‚Ä¢ "üìö My generations" - view history\n'
                        '‚Ä¢ "üîÑ Repeat" - create with same parameters\n'
                        '‚Ä¢ "üí≥ Top up" - top up balance'
                    )
            
            keyboard = []
            if is_new:
                if user_lang == 'ru':
                    keyboard.append([InlineKeyboardButton("‚ùì –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?", callback_data="tutorial_start")])
                else:
                    keyboard.append([InlineKeyboardButton("‚ùì How it works?", callback_data="tutorial_start")])
            if user_lang == 'ru':
                keyboard.append([
                    InlineKeyboardButton("üéÅ –ö–æ–ª–µ—Å–æ —É–¥–∞—á–∏", callback_data="claim_gift"),
                    InlineKeyboardButton(t('btn_copy_bot', lang=user_lang), callback_data="copy_bot")
                ])
                keyboard.append([
                    InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="set_language:ru"),
                    InlineKeyboardButton("üá∫üá∏ English", callback_data="set_language:en")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton("üéÅ Wheel of Fortune", callback_data="claim_gift"),
                    InlineKeyboardButton(t('btn_copy_bot', lang=user_lang), callback_data="copy_bot")
                ])
                keyboard.append([
                    InlineKeyboardButton("üá∑üá∫ Russian", callback_data="set_language:ru"),
                    InlineKeyboardButton("üá∫üá∏ English", callback_data="set_language:en")
                ])
            keyboard.append([
                InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")
            ])
            
            try:
                await query.edit_message_text(
                    help_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in help_menu: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        help_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data == "support_contact":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language
            user_lang = get_user_language(user_id)
            support_info = get_support_contact()
            
            # Translate support contact message if needed
            if user_lang == 'en' and '–ü–æ–¥–¥–µ—Ä–∂–∫–∞' in support_info:
                # If support info is in Russian but user wants English, add English header
                support_info = (
                    'üí¨ <b>SUPPORT</b>\n\n'
                    '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    'If you have any questions or need help, please contact our support team:\n\n'
                    + support_info.replace('üí¨ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>', '').replace('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', '').strip()
                )
            
            keyboard = [
                [InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            try:
                await query.edit_message_text(
                    support_info,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in support_contact: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        support_info,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return ConversationHandler.END
        
        # Handle copy bot request
        if data == "copy_bot":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Get user language
            user_lang = get_user_language(user_id)
            
            # Create admin link
            admin_link = f"tg://user?id={ADMIN_ID}"
            
            # Create message with admin link
            if user_lang == 'ru':
                copy_message = (
                    f"{t('msg_copy_bot_title', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"{t('msg_copy_bot_description', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üë®‚Äçüíª <a href=\"{admin_link}\">–°–≤—è–∑–∞—Ç—å—Å—è —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º</a>"
                )
            else:
                copy_message = (
                    f"{t('msg_copy_bot_title', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"{t('msg_copy_bot_description', lang=user_lang)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üë®‚Äçüíª <a href=\"{admin_link}\">Contact Administrator</a>"
                )
            
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            try:
                await query.edit_message_text(
                    copy_message,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML',
                    disable_web_page_preview=False
                )
            except Exception as e:
                logger.error(f"Error editing message in copy_bot: {e}", exc_info=True)
                try:
                    await query.message.reply_text(
                        copy_message,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML',
                        disable_web_page_preview=False
                    )
                except:
                    pass
            return ConversationHandler.END
        
        if data == "referral_info":
            return await handle_referral_info(update, context)
        
        if data == "my_generations":
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
            except:
                pass
            
            # Show user's generation history
            history = get_user_generations_history(user_id, limit=20)
            
            # Debug: log history loading
            logger.info(f"Loading history for user {user_id}: found {len(history)} generations")
            
            # Check if file exists and show helpful message
            if not history:
                user_lang = get_user_language(user_id)
                from app.config import get_settings

                storage_is_db = get_settings().get_storage_mode() == "db"
                file_exists = False
                
                # Load full history to check if there are any users at all
                full_history = {}
                total_users = 0
                if not storage_is_db:
                    file_exists = os.path.exists(GENERATIONS_HISTORY_FILE)
                if file_exists and not storage_is_db:
                    try:
                        full_history = load_json_file(GENERATIONS_HISTORY_FILE, {})
                        total_users = len(full_history)
                        logger.info(f"History file exists with {total_users} users. Checking for user {user_id}...")
                    except Exception as e:
                        logger.error(f"Error loading history file: {e}", exc_info=True)
                
                if user_lang == 'ru':
                    message_text = (
                        "üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                        "‚ùå –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.\n\n"
                    )
                    if not storage_is_db and not file_exists:
                        message_text += (
                            "‚ö†Ô∏è <b>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:</b> –§–∞–π–ª –∏—Å—Ç–æ—Ä–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.\n"
                            "–≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞.\n\n"
                        )
                    elif not storage_is_db and total_users > 0:
                        message_text += (
                            f"‚ÑπÔ∏è –í —Å–∏—Å—Ç–µ–º–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ {total_users} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∏—Å—Ç–æ—Ä–∏–µ–π.\n"
                            f"–ï—Å–ª–∏ –≤—ã —Å–æ–∑–¥–∞–≤–∞–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–∞–Ω–µ–µ, –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è.\n\n"
                        )
                    message_text += "üí° –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤—Å–µ –≤–∞—à–∏ —Ä–∞–±–æ—Ç—ã –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –∑–¥–µ—Å—å."
                else:
                    message_text = (
                        "üìö <b>My Generations</b>\n\n"
                        "‚ùå You don't have any saved generations yet.\n\n"
                    )
                    if not storage_is_db and not file_exists:
                        message_text += (
                            "‚ö†Ô∏è <b>Note:</b> History file not found.\n"
                            "This may happen after bot update.\n\n"
                        )
                    elif not storage_is_db and total_users > 0:
                        message_text += (
                            f"‚ÑπÔ∏è System has {total_users} users with history saved.\n"
                            f"If you created generations before, they should appear.\n\n"
                        )
                    message_text += "üí° After creating content, all your works will be saved here."
                
                keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é" if user_lang == 'ru' else "‚óÄÔ∏è Back to menu", callback_data="back_to_menu")]]
                try:
                    await query.edit_message_text(
                        message_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error editing message in my_generations (empty): {e}", exc_info=True)
                    try:
                        await query.message.reply_text(
                            message_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except:
                        pass
                return ConversationHandler.END
            
            # Show first generation with navigation
            try:
                from datetime import datetime
                
                gen = history[0]
                timestamp = gen.get('timestamp', 0)
                if timestamp:
                    date_str = datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M')
                else:
                    date_str = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                
                model_name = gen.get('model_name', gen.get('model_id', 'Unknown'))
                result_urls = gen.get('result_urls', [])
                price = gen.get('price', 0)
                is_free = gen.get('is_free', False)
                
                user_lang = get_user_language(user_id)
                
                history_text = (
                    f"üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä <b>–í—Å–µ–≥–æ:</b> {len(history)} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen.get('id', 1)}</b>\n"
                    f"üìÖ <b>–î–∞—Ç–∞:</b> {date_str}\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                    f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else format_rub_amount(price)}\n"
                    f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
                )
                
                if len(history) > 1:
                    history_text += f"üí° <b>–ü–æ–∫–∞–∑–∞–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n"
                    history_text += f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏\n\n"
                
                keyboard = []
                
                # Navigation buttons if more than 1 generation
                if len(history) > 1:
                    keyboard.append([
                        InlineKeyboardButton(t('btn_previous', lang=user_lang), callback_data=f"gen_history:{gen.get('id', 1)}:prev"),
                        InlineKeyboardButton(t('btn_next', lang=user_lang), callback_data=f"gen_history:{gen.get('id', 1)}:next")
                    ])
                
                # Action buttons
                if result_urls:
                    keyboard.append([
                        InlineKeyboardButton("üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", callback_data=f"gen_view:{gen.get('id', 1)}")
                    ])
                    keyboard.append([
                        InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"gen_repeat:{gen.get('id', 1)}")
                    ])
                
                keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
                
                try:
                    await query.edit_message_text(
                        history_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error editing message in my_generations: {e}", exc_info=True)
                    try:
                        await query.message.reply_text(
                            history_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                    except:
                        pass
            except Exception as e:
                logger.error(f"Error in my_generations: {e}", exc_info=True)
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏—Å—Ç–æ—Ä–∏–∏", show_alert=True)
                except:
                    pass
            return ConversationHandler.END
        
        if data.startswith("gen_view:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            # View specific generation result
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            try:
                gen_id = int(parts[1])
            except (ValueError, TypeError):
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            gen = get_generation_by_id(user_id, gen_id)
            
            if not gen:
                try:
                    await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            result_urls = gen.get('result_urls', [])
            if not result_urls:
                try:
                    await query.answer("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            # Send media
            try:
                session_http = await get_http_client()
                for i, url in enumerate(result_urls[:5]):
                    try:
                        async with session_http.get(url) as resp:
                                if resp.status == 200:
                                    media_data = await resp.read()
                                    
                                    is_last = (i == len(result_urls[:5]) - 1)
                                    is_video = gen.get('model_id', '') in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard']
                                    
                                    keyboard = []
                                    if is_last:
                                        keyboard = [
                                            [InlineKeyboardButton(t('btn_back_to_history', lang=user_lang), callback_data="my_generations")],
                                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                                        ]
                                    
                                    if is_video:
                                        video_file = io.BytesIO(media_data)
                                        video_file.name = f"generated_video_{i+1}.mp4"
                                        await context.bot.send_video(
                                            chat_id=update.effective_chat.id,
                                            video=video_file,
                                            reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                        )
                                    else:
                                        photo_file = io.BytesIO(media_data)
                                        photo_file.name = f"generated_image_{i+1}.png"
                                        await context.bot.send_photo(
                                            chat_id=update.effective_chat.id,
                                            photo=photo_file,
                                            reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None
                                        )
                    except Exception as e:
                        logger.error(f"Error sending generation result (HTTP API call): {e}", exc_info=True)
            except Exception as e:
                logger.error(f"Error in gen_view API calls: {e}", exc_info=True)
                try:
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
                    await query.answer(error_msg, show_alert=True)
                except:
                    pass
            
            try:
                await query.answer("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")
            except:
                pass
            return ConversationHandler.END
        
        if data.startswith("gen_repeat:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            # Repeat generation with same parameters
            parts = data.split(":", 1)
            if len(parts) < 2:
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            try:
                gen_id = int(parts[1])
            except (ValueError, TypeError):
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            gen = get_generation_by_id(user_id, gen_id)
            
            if not gen:
                try:
                    await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            # Restore session from history
            model_id = gen.get('model_id')
            params = gen.get('params', {})
            model_info = get_model_by_id(model_id)
            
            if not model_info:
                try:
                    await query.answer("‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            user_sessions[user_id] = {
                'model_id': model_id,
                'model_info': model_info,
                'params': params.copy(),
                'properties': model_info.get('input_params', {}),
                'required': []
            }
            
            # Go directly to confirmation
            try:
                await query.answer("‚úÖ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
            except:
                pass
            
            try:
                # Format parameters for display
                params = gen.get('params', {})
                params_preview = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in list(params.items())[:5]])
                if len(params) > 5:
                    params_preview += f"\n  ... –∏ –µ—â–µ {len(params) - 5} –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"
                
                if user_lang == 'ru':
                    repeat_msg = (
                        "üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_info.get('name', model_id)}\n\n"
                        f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏:</b>\n{params_preview if params_preview else '  (–Ω–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)'}\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        "üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                        "‚Ä¢ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã\n"
                        "‚Ä¢ –í—ã –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∑—É –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n"
                        "‚Ä¢ –ò–ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∏ –∏–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\n"
                        "üöÄ <b>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é:</b>"
                    )
                else:
                    repeat_msg = (
                        "üîÑ <b>Repeat generation</b>\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"ü§ñ <b>Model:</b> {model_info.get('name', model_id)}\n\n"
                        f"‚öôÔ∏è <b>Parameters restored from history:</b>\n{params_preview if params_preview else '  (no parameters)'}\n\n"
                        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        "üí° <b>What's next:</b>\n"
                        "‚Ä¢ Parameters are already filled\n"
                        "‚Ä¢ You can start generation immediately\n"
                        "‚Ä¢ Or go back and change parameters\n\n"
                        "üöÄ <b>Confirm generation:</b>"
                    )
                
                logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved repeat generation message to user {user_id}")
                await query.edit_message_text(
                    repeat_msg,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t('btn_confirm_generate_text', lang=user_lang), callback_data="confirm_generate")],
                        [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                        [InlineKeyboardButton(t('btn_back_to_history', lang=user_lang), callback_data="my_generations")],
                        [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                    ]),
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.error(f"Error editing message in gen_repeat: {e}", exc_info=True)
                try:
                    # Format parameters for display
                    params = gen.get('params', {})
                    params_preview = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in list(params.items())[:5]])
                    if len(params) > 5:
                        params_preview += f"\n  ... –∏ –µ—â–µ {len(params) - 5} –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"
                    
                    if user_lang == 'ru':
                        repeat_msg = (
                            "üîÑ <b>–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_info.get('name', model_id)}\n\n"
                            f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏:</b>\n{params_preview if params_preview else '  (–Ω–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)'}\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            "üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                            "‚Ä¢ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã\n"
                            "‚Ä¢ –í—ã –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∑—É –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n"
                            "‚Ä¢ –ò–ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∏ –∏–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã\n\n"
                            "üöÄ <b>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é:</b>"
                        )
                    else:
                        repeat_msg = (
                            "üîÑ <b>Repeat generation</b>\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            f"ü§ñ <b>Model:</b> {model_info.get('name', model_id)}\n\n"
                            f"‚öôÔ∏è <b>Parameters restored from history:</b>\n{params_preview if params_preview else '  (no parameters)'}\n\n"
                            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                            "üí° <b>What's next:</b>\n"
                            "‚Ä¢ Parameters are already filled\n"
                            "‚Ä¢ You can start generation immediately\n"
                            "‚Ä¢ Or go back and change parameters\n\n"
                            "üöÄ <b>Confirm generation:</b>"
                        )
                    
                    logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved repeat generation message (fallback) to user {user_id}")
                    await query.message.reply_text(
                        repeat_msg,
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" if user_lang == 'ru' else "‚úÖ Generate", callback_data="confirm_generate")],
                            [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∏—Å—Ç–æ—Ä–∏–∏" if user_lang == 'ru' else "‚óÄÔ∏è Back to history", callback_data="my_generations")],
                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                        ]),
                        parse_mode='HTML'
                    )
                except:
                    pass
            return CONFIRMING_GENERATION
        
        if data.startswith("gen_history:"):
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            # Navigate through generation history
            parts = data.split(":", 2)
            if len(parts) < 3:
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            try:
                current_gen_id = int(parts[1])
            except (ValueError, TypeError):
                try:
                    await query.answer("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            direction = parts[2]  # prev or next
            
            history = get_user_generations_history(user_id, limit=100)
            if not history:
                try:
                    await query.answer("‚ùå –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            # Find current generation index
            current_index = -1
            for i, gen in enumerate(history):
                if gen.get('id') == current_gen_id:
                    current_index = i
                    break
            
            if current_index == -1:
                try:
                    await query.answer("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            # Navigate
            if direction == 'prev' and current_index < len(history) - 1:
                new_index = current_index + 1
            elif direction == 'next' and current_index > 0:
                new_index = current_index - 1
            else:
                try:
                    await query.answer("‚ö†Ô∏è –≠—Ç–æ –ø–µ—Ä–≤–∞—è/–ø–æ—Å–ª–µ–¥–Ω—è—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è", show_alert=True)
                except:
                    pass
                return ConversationHandler.END
            
            user_lang = get_user_language(user_id)
            
            gen = history[new_index]
            from datetime import datetime
            
            timestamp = gen.get('timestamp', 0)
            if timestamp:
                date_str = datetime.fromtimestamp(timestamp).strftime('%d.%m.%Y %H:%M')
            else:
                date_str = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
            
            model_name = gen.get('model_name', gen.get('model_id', 'Unknown'))
            result_urls = gen.get('result_urls', [])
            price = gen.get('price', 0)
            is_free = gen.get('is_free', False)
            
            if user_lang == 'ru':
                history_text = (
                    f"üìö <b>–ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä <b>–í—Å–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π:</b> {len(history)}\n"
                    f"üìç <b>–ü–æ–∫–∞–∑–∞–Ω–∞:</b> {new_index + 1} –∏–∑ {len(history)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è #{gen.get('id', 1)}</b>\n\n"
                    f"üìÖ <b>–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:</b> {date_str}\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n"
                    f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {'üéÅ –ë–µ—Å–ø–ª–∞—Ç–Ω–æ' if is_free else format_rub_amount(price)}\n"
                    f"üì¶ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:</b> {len(result_urls)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>–ß—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n"
                    f"‚Ä¢ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å —Ç–µ–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏\n"
                    f"‚Ä¢ –ü–µ—Ä–µ–π—Ç–∏ –∫ –¥—Ä—É–≥–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n\n"
                    f"üîÑ <b>–ù–∞–≤–∏–≥–∞—Ü–∏—è:</b> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ"
                )
            else:
                history_text = (
                    f"üìö <b>My Generations</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä <b>Total generations:</b> {len(history)}\n"
                    f"üìç <b>Showing:</b> {new_index + 1} of {len(history)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üé® <b>Generation #{gen.get('id', 1)}</b>\n\n"
                    f"üìÖ <b>Created:</b> {date_str}\n"
                    f"ü§ñ <b>Model:</b> {model_name}\n"
                    f"üí∞ <b>Cost:</b> {'üéÅ Free' if is_free else format_rub_amount(price)}\n"
                    f"üì¶ <b>Results:</b> {len(result_urls)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° <b>What you can do:</b>\n"
                    f"‚Ä¢ View generation result\n"
                    f"‚Ä¢ Repeat generation with same parameters\n"
                    f"‚Ä¢ Navigate to another generation\n\n"
                    f"üîÑ <b>Navigation:</b> Use buttons below"
                )
            
            logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved generation history view to user {user_id}")
            
            keyboard = []
            
            # Navigation buttons
            keyboard.append([
                InlineKeyboardButton("‚óÄÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"gen_history:{gen.get('id', 1)}:prev"),
                InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚ñ∂Ô∏è", callback_data=f"gen_history:{gen.get('id', 1)}:next")
            ])
            
            # Action buttons
            if result_urls:
                keyboard.append([
                    InlineKeyboardButton("üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", callback_data=f"gen_view:{gen.get('id', 1)}")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data=f"gen_repeat:{gen.get('id', 1)}")
                ])
            
            keyboard.append([InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")])
            
            await query.edit_message_text(
                history_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle model card display (model:<model_id>)
        if data.startswith("m:"):
            short_id = data.split(":", 1)[1] if ":" in data else ""
            if not short_id:
                user_lang = get_user_language(user_id) if user_id else "ru"
                await query.answer(
                    t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"),
                    show_alert=True,
                )
                return ConversationHandler.END
            models = get_models_sync()
            matches = [m for m in models if m.get("id", "").startswith(short_id)]
            if len(matches) == 1:
                data = f"model:{matches[0].get('id')}"
            else:
                user_lang = get_user_language(user_id) if user_id else "ru"
                error_msg = (
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–æ–¥–µ–ª—å. –í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –º–µ–Ω—é –∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–Ω–æ–≤–∞."
                    if user_lang == "ru"
                    else "‚ùå Could not resolve model. Return to the menu and select again."
                )
                await query.edit_message_text(
                    error_msg,
                    reply_markup=InlineKeyboardMarkup(
                        [[InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]]
                    ),
                    parse_mode="HTML",
                )
                return ConversationHandler.END

        if data.startswith("model:") or data.startswith("modelk:"):
            try:
                await query.answer()
            except:
                pass
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
            user_lang = get_user_language(user_id)
            
            try:
                from app.helpers.models_menu_handlers import handle_model_callback
                success = await handle_model_callback(query, user_id, user_lang, data)
                
                if success:
                    return SELECTING_MODEL
                else:
                    return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in handle_model_callback: {e}", exc_info=True)
                if user_lang == 'ru':
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–∏", show_alert=True)
                else:
                    await query.answer("‚ùå Error loading model", show_alert=True)
                return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥ (–µ—Å–ª–∏ –Ω–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª)
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1] if len(parts) > 1 else None
            if not model_id:
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑—Ä–µ—à–∏—Ç—å —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import resolve_model_id_from_callback
                model_id = resolve_model_id_from_callback(data)
            
            if not model_id:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.kie_catalog import get_model as get_model_from_catalog
            catalog_model = get_model_from_catalog(model_id)
            
            if catalog_model:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import build_model_card_text
                card_text, keyboard_markup = build_model_card_text(catalog_model, 0, user_lang)
                try:
                    await query.edit_message_text(
                        card_text,
                        reply_markup=keyboard_markup,
                        parse_mode='HTML'
                    )
                    return SELECTING_MODEL
                except Exception as e:
                    logger.error(f"Error showing model card: {e}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –º–æ–¥–µ–ª–∏", show_alert=True)
                    return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            model = get_model_by_id(model_id)
            
            if not model:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –º–æ–¥–µ–ª—å –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            try:
                from kie_models import normalize_model_for_api
                normalized = normalize_model_for_api(model)
            except:
                normalized = model
            
            user_lang = get_user_language(user_id)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –º–æ–¥–µ–ª–∏
            title = normalized.get('title') or normalized.get('name') or model_id
            emoji = normalized.get('emoji', '')
            gen_type = normalized.get('generation_type', 'unknown')
            help_text = normalized.get('help') or normalized.get('description', '')
            input_schema = normalized.get('input_schema') or normalized.get('input_params', {})
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ –º–æ–¥–µ–ª–∏
            if user_lang == 'ru':
                model_info_text = (
                    f"{emoji} <b>{title}</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìã <b>–¢–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {gen_type.replace('_', '-')}\n\n"
                    f"‚ÑπÔ∏è <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{help_text}\n\n"
                )
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö (–±–µ–∑ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —Å—Ö–µ–º—ã)
                if input_schema:
                    required_params = [k for k, v in input_schema.items() if v.get('required', False)]
                    optional_params = [k for k, v in input_schema.items() if not v.get('required', False)]
                    
                    model_info_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    model_info_text += "‚öôÔ∏è <b>–û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
                    if required_params:
                        model_info_text += f"‚Ä¢ –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ: {', '.join(required_params[:5])}"
                        if len(required_params) > 5:
                            model_info_text += f" –∏ –µ—â–µ {len(required_params) - 5}"
                        model_info_text += "\n"
                    if optional_params:
                        model_info_text += f"‚Ä¢ –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ: {', '.join(optional_params[:5])}"
                        if len(optional_params) > 5:
                            model_info_text += f" –∏ –µ—â–µ {len(optional_params) - 5}"
                        model_info_text += "\n"
                    model_info_text += "\n"
                
                model_info_text += (
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üí° <b>–°–æ–≤–µ—Ç:</b> –ü–æ—Å–ª–µ –Ω–∞—á–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—à–∞–≥–æ–≤–æ.\n\n"
                    "üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b> –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ!"
                )
            else:
                model_info_text = (
                    f"{emoji} <b>{title}</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìã <b>Generation type:</b> {gen_type.replace('_', '-')}\n\n"
                    f"‚ÑπÔ∏è <b>Description:</b>\n{help_text}\n\n"
                )
                
                # Add parameter info (without technical schema)
                if input_schema:
                    required_params = [k for k, v in input_schema.items() if v.get('required', False)]
                    optional_params = [k for k, v in input_schema.items() if not v.get('required', False)]
                    
                    model_info_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    model_info_text += "‚öôÔ∏è <b>Main parameters:</b>\n"
                    if required_params:
                        model_info_text += f"‚Ä¢ Required: {', '.join(required_params[:5])}"
                        if len(required_params) > 5:
                            model_info_text += f" and {len(required_params) - 5} more"
                        model_info_text += "\n"
                    if optional_params:
                        model_info_text += f"‚Ä¢ Optional: {', '.join(optional_params[:5])}"
                        if len(optional_params) > 5:
                            model_info_text += f" and {len(optional_params) - 5} more"
                        model_info_text += "\n"
                    model_info_text += "\n"
                
                model_info_text += (
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    "üí° <b>Tip:</b> After starting generation, you'll be able to configure all parameters step by step.\n\n"
                    "üöÄ <b>Ready to start?</b> Click the button below!"
                )
            
            logger.info(f"‚úÖ [UX IMPROVEMENT] Sending improved model card to user {user_id} for model {model_id}")
            
            # –ö–Ω–æ–ø–∫–∏
            if user_lang == 'ru':
                keyboard = [
                    [InlineKeyboardButton("‚úÖ –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é", callback_data=f"start:{model_id}")],
                    [InlineKeyboardButton("‚ÑπÔ∏è –ü—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞", callback_data=f"example:{model_id}")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
            else:
                keyboard = [
                    [InlineKeyboardButton("‚úÖ Start generation", callback_data=f"start:{model_id}")],
                    [InlineKeyboardButton("‚ÑπÔ∏è Example request", callback_data=f"example:{model_id}")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_to_menu")]
                ]
            
            await query.edit_message_text(
                text=model_info_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return ConversationHandler.END
        
        # Handle start generation from model card (start:<model_id>)
        if data.startswith("start:"):
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1]
            # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ select_model –¥–ª—è –Ω–∞—á–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            query.data = f"select_model:{model_id}"
            # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–∞–∫ select_model
            data = query.data
        
        # Handle example request (example:<model_id>)
        if data.startswith("example:"):
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1]
            user_lang = get_user_language(user_id)
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.kie_catalog import get_model as get_model_from_catalog
            catalog_model = get_model_from_catalog(model_id)
            
            if catalog_model:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥ –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
                mode = catalog_model.modes[0] if catalog_model.modes else None
                if user_lang == 'ru':
                    example_text = (
                        f"üì∏ <b>–ü—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è {catalog_model.title_ru}</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–¢–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b> {catalog_model.type}\n\n"
                    )
                else:
                    example_text = (
                        f"üì∏ <b>Example request for {catalog_model.title_ru}</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>Generation type:</b> {catalog_model.type}\n\n"
                    )
                
                if mode:
                    mode_label = _resolve_mode_label(mode, 0, user_lang)
                    example_text += (
                        f"‚öôÔ∏è <b>–†–µ–∂–∏–º:</b> {mode_label}\n\n"
                        if user_lang == 'ru'
                        else f"‚öôÔ∏è <b>Mode:</b> {mode_label}\n\n"
                    )
                
                if user_lang == 'ru':
                    example_text += (
                        f"üí° <b>–°–æ–≤–µ—Ç:</b> –ü–æ—Å–ª–µ –Ω–∞—á–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ—à–∞–≥–æ–≤–æ.\n\n"
                        f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b> –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ!"
                    )
                else:
                    example_text += (
                        f"üí° <b>Tip:</b> After starting generation, you'll be able to configure all parameters step by step.\n\n"
                        f"üöÄ <b>Ready to start?</b> Click the button below!"
                    )
                
                keyboard = [
                    [InlineKeyboardButton("üöÄ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" if user_lang == 'ru' else "üöÄ Generate", callback_data=f"select_model:{model_id}")],
                    [InlineKeyboardButton("‚ÑπÔ∏è –ò–Ω—Ñ–æ" if user_lang == 'ru' else "‚ÑπÔ∏è Info", callback_data=f"info:{model_id}")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥" if user_lang == 'ru' else "‚¨ÖÔ∏è Back", callback_data=f"model:{model_id}")]
                ]
                
                try:
                    await query.edit_message_text(
                        text=example_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return SELECTING_MODEL
                except Exception as e:
                    logger.error(f"Error showing example from catalog: {e}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–∏–º–µ—Ä–∞", show_alert=True)
                    return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            model = get_model_by_id(model_id)
            
            if not model:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –º–æ–¥–µ–ª—å
            try:
                from kie_models import normalize_model_for_api
                normalized = normalize_model_for_api(model)
            except:
                normalized = model
            
            user_lang = get_user_language(user_id)
            input_schema = normalized.get('input_schema') or normalized.get('input_params', {})
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞
            example_text = f"üìù <b>–ü—Ä–∏–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è {normalized.get('title', model_id)}</b>\n\n"
            example_text += f"<b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
            
            import json
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–∏–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ö–µ–º—ã
            example_params = {}
            for param_name, param_type in input_schema.items():
                if param_type == 'string':
                    if 'prompt' in param_name.lower():
                        example_params[param_name] = "–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"
                    elif 'url' in param_name.lower():
                        example_params[param_name] = "https://example.com/image.jpg"
                    else:
                        example_params[param_name] = "–ø—Ä–∏–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏—è"
                elif param_type == 'array':
                    example_params[param_name] = ["https://example.com/image1.jpg"]
                else:
                    example_params[param_name] = "–ø—Ä–∏–º–µ—Ä"
            
            example_text += f"<code>{json.dumps(example_params, indent=2, ensure_ascii=False)}</code>\n\n"
            example_text += f"üí° <b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b>\n{normalized.get('help', '–°–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –º–æ–¥–µ–ª–∏')}"
            
            keyboard = [
                [InlineKeyboardButton("‚úÖ –ù–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é", callback_data=f"start:{model_id}")],
                [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª–∏", callback_data=f"model:{model_id}")]
            ]
            
            await query.edit_message_text(
                text=example_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_MODEL
        
        # Handle info: callback - shows detailed model information
        if data.startswith("info:"):
            try:
                await query.answer()
            except:
                pass
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1]
            user_lang = get_user_language(user_id)
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.kie_catalog import get_model as get_model_from_catalog
            catalog_model = get_model_from_catalog(model_id)
            
            if catalog_model:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                from app.helpers.models_menu import build_model_card_text
                card_text, keyboard_markup = build_model_card_text(catalog_model, 0, user_lang)
                try:
                    await query.edit_message_text(
                        card_text,
                        reply_markup=keyboard_markup,
                        parse_mode='HTML'
                    )
                    return SELECTING_MODEL
                except Exception as e:
                    logger.error(f"Error showing model info: {e}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –º–æ–¥–µ–ª–∏", show_alert=True)
                    return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            model = get_model_by_id(model_id)
            if not model:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default="‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –º–æ–¥–µ–ª—å
            try:
                from kie_models import normalize_model_for_api
                normalized = normalize_model_for_api(model)
            except:
                normalized = model
            
            user_lang = get_user_language(user_id)
            input_schema = normalized.get('input_schema') or normalized.get('input_params', {})
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥–µ–ª–∏
            if user_lang == 'ru':
                info_text = (
                    f"‚ÑπÔ∏è <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏: {normalized.get('title', model_id)}</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                )
            else:
                info_text = (
                    f"‚ÑπÔ∏è <b>Model Information: {normalized.get('title', model_id)}</b>\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                )
            
            if normalized.get('description'):
                info_text += f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{normalized.get('description')}\n\n"
            
            if input_schema:
                if user_lang == 'ru':
                    info_text += f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
                else:
                    info_text += f"‚öôÔ∏è <b>Parameters:</b>\n"
                
                for param_name, param_info in input_schema.items():
                    if isinstance(param_info, dict):
                        param_type = param_info.get('type', 'string')
                        param_desc = param_info.get('description', '')
                        required = param_info.get('required', False)
                        req_text = " (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π)" if required else " (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π)"
                        if user_lang != 'ru':
                            req_text = " (required)" if required else " (optional)"
                        info_text += f"‚Ä¢ <b>{param_name}</b>: {param_type}{req_text}\n"
                        if param_desc:
                            info_text += f"  {param_desc}\n"
                    else:
                        info_text += f"‚Ä¢ <b>{param_name}</b>: {param_info}\n"
            
            if normalized.get('help'):
                info_text += f"\nüí° <b>–°–æ–≤–µ—Ç:</b>\n{normalized.get('help')}\n"
            
            keyboard = [
                [InlineKeyboardButton("üöÄ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" if user_lang == 'ru' else "üöÄ Generate", callback_data=f"select_model:{model_id}")],
                [InlineKeyboardButton("üì∏ –ü—Ä–∏–º–µ—Ä" if user_lang == 'ru' else "üì∏ Example", callback_data=f"example:{model_id}")],
                [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥" if user_lang == 'ru' else "‚¨ÖÔ∏è Back", callback_data=f"model:{model_id}")]
            ]
            
            await query.edit_message_text(
                text=info_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_MODEL
        
        # Handle model: callback - shows model card with "Start" button (canonical format for tests)
        if data.startswith("model:") or data.startswith("modelk:"):
            try:
                await query.answer()
            except:
                pass
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
            user_lang = get_user_language(user_id)
            
            try:
                from app.helpers.models_menu_handlers import handle_model_callback
                success = await handle_model_callback(query, user_id, user_lang, data)
                
                if success:
                    return SELECTING_MODEL
                else:
                    return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in handle_model_callback (second handler): {e}", exc_info=True)
                # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
                pass
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            parts = data.split(":", 1)
            if len(parts) < 2:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_invalid_model', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"), show_alert=True)
                return ConversationHandler.END
            
            model_id = parts[1] if len(parts) > 1 else None
            if not model_id:
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑—Ä–µ—à–∏—Ç—å —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import resolve_model_id_from_callback
                model_id = resolve_model_id_from_callback(data)
            
            if not model_id:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default=f"‚ùå –ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            logger.info(f"Model card requested: model_id={model_id}, user_id={user_id}")
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            from app.kie_catalog import get_model as get_model_from_catalog
            catalog_model = get_model_from_catalog(model_id)
            
            if catalog_model:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥
                from app.helpers.models_menu import build_model_card_text
                card_text, keyboard_markup = build_model_card_text(catalog_model, 0, user_lang)
                try:
                    await query.edit_message_text(
                        card_text,
                        reply_markup=keyboard_markup,
                        parse_mode='HTML'
                    )
                    return SELECTING_MODEL
                except Exception as e:
                    logger.error(f"Error showing model card: {e}", exc_info=True)
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –º–æ–¥–µ–ª–∏", show_alert=True)
                    return ConversationHandler.END
            
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—ã–π –∫–æ–¥
            # Get model from registry
            model_info = get_model_by_id_from_registry(model_id)
            if not model_info:
                user_lang = get_user_language(user_id)
                await query.answer(t('error_model_not_found', lang=user_lang, default=f"‚ùå –ú–æ–¥–µ–ª—å {model_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"), show_alert=True)
                return ConversationHandler.END
            
            # Check if model is coming soon
            if model_info.get('coming_soon', False):
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                error_msg = t('error_model_unavailable', lang=user_lang) or "–ú–æ–¥–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"
                try:
                    await query.edit_message_text(
                        error_msg,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                except Exception as edit_error:
                    logger.warning(f"Could not edit message for coming_soon model: {edit_error}")
                    try:
                        await query.message.reply_text(error_msg, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
                        try:
                            await query.message.delete()
                        except:
                            pass
                    except:
                        await query.answer(error_msg, show_alert=True)
                return ConversationHandler.END
            
            # Show model card with info and "Start" button
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            user_lang = get_user_language(user_id)
            
            is_admin_check = get_is_admin(user_id) if user_id is not None else is_admin
            min_price = get_from_price_value(model_id)
            price_text = get_model_price_text(model_id, None, is_admin_check, user_id)
            try:
                from app.services.pricing_service import get_model_price_info
                from app.config import get_settings

                settings = get_settings()
                mode_index = _resolve_mode_index(model_id, {}, user_id)
                price_info = get_model_price_info(model_id, mode_index, settings, is_admin=is_admin_check)
                trace_event(
                    "info",
                    correlation_id,
                    event="PRICE_CALC",
                    stage="PRICE_CALC",
                    update_type="callback",
                    action="SELECT_MODEL",
                    action_path=build_action_path(data),
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    model_id=model_id,
                    official_usd=price_info.get("official_usd") if price_info else None,
                    rate=price_info.get("usd_to_rub") if price_info else None,
                    multiplier=price_info.get("price_multiplier") if price_info else None,
                    price_rub=min_price,
                    is_admin=is_admin_check,
                    pricing_source="catalog",
                    always_fields=[
                        "model_id",
                        "official_usd",
                        "rate",
                        "multiplier",
                        "price_rub",
                        "is_admin",
                        "pricing_source",
                    ],
                )
            except Exception as price_exc:
                logger.debug("Pricing trace skipped: %s", price_exc)
            
            # Format model card
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            model_category = model_info.get('category', '–û–±—â–µ–µ')
            
            model_info_text = (
                f"{model_emoji} <b>{model_name}</b>\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            
            if model_category:
                model_info_text += f"üìÅ <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {model_category}\n"
            
            if model_desc:
                model_info_text += f"\nüìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n{model_desc}\n\n"
            
            model_info_text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            model_info_text += f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_text}\n\n"
            
            # Build keyboard with "Start" button
            keyboard = [
                [InlineKeyboardButton("üöÄ –°—Ç–∞—Ä—Ç", callback_data=f"select_model:{model_id}")],
                [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
            ]
            
            # Try to edit message, fallback to reply if edit fails
            try:
                await query.edit_message_text(
                    model_info_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
            except Exception as edit_error:
                logger.warning(f"Could not edit message in model: handler: {edit_error}, sending new message")
                try:
                    await query.message.reply_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    try:
                        await query.message.delete()
                    except:
                        pass
                except Exception as send_error:
                    logger.error(f"Could not send new message in model: handler: {send_error}", exc_info=True)
                    await query.answer(t('error_try_start', lang=user_lang, default="‚ùå –û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start"), show_alert=True)
            
            return ConversationHandler.END
        
        mode_selected = False
        if data.startswith("select_mode:"):
            parts = data.split(":")
            if len(parts) < 3:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ä–µ–∂–∏–º–∞", show_alert=True)
                return ConversationHandler.END
            model_id = parts[1]
            try:
                mode_index = int(parts[2])
            except ValueError:
                await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ä–µ–∂–∏–º", show_alert=True)
                return ConversationHandler.END
            if user_id not in user_sessions:
                user_sessions[user_id] = {}
            from app.kie_catalog import get_model as get_catalog_model

            model_spec = get_catalog_model(model_id)
            model_gen_type = _derive_model_gen_type(model_spec)
            mode_quote = _resolve_mode_price_quote(model_id, mode_index, model_gen_type)
            if not mode_quote:
                user_lang = get_user_language(user_id)
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update_id,
                    action="pricing_miss",
                    action_path=build_action_path(data),
                    model_id=model_id,
                    gen_type=model_gen_type,
                    stage="MODE_SELECTION",
                    outcome="blocked",
                    error_code="NO_PRICE_FOR_PARAMS",
                    fix_hint="–î–æ–±–∞–≤—å—Ç–µ SKU/–º–∞–ø–ø–∏–Ω–≥ –∏–ª–∏ —Å–∫—Ä–æ–π—Ç–µ –ø—Ä–µ—Å–µ—Ç.",
                    param={
                        "mode_index": mode_index,
                        "params": {},
                    },
                )
                blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                await query.edit_message_text(blocked_text, parse_mode="HTML")
                return ConversationHandler.END
            user_sessions[user_id]["mode_index"] = mode_index
            _prefill_params_from_quote(user_sessions[user_id], model_id, mode_quote)
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
                update_id=update_id,
                action="MODE_SELECTED",
                action_path=build_action_path(data),
                model_id=model_id,
                param={"mode_index": mode_index},
                outcome="selected",
            )
            data = f"select_model:{model_id}"
            mode_selected = True

        if data.startswith("sku:") or data.startswith("sk:"):
            await query.answer()
            from app.pricing.ssot_catalog import get_sku_by_id

            session = ensure_session_cached(context, session_store, user_id, update_id)
            sku_id, parsed_params = _parse_sku_callback_data(data)
            if sku_id:
                session["sku_id"] = sku_id
            if parsed_params:
                session["prefill_params"] = dict(parsed_params)
            sku = get_sku_by_id(sku_id) if sku_id else None
            if not sku:
                user_lang = get_user_language(user_id)
                await query.edit_message_text(
                    "‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –æ–ø—Ü–∏—è" if user_lang == "ru" else "‚ùå Invalid free option",
                )
                return ConversationHandler.END
            session["prefill_params"] = dict(sku.params)
            session["sku_id"] = sku.sku_id
            data = f"select_model:{canonicalize_model_id(sku.model_id)}"

        # Handle select_model: callback - starts generation flow directly (legacy, still supported)
        # Also handles start: callback (redirects to select_model:)
        if data.startswith("select_model:") or data.startswith("sel:"):
            # Handle short format sel: -> select_model:
            if data.startswith("sel:"):
                parts = data.split(":", 1)
                if len(parts) >= 2:
                    model_id = parts[1]
                    # Try to find full model_id by prefix (for backward compatibility)
                    # In most cases, sel: prefix means it was truncated, so we need to search
                    models = get_models_sync()
                    matching_models = [m for m in models if m.get('id', '').startswith(model_id)]
                    if matching_models:
                        model_id = canonicalize_model_id(matching_models[0].get('id'))
                        data = f"select_model:{model_id}"
                    else:
                        data = f"select_model:{canonicalize_model_id(model_id)}"
            
            # üî• MAXIMUM LOGGING: select_model entry
            logger.debug(f"üî•üî•üî• SELECT_MODEL START: user_id={user_id}, data={data}")
            reset_session_context(
                user_id,
                reason="select_model",
                clear_gen_type=False,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            if not mode_selected and user_id in user_sessions:
                user_sessions[user_id].pop("mode_index", None)
            
            # Answer callback immediately to show button was pressed
            try:
                await query.answer()
                logger.info(f"‚úÖ Query answered for select_model: user_id={user_id}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Failed to answer query: {e}")
            
            parts = data.split(":", 1)
            if len(parts) < 2:
                logger.error(f"‚ùå Invalid select_model format: data={data}, user_id={user_id}")
                try:
                    await query.answer("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞", show_alert=True)
                except:
                    pass
                try:
                    await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                except:
                    try:
                        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞.")
                    except:
                        pass
                return ConversationHandler.END
            model_id = canonicalize_model_id(parts[1])
            logger.debug(f"üî•üî•üî• SELECT_MODEL: Parsed model_id={model_id}, user_id={user_id}")
            
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –Ω–æ–≤–æ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            model_info = None
            catalog_model = None
            try:
                from app.kie_catalog import get_model as get_model_from_catalog
                catalog_model = get_model_from_catalog(model_id)
                if catalog_model:
                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º catalog_model –≤ —Ñ–æ—Ä–º–∞—Ç model_info –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    model_info = {
                        'id': catalog_model.id,
                        'name': catalog_model.title_ru,
                        'emoji': 'ü§ñ',  # –ë—É–¥–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –ø–æ–∑–∂–µ
                        'description': catalog_model.title_ru,
                        'category': catalog_model.type,
                        'coming_soon': False
                    }
                    logger.info(f"‚úÖ SELECT_MODEL: Found in catalog: model_id={model_id}, name={catalog_model.title_ru}, user_id={user_id}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è SELECT_MODEL: Error loading from catalog: {e}, trying registry")
            
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ –∫–∞—Ç–∞–ª–æ–≥–µ, –ø—Ä–æ–±—É–µ–º —Å—Ç–∞—Ä—ã–π —Ä–µ–µ—Å—Ç—Ä
            if not model_info:
                model_info = get_model_by_id_from_registry(model_id)
                logger.debug(f"üî•üî•üî• SELECT_MODEL: Model lookup result: found={bool(model_info)}, model_name={model_info.get('name', 'N/A') if model_info else 'N/A'}, user_id={user_id}")
            
            if not model_info:
                logger.error(f"‚ùå‚ùå‚ùå MODEL NOT FOUND: model_id={model_id}, user_id={user_id}")
                user_lang = get_user_language(user_id)
                error_msg = t('error_model_not_found', lang=user_lang, default=f"‚ùå –ú–æ–¥–µ–ª—å {model_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                try:
                    await query.edit_message_text(error_msg)
                except:
                    try:
                        await query.message.reply_text(error_msg)
                    except:
                        await query.answer(error_msg, show_alert=True)
                return ConversationHandler.END
            
            # Check if model is coming soon - –ù–ï –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –º–µ–Ω—é
            if model_info.get('coming_soon', False):
                user_lang = get_user_language(user_id)
                # –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º "COMING SOON" - –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –º–µ–Ω—é
                keyboard = [
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                
                await query.edit_message_text(
                    t('error_model_unavailable', lang=user_lang) or "–ú–æ–¥–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END

            # Load model spec early (needed for multi-mode selection)
            from app.kie_catalog import get_model
            model_spec = get_model(model_id)
            if not model_spec:
                await query.edit_message_text(
                    "‚ùå <b>–ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–∞—Ç–∞–ª–æ–≥–µ</b>",
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            from app.pricing.coverage_guard import (
                DISABLED_REASON_NO_PRICE,
                get_disabled_model_info,
                get_pricing_preflight_status,
            )
            preflight_status = get_pricing_preflight_status()
            if preflight_status.get("degraded"):
                user_lang = get_user_language(user_id)
                pricing_error = preflight_status.get("error") or "unknown"
                message_text = (
                    "‚ö†Ô∏è <b>–ü—Ä–∞–π—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</b>\n\n"
                    "–ú—ã –Ω–µ —É—Å–ø–µ–ª–∏ –ø—Ä–æ–≥—Ä–µ—Ç—å –ø—Ä–∞–π—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å.\n\n"
                    f"–õ–æ–≥: <code>{correlation_id}</code>"
                    if user_lang == "ru"
                    else (
                        "‚ö†Ô∏è <b>Pricing temporarily unavailable</b>\n\n"
                        "We are still warming up pricing data. Please try again later.\n\n"
                        f"Log: <code>{correlation_id}</code>"
                    )
                )
                keyboard = InlineKeyboardMarkup(
                    [[InlineKeyboardButton("–ú–æ–¥–µ–ª–∏/–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]]
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update_id,
                    action="PRICING_PREFLIGHT_DEGRADED",
                    action_path="select_model",
                    model_id=model_id,
                    stage="MODEL_SELECT",
                    outcome="blocked",
                    error_code="PRICING_PREFLIGHT_DEGRADED",
                    param={"error": pricing_error},
                )
                await query.edit_message_text(message_text, reply_markup=keyboard, parse_mode="HTML")
                return ConversationHandler.END
            from app.ux.model_visibility import (
                evaluate_model_visibility,
                STATUS_BLOCKED_NO_PRICE,
                STATUS_READY_VISIBLE,
            )
            visibility = evaluate_model_visibility(model_id)
            if visibility.status != STATUS_READY_VISIBLE:
                user_lang = get_user_language(user_id)
                disabled_info = get_disabled_model_info(model_id)
                if visibility.status == STATUS_BLOCKED_NO_PRICE or (
                    disabled_info and disabled_info.reason == DISABLED_REASON_NO_PRICE
                ):
                    message_text = (
                        "–ú–æ–¥–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–∞: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∞–π—Å –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. "
                        "–í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å."
                    )
                    keyboard = InlineKeyboardMarkup(
                        [[InlineKeyboardButton("–ú–æ–¥–µ–ª–∏/–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")]]
                    )
                    log_structured_event(
                        correlation_id=correlation_id,
                        user_id=user_id,
                        chat_id=query.message.chat_id if query.message else None,
                        update_id=update_id,
                        action="MODEL_DISABLED",
                        action_path="select_model",
                        model_id=model_id,
                        stage="MODEL_SELECT",
                        outcome="blocked",
                        error_code=DISABLED_REASON_NO_PRICE,
                        param={
                            "issues": disabled_info.issues if disabled_info else visibility.issues,
                            "status": visibility.status,
                        },
                    )
                    await query.edit_message_text(message_text, reply_markup=keyboard)
                    return ConversationHandler.END

                issues = "\n".join(f"‚Ä¢ {issue}" for issue in visibility.issues) if visibility.issues else ""
                if user_lang == "ru":
                    blocked_text = (
                        "‚õîÔ∏è <b>–ú–æ–¥–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</b>\n\n"
                        f"–ü—Ä–∏—á–∏–Ω–∞: <code>{visibility.status}</code>\n"
                        f"{issues or '‚Ä¢ –ü—Ä–∏—á–∏–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞'}"
                    )
                else:
                    blocked_text = (
                        "‚õîÔ∏è <b>Model unavailable</b>\n\n"
                        f"Reason: <code>{visibility.status}</code>\n"
                        f"{issues or '‚Ä¢ No details available'}"
                    )
                await query.edit_message_text(blocked_text, parse_mode="HTML")
                return ConversationHandler.END

            session = ensure_session_cached(context, session_store, user_id, update_id)
            session["model_id"] = model_id
            session["model_info"] = model_info
            session["active_model_id"] = model_id
            session_gen_type = _resolve_session_gen_type(session, None)
            model_gen_type = _derive_model_gen_type(model_spec)
            if model_gen_type:
                session["active_gen_type"] = model_gen_type
                session["gen_type"] = model_gen_type
            registry_gen_type = session.get("gen_type") or session_gen_type
            registry_entry = await _get_registry_model_entry(
                model_id,
                correlation_id=correlation_id,
                user_id=user_id,
                gen_type=registry_gen_type,
            )
            if not registry_entry and model_gen_type and registry_gen_type != model_gen_type:
                registry_entry = await _get_registry_model_entry(
                    model_id,
                    correlation_id=correlation_id,
                    user_id=user_id,
                    gen_type=model_gen_type,
                )
            if not registry_entry and registry_gen_type is not None:
                registry_entry = await _get_registry_model_entry(
                    model_id,
                    correlation_id=correlation_id,
                    user_id=user_id,
                    gen_type=None,
                )
            registry_kie_model = registry_entry.get("kie_model") if registry_entry else None
            if not registry_entry or (
                registry_kie_model and registry_kie_model != model_spec.kie_model
            ):
                user_lang = get_user_language(user_id)
                notice_text = (
                    "üîÑ <b>–ú–æ–¥–µ–ª—å –æ–±–Ω–æ–≤–∏–ª–∞—Å—å –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</b>\n\n"
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ –∞–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞."
                    if user_lang == "ru"
                    else "üîÑ <b>Model updated or unavailable</b>\n\nPlease choose from the current list."
                )
                gen_type_hint = (
                    session.get("active_gen_type")
                    or session.get("gen_type")
                    or _derive_model_gen_type(model_spec)
                )
                loading_text = (
                    f"{notice_text}\n\n‚è≥ <b>–û–±–Ω–æ–≤–ª—è—é –º–µ–Ω—é...</b>"
                    if user_lang == "ru"
                    else f"{notice_text}\n\n‚è≥ <b>Refreshing menu...</b>"
                )
                await _safe_edit_or_reply(query, loading_text, parse_mode="HTML")
                if gen_type_hint:
                    _create_background_task(
                        _render_gen_type_menu(
                            query=query,
                            user_id=user_id,
                            gen_type=_normalize_gen_type(gen_type_hint) or gen_type_hint,
                            correlation_id=correlation_id,
                            update_id=update_id,
                            notice_text=notice_text,
                        ),
                        action="render_gen_type_menu_refresh",
                    )
                else:
                    reply_markup = build_back_to_menu_keyboard(user_lang)
                    await _safe_edit_or_reply(query, notice_text, reply_markup=reply_markup)
                return ConversationHandler.END

            if session_gen_type and model_gen_type and session_gen_type != model_gen_type:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update_id,
                    action="GEN_TYPE_AUTO_SWITCH_ON_SELECT",
                    action_path="select_model",
                    model_id=model_id,
                    gen_type=model_gen_type,
                    stage="MODEL_SELECT",
                    outcome="auto_switched",
                    param={
                        "previous_gen_type": session_gen_type,
                        "new_gen_type": model_gen_type,
                    },
                )
                session["active_gen_type"] = model_gen_type
                session["gen_type"] = model_gen_type

            mode_index = user_sessions.get(user_id, {}).get("mode_index")
            if model_spec.modes and len(model_spec.modes) > 1 and mode_index is None:
                user_balance = await get_user_balance_async(user_id)
                sku_id = session.get("sku_id", "")
                is_free_available = await is_free_generation_available(user_id, sku_id)
                is_admin_check = get_is_admin(user_id) if user_id is not None else False
                min_price: Optional[float] = None
                session["model_id"] = model_id
                session["model_info"] = model_info
                session["active_model_id"] = model_id
                if model_gen_type:
                    session["active_gen_type"] = model_gen_type
                    session["gen_type"] = model_gen_type
                session["waiting_for"] = "mode_index"
                user_lang = get_user_language(user_id)
                model_name = model_info.get("name", model_id)
                available_mode_entries: List[tuple[int, Any]] = []
                for idx, mode in enumerate(model_spec.modes):
                    mode_quote = _resolve_mode_price_quote(model_id, idx, model_gen_type)
                    if not mode_quote:
                        log_structured_event(
                            correlation_id=correlation_id,
                            user_id=user_id,
                            chat_id=query.message.chat_id if query.message else None,
                            update_id=update_id,
                            action="pricing_miss",
                            action_path="mode_selection",
                            model_id=model_id,
                            gen_type=model_gen_type,
                            stage="MODE_SELECTION",
                            outcome="blocked",
                            error_code="NO_PRICE_FOR_PARAMS",
                            fix_hint="–î–æ–±–∞–≤—å—Ç–µ SKU/–º–∞–ø–ø–∏–Ω–≥ –∏–ª–∏ —Å–∫—Ä–æ–π—Ç–µ –ø—Ä–µ—Å–µ—Ç.",
                            param={
                                "mode_index": idx,
                                "mode_notes": getattr(mode, "notes", None),
                                "params": {},
                            },
                        )
                        continue
                    try:
                        mode_price = float(mode_quote.price_rub)
                        min_price = mode_price if min_price is None else min(min_price, mode_price)
                    except Exception:
                        pass
                    available_mode_entries.append((idx, mode))

                if not available_mode_entries:
                    blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                    await query.edit_message_text(blocked_text, parse_mode="HTML")
                    return ConversationHandler.END
                if (
                    not is_admin_check
                    and not is_free_available
                    and min_price is not None
                    and user_balance < min_price
                ):
                    await query.edit_message_text(
                        _build_insufficient_funds_text(user_lang, min_price, user_balance),
                        reply_markup=_build_insufficient_funds_keyboard(user_lang),
                    )
                    return ConversationHandler.END
                await query.edit_message_text(
                    _build_mode_selection_text(model_name, user_lang),
                    reply_markup=_build_mode_selection_keyboard(model_id, available_mode_entries, user_lang),
                    parse_mode="HTML",
                )
                return ConversationHandler.END

            input_params, required_params, forced_media_required = _apply_media_required_overrides(
                model_spec,
                model_spec.schema_properties or {},
            )
            
            # Check user balance and calculate available generations
            user_balance = await get_user_balance_async(user_id)
            is_admin = get_is_admin(user_id)
            
            # IMPORTANT: Use get_is_admin() if user_id is available to respect ADMIN_ID list.
            is_admin_check = get_is_admin(user_id) if user_id is not None else is_admin
            
            # Check for free generations for free models
            sku_id = session.get("sku_id", "")
            is_free_available = await is_free_generation_available(user_id, sku_id)
            from app.pricing.free_policy import is_sku_free_daily
            remaining_free = (
                await get_user_free_generations_remaining(user_id)
                if is_sku_free_daily(sku_id)
                else 0
            )

            price_value, price_line, price_note = _resolve_price_for_display(
                session,
                model_id=model_id,
                mode_index=_resolve_mode_index(model_id, session.get("params", {}), user_id),
                gen_type=session.get("gen_type"),
                params=session.get("params", {}),
                user_lang=user_lang,
                is_admin=is_admin_check,
                correlation_id=correlation_id,
                update_id=update_id,
                action_path="model_select_info",
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            if price_value is None:
                blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                await query.edit_message_text(blocked_text, parse_mode="HTML")
                return ConversationHandler.END
            
            # Calculate how many generations available
            if is_admin:
                available_count = "–ë–µ–∑–ª–∏–º–∏—Ç"
            elif is_free_available:
                # For free models with free generations, show free count
                available_count = f"üéÅ {remaining_free} –±–µ—Å–ø–ª–∞—Ç–Ω–æ –≤ –¥–µ–Ω—å"
            elif price_value is not None and price_value > 0 and user_balance >= price_value:
                available_count = int(user_balance / price_value)
            else:
                available_count = 0
            
            # Show model info with premium formatting
            model_name = model_info.get('name', model_id)
            model_emoji = model_info.get('emoji', 'ü§ñ')
            model_desc = model_info.get('description', '')
            model_category = model_info.get('category', '–û–±—â–µ–µ')
            
            # Check if new user for hints
            is_new = await is_new_user_async(user_id)
            
            model_info_text = (
                _build_model_card(model_spec, model_info, required_params, user_lang)
                + "\n\n"
                + "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )
            free_counter_line = ""
            try:
                free_counter_line = await get_free_counter_line(
                    user_id,
                    user_lang=user_lang,
                    correlation_id=correlation_id,
                    action_path="model_select_info",
                    sku_id=sku_id,
                )
            except Exception as exc:
                logger.warning("Failed to resolve free counter line: %s", exc)
            
            balance_label = "–ë–∞–ª–∞–Ω—Å" if user_lang == "ru" else "Balance"
            balance_line = f"üíµ <b>{balance_label}:</b> {format_rub_amount(user_balance)}"
            model_info_text += f"{balance_line}\n{price_line}\n"
            if price_note:
                model_info_text += f"{price_note}\n"
            
            # Add hint for new users
            if is_new and sku_id in FREE_TOOL_SKU_IDS:
                model_info_text += (
                    f"\nüí° <b>–û—Ç–ª–∏—á–Ω–æ –¥–ª—è –Ω–∞—á–∞–ª–∞!</b>\n"
                    f"–≠—Ç–∞ –º–æ–¥–µ–ª—å –±–µ—Å–ø–ª–∞—Ç–Ω–∞ –¥–ª—è –ø–µ—Ä–≤—ã—Ö {FREE_GENERATIONS_PER_DAY} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤ –¥–µ–Ω—å.\n"
                    f"–ü—Ä–æ—Å—Ç–æ –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å, –∏ –Ω–∞–∂–º–∏—Ç–µ \"–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å\"!\n\n"
                )
            
            # –ö–†–ò–¢–ò–ß–ù–û: –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            if is_admin:
                model_info_text += (
                    f"‚úÖ <b>–î–æ—Å—Ç—É–ø:</b> <b>–ë–µ–∑–ª–∏–º–∏—Ç</b>\n"
                    f"üëë <b>–°—Ç–∞—Ç—É—Å:</b> –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä\n\n"
                )
            else:
                # –î–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É –∏ –±–∞–ª–∞–Ω—Å
                if is_free_available:
                    model_info_text += (
                        f"üéÅ <b>–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:</b> {remaining_free}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å\n"
                    )
                    if price_value is not None and price_value > 0 and user_balance >= price_value:
                        paid_count = int(user_balance / price_value)
                        model_info_text += f"üí≥ <b>–ü–ª–∞—Ç–Ω—ã—Ö:</b> {paid_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                    model_info_text += "\n"
                elif available_count > 0:
                    model_info_text += (
                        f"‚úÖ <b>–î–æ—Å—Ç—É–ø–Ω–æ:</b> {available_count} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n"
                        "\n"
                    )
                else:
                    # Not enough balance - show warning
                    model_info_text += (
                        f"\n‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤</b>\n\n"
                        f"{balance_line}\n"
                        f"{price_line}\n\n"
                        f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"
                    )

                    if free_counter_line:
                        model_info_text = _append_free_counter_text(model_info_text, free_counter_line)
                    
                    keyboard = [
                        [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
                        [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                    ]
                    
                    await query.edit_message_text(
                        model_info_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return ConversationHandler.END

            if free_counter_line:
                model_info_text = _append_free_counter_text(model_info_text, free_counter_line)
            
            # Check balance before starting generation (but allow free generations)
            if not is_admin and not is_free_available and price_value is not None and user_balance < price_value:
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_top_up_balance', lang=user_lang), callback_data="topup_balance")],
                    [InlineKeyboardButton(t('btn_back_to_models', lang=user_lang), callback_data="back_to_menu")]
                ]
                
                needed = price_value - user_balance
                needed_str = format_rub_amount(needed)
                remaining_free = await get_user_free_generations_remaining(user_id)
                
                if user_lang == 'ru':
                    insufficient_msg = (
                        f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"{balance_line}\n"
                        f"{price_line}\n"
                        f"‚ùå <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç:</b> {needed_str}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                        f"‚Ä¢ –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π ({remaining_free} –¥–æ—Å—Ç—É–ø–Ω–æ)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–≥–∞ –∏ –ø–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å—ã\n\n"
                        f"üîÑ –ü–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–Ω–æ–≤–∞."
                    )
                else:
                    insufficient_msg = (
                        f"‚ùå <b>Insufficient Funds for Generation</b>\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"{balance_line}\n"
                        f"{price_line}\n"
                        f"‚ùå <b>Need:</b> {needed_str}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>What to do:</b>\n"
                        f"‚Ä¢ Top up balance via button below\n"
                    )
                    
                    if remaining_free > 0:
                        insufficient_msg += f"‚Ä¢ Use free models generations ({remaining_free} available)\n"
                    
                    insufficient_msg += (
                        f"‚Ä¢ Invite a friend and get bonuses\n\n"
                        f"üîÑ After topping up, try generation again."
                    )
                
                await query.edit_message_text(
                    insufficient_msg,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
            
            # Store selected model
            logger.debug(f"üî•üî•üî• SELECT_MODEL: Created new session for user_id={user_id}")
            session['model_id'] = model_id
            session['model_info'] = model_info
            session['active_model_id'] = model_id
            session['active_gen_type'] = model_gen_type or session_gen_type or _resolve_session_gen_type(None, model_spec)
            session['gen_type'] = session['active_gen_type']
            set_session_context(
                user_id,
                to_context=UI_CONTEXT_WIZARD,
                reason="select_model",
                active_gen_type=session.get("active_gen_type"),
                active_model_id=model_id,
                correlation_id=correlation_id,
                update_id=update_id,
                chat_id=query.message.chat_id if query.message else None,
            )
            logger.debug(f"üî•üî•üî• SELECT_MODEL: Stored model in session: model_id={model_id}, user_id={user_id}, session_keys={list(session.keys())}")

            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
                update_id=update.update_id,
                action="MODEL_SELECT",
                action_path=build_action_path(data),
                model_id=model_id,
                gen_type=session.get("gen_type"),
                stage="MODEL_SELECT",
                outcome="selected",
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
                update_id=update.update_id,
                action="MODEL_SELECTED",
                action_path=build_action_path(data),
                model_id=model_id,
                gen_type=session.get("gen_type"),
                stage="MODEL_SELECT",
                outcome="selected",
            )

            logger.info(
                "‚úÖ SELECT_MODEL: Using SSOT schema: count=%s, keys=%s, user_id=%s",
                len(input_params),
                list(input_params.keys()),
                user_id,
            )
            input_params = _apply_unified_param_defaults(
                input_params,
                model_spec=model_spec,
                session_gen_type=session.get("gen_type") or model_spec.model_type,
            )

            # Store session data
            session['params'] = {}
            session['properties'] = input_params
            session['required'] = required_params
            session['required_original'] = (model_spec.schema_required or []).copy()
            session['required_forced_media'] = forced_media_required
            session['current_param'] = None
            session['model_type'] = model_spec.model_type or model_spec.model_mode
            session['model_mode'] = model_spec.model_mode
            session['param_history'] = []
            session['model_spec'] = model_spec
            session['param_order'] = _build_param_order(input_params)
            session['ssot_conflicts'] = _detect_ssot_conflicts(model_spec, input_params)
            session['optional_media_params'] = []
            session['image_ref_prompt'] = False
            session['skipped_params'] = set()
            mode_index = _resolve_mode_index(model_id, session.get("params"), user_id)
            _update_price_quote(
                session,
                model_id=model_id,
                mode_index=mode_index,
                gen_type=session.get("gen_type"),
                params=session.get("params", {}),
                correlation_id=correlation_id,
                update_id=update_id,
                action_path="select_model",
                user_id=user_id,
                chat_id=query.message.chat_id if query.message else None,
                is_admin=is_admin_check,
            )
            model_info.setdefault("input_params", input_params)
            if model_spec.model_type in {"text_to_image", "text_to_video", "text_to_audio", "text_to_speech", "text"}:
                if "image_input" in input_params or "image_urls" in input_params:
                    session['image_ref_prompt'] = True
            if "SSOT_CONFLICT_TEXT_MODEL_REQUIRES_IMAGE" in session['ssot_conflicts']:
                media_param = _first_required_media_param(input_params)
                if media_param:
                    session['optional_media_params'] = [media_param]
                    session['required'] = [
                        name for name in session['required'] if name != media_param
                    ]
            if session['ssot_conflicts']:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update.update_id,
                    action="SSOT_CONFLICT",
                    action_path="select_model",
                    model_id=model_id,
                    outcome="detected",
                    error_code="SSOT_CONFLICT_DETECTED",
                    fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –º–æ–¥–µ–ª—å–Ω—ã–π SSOT –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—è.",
                    param={"conflicts": session['ssot_conflicts']},
                )
            if forced_media_required:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=query.message.chat_id if query.message else None,
                    update_id=update.update_id,
                    action="MEDIA_REQUIRED_OVERRIDE",
                    action_path="select_model",
                    model_id=model_id,
                    gen_type=session.get("gen_type"),
                    stage="MODEL_SELECT",
                    outcome="forced",
                    param={"forced_media": forced_media_required},
                )
            logger.info(
                "‚úÖ SELECT_MODEL: Parameter order determined: %s, user_id=%s",
                session['param_order'],
                user_id,
            )

            if not input_params:
                return await send_confirmation_message(update, context, user_id, source="select_model")

            next_param_result = await start_next_parameter(update, context, user_id)
            if next_param_result is None:
                return await send_confirmation_message(update, context, user_id, source="select_model")
            return next_param_result
        
        # Handle confirm_generate as fallback (in case state didn't switch properly)
        if data == "confirm_generate":
            # Answer callback immediately
            try:
                await query.answer()
            except:
                pass
            
            logger.info(f"confirm_generate callback received in button_callback (fallback)")
            # Call confirm_generation function directly
            # üî¥ API CALL: confirm_generation –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å KIE API
            try:
                await confirm_generation(update, context)
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"‚ùå‚ùå‚ùå ERROR in confirm_generation fallback: {e}", exc_info=True)
                try:
                    user_lang = get_user_language(user_id) if user_id else 'ru'
                    error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
                    await query.answer(error_msg, show_alert=True)
                except Exception:
                    pass
                return ConversationHandler.END
    
    # If we get here and no handler matched, log and return END
    except Exception as e:
        logger.debug("button_callback exception: %s", e, exc_info=True)
        try:
            partner_id = os.getenv("BOT_INSTANCE_ID", "").strip() or None
            await handle_update_exception(
                update,
                context,
                e,
                stage="router",
                handler="button_callback",
                partner_id=partner_id,
            )
        except Exception:
            logger.debug("button_callback exception boundary failed", exc_info=True)
        return ConversationHandler.END
    
    # üî¥ FALLBACK - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö callback_data
    # –≠—Ç–æ –∑–∞—â–∏—Ç–∞ –æ—Ç —Å–±–æ–µ–≤ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è—Ö - –µ—Å–ª–∏ –∫–∞–∫–∞—è-—Ç–æ –∫–Ω–æ–ø–∫–∞ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞,
    # –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∏—Ç –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ –æ—à–∏–±–∫–∏
    # –í–ê–ñ–ù–û: –≠—Ç–æ—Ç –∫–æ–¥ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã—à–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
    
    logger.warning("‚ö†Ô∏è Unhandled callback_data detected")
    user_lang = "ru"
    correlation_id = None
    try:
        correlation_id = await handle_unknown_callback(
            update,
            context,
            data,
            partner_id=os.getenv("BOT_INSTANCE_ID", "").strip() or None,
        )
        user_lang = get_user_language(user_id) if user_id else "ru"
    except Exception:
        logger.debug("Unknown callback logging failed", exc_info=True)
    
    # –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, –¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ–º —á—Ç–æ –¥–µ–ª–∞—Ç—å
    try:
        fallback_text = (
            "–ö–Ω–æ–ø–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞, –æ—Ç–∫—Ä–æ–π –º–µ–Ω—é." if user_lang == "ru" else "Button outdated, open menu."
        )
        await query.answer(fallback_text, show_alert=False)
    except Exception:
        try:
            if context and query and query.id:
                await context.bot.answer_callback_query(query.id, text=fallback_text, show_alert=False)
        except Exception:
            pass

    try:
        await ensure_main_menu(update, context, source="unknown_callback", prefer_edit=False)
    except Exception:
        logger.debug("Unknown callback menu send failed", exc_info=True)
    return ConversationHandler.END


def _get_chat_id_from_update(update: Update) -> int | None:
    if hasattr(update, 'effective_chat') and update.effective_chat:
        return update.effective_chat.id
    if hasattr(update, 'message') and update.message:
        return update.message.chat_id
    if hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
        return update.callback_query.message.chat_id
    return None


def _get_step_info(session: dict, param_name: str, user_lang: str) -> str:
    param_order = session.get('param_order', [])
    if param_name in param_order:
        step_index = param_order.index(param_name) + 1
        total_steps = len(param_order)
        if user_lang == 'en':
            return f"Step {step_index}/{total_steps}"
        return f"–®–∞–≥ {step_index}/{total_steps}"
    return ""


def _get_param_example(param_name: str, param_info: dict, user_lang: str, enum_values: list | None = None) -> str:
    example = param_info.get('example')
    if not example and enum_values:
        example = enum_values[0]
    if not example and param_name == "prompt":
        example = "A cinematic night cityscape with neon lights" if user_lang == 'en' else "–§–æ—Ç–æ—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –∫–∏–±–µ—Ä–ø–∞–Ω–∫-–≥–æ—Ä–æ–¥ –Ω–æ—á—å—é"
    if not example:
        return ""
    prefix = "Example" if user_lang == 'en' else "–ü—Ä–∏–º–µ—Ä"
    return f"{prefix}: {example}"


def _get_param_format_hint(param_type: str, enum_values: list | None, user_lang: str) -> str:
    if enum_values:
        return "Format: choose from list" if user_lang == 'en' else "–§–æ—Ä–º–∞—Ç: –≤—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞"
    if param_type == "boolean":
        return "Format: yes/no" if user_lang == 'en' else "–§–æ—Ä–º–∞—Ç: –¥–∞/–Ω–µ—Ç"
    return "Format: text" if user_lang == 'en' else "–§–æ—Ä–º–∞—Ç: —Ç–µ–∫—Å—Ç"


def _humanize_param_name(param_name: str, user_lang: str) -> str:
    fallback = param_name.replace("_", " ").strip()
    if user_lang != "ru":
        return fallback.title() if fallback else param_name
    ru_map = {
        "prompt": "–¢–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞",
        "text": "–¢–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞",
        "image_size": "–†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è",
        "aspect_ratio": "–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω",
        "guidance_scale": "–°–∏–ª–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è",
        "enable_safety_checker": "–§–∏–ª—å—Ç—Ä –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏",
        "image_urls": "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
        "image_input": "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
        "audio_url": "–ê—É–¥–∏–æ",
        "audio_input": "–ê—É–¥–∏–æ",
        "video_url": "–í–∏–¥–µ–æ",
        "video_input": "–í–∏–¥–µ–æ",
    }
    return ru_map.get(param_name, fallback.capitalize() if fallback else param_name)


def _short_correlation_suffix(correlation_id: Optional[str]) -> str:
    if not correlation_id:
        return "corr-na"
    return correlation_id[-6:]


def _build_default_mode_label(index: int, user_lang: str) -> str:
    if user_lang == "ru":
        fallbacks = ["–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π", "–í—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ", "–ë—ã—Å—Ç—Ä—ã–π", "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π"]
    else:
        fallbacks = ["Standard", "High quality", "Fast", "Extra"]
    if index < len(fallbacks):
        return fallbacks[index]
    return fallbacks[-1]


def _resolve_mode_label(mode: Any, index: int, user_lang: str) -> str:
    title = getattr(mode, "title_ru", None)
    hint = getattr(mode, "short_hint_ru", None)
    if user_lang != "ru":
        title = getattr(mode, "notes", None) or getattr(mode, "title_ru", None)
        hint = getattr(mode, "notes", None)
    title = title or _build_default_mode_label(index, user_lang)
    if hint:
        return f"{title} ¬∑ {hint}"
    return title


def _summarize_required_inputs(
    required_params: List[str],
    properties: Dict[str, Any],
    user_lang: str,
) -> str:
    kinds: List[str] = []
    for param in required_params:
        if param in {"prompt", "text"}:
            kinds.append("text")
            continue
        media_kind = _get_media_kind(param)
        if media_kind:
            kinds.append(media_kind)
    if not kinds:
        if "prompt" in properties or "text" in properties:
            kinds.append("text")
    labels_ru = {
        "text": "–¢–µ–∫—Å—Ç",
        "image": "–ö–∞—Ä—Ç–∏–Ω–∫–∞",
        "video": "–í–∏–¥–µ–æ",
        "audio": "–ê—É–¥–∏–æ",
        "document": "–§–∞–π–ª",
    }
    labels_en = {
        "text": "Text",
        "image": "Image",
        "video": "Video",
        "audio": "Audio",
        "document": "File",
    }
    labels = labels_ru if user_lang == "ru" else labels_en
    ordered = []
    for kind in ["text", "image", "video", "audio", "document"]:
        if kind in kinds and kind not in ordered:
            ordered.append(kind)
    if not ordered:
        return ""
    if user_lang == "ru":
        return "–í—Ö–æ–¥—ã: " + ", ".join(labels[k] for k in ordered)
    return "Inputs: " + ", ".join(labels[k] for k in ordered)


def _resolve_output_type_label(model_spec: "ModelSpec", user_lang: str) -> str:
    output_ru = model_spec.output_type_ru or ""
    output_media = (model_spec.output_media_type or "").lower()
    fallback_ru = {
        "image": "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
        "video": "–í–∏–¥–µ–æ",
        "audio": "–ê—É–¥–∏–æ",
        "text": "–¢–µ–∫—Å—Ç",
        "document": "–§–∞–π–ª",
    }.get(output_media, "–§–∞–π–ª")
    fallback_en = {
        "image": "Image",
        "video": "Video",
        "audio": "Audio",
        "text": "Text",
        "document": "File",
    }.get(output_media, "File")
    if user_lang == "ru":
        return output_ru or fallback_ru
    return fallback_en


def _build_model_card(
    model_spec: "ModelSpec",
    model_info: Dict[str, Any],
    required_params: List[str],
    user_lang: str,
) -> str:
    name = model_info.get("name") or model_spec.title_ru or model_spec.id
    description_ru = model_spec.description_ru or "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É."
    inputs_line = _summarize_required_inputs(required_params, model_spec.schema_properties or {}, user_lang)
    output_label = _resolve_output_type_label(model_spec, user_lang)
    if user_lang == "ru":
        usage_line = "–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è: –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –≤—Ö–æ–¥—ã –∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å¬ª."
        card_parts = [
            f"ü™™ <b>–ö–∞—Ä—Ç–æ—á–∫–∞ –º–æ–¥–µ–ª–∏</b>",
            f"ü§ñ <b>{name}</b>",
            f"üìù {description_ru}",
        ]
        if inputs_line:
            card_parts.append(f"üì• {inputs_line}")
        card_parts.append(f"üì§ –†–µ–∑—É–ª—å—Ç–∞—Ç: {output_label}")
        card_parts.append(f"üí° {usage_line}")
        return "\n".join(card_parts)
    usage_line = "How to use: provide required inputs and tap ‚ÄúGenerate‚Äù."
    card_parts = [
        f"ü™™ <b>Model card</b>",
        f"ü§ñ <b>{name}</b>",
        f"üìù {description_ru}",
    ]
    if inputs_line:
        card_parts.append(f"üì• {inputs_line}")
    card_parts.append(f"üì§ Output: {output_label}")
    card_parts.append(f"üí° {usage_line}")
    return "\n".join(card_parts)


def _record_param_history(session: dict, param_name: str) -> None:
    history = session.setdefault('param_history', [])
    if not history or history[-1] != param_name:
        history.append(param_name)


def _get_settings_label(user_lang: str) -> str:
    return "‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã" if user_lang == 'ru' else "‚öôÔ∏è Parameters"


def _get_reset_step_label(user_lang: str) -> str:
    return "üîÑ –°–±—Ä–æ—Å–∏—Ç—å —à–∞–≥" if user_lang == 'ru' else "üîÑ Reset step"


def _format_required_label(is_optional: bool, user_lang: str) -> str:
    if user_lang == "ru":
        return "‚úÖ –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π" if not is_optional else "‚ö™Ô∏è –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π"
    return "‚úÖ Required" if not is_optional else "‚ö™Ô∏è Optional"


def _media_first_instruction(user_lang: str) -> str:
    if user_lang == "ru":
        return "üìå –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª, –∑–∞—Ç–µ–º —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã."
    return "üìå Upload the file first, then you can enter text and parameters."


def _get_param_price_variants(
    model_id: str,
    param_name: str,
    current_params: dict,
) -> tuple[bool, dict[str, float]]:
    try:
        from app.pricing.price_ssot import list_model_skus, list_variants_with_prices
    except Exception:
        return False, {}
    skus = list_model_skus(model_id)
    if not any(param_name in sku.params for sku in skus):
        return False, {}
    variants = list_variants_with_prices(model_id, param_name, current_params or {})
    return True, {value: float(price) for value, price in variants}


def _format_param_price_rows(values: list[str], price_map: dict[str, float]) -> list[str]:
    from app.pricing.price_resolver import format_price_rub

    rows: list[str] = []
    for value in values:
        price_value = price_map.get(str(value))
        if price_value is None:
            continue
        rows.append(f"{value} ‚Äî {format_price_rub(price_value)}‚ÇΩ")
    return rows


def build_enum_keyboard_with_prices(
    param_name: str,
    enum_values: list,
    is_optional: bool,
    default_value: str | None,
    user_lang: str,
    model_id: str,
    current_params: dict,
) -> tuple[list[list[InlineKeyboardButton]] | None, str, list]:
    price_depends, param_price_map = _get_param_price_variants(
        model_id,
        param_name,
        current_params or {},
    )
    display_values = list(enum_values)
    if price_depends:
        display_values = [value for value in enum_values if str(value) in param_price_map]
        if not display_values:
            return None, "", []

    price_variants_text = ""
    if price_depends:
        price_rows = _format_param_price_rows([str(value) for value in display_values], param_price_map)
        price_variants_text = "\n".join(price_rows)

    keyboard = []
    if price_depends:
        from app.pricing.price_resolver import format_price_rub
    for i in range(0, len(display_values), 2):
        first_value = display_values[i]
        first_label = str(first_value)
        if price_depends:
            price_value = param_price_map.get(str(first_value))
            if price_value is not None:
                first_label = f"{first_label} ‚Äî {format_price_rub(price_value)}‚ÇΩ"
        row = [
            InlineKeyboardButton(first_label, callback_data=f"set_param:{param_name}:{first_value}")
        ]
        if i + 1 < len(display_values):
            second_value = display_values[i + 1]
            second_label = str(second_value)
            if price_depends:
                price_value = param_price_map.get(str(second_value))
                if price_value is not None:
                    second_label = f"{second_label} ‚Äî {format_price_rub(price_value)}‚ÇΩ"
            row.append(InlineKeyboardButton(second_label, callback_data=f"set_param:{param_name}:{second_value}"))
        keyboard.append(row)

    if is_optional:
        if default_value is not None and default_value in display_values:
            default_text = (
                f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ({default_value})"
                if user_lang == "ru"
                else f"‚è≠Ô∏è Use default ({default_value})"
            )
            keyboard.append([InlineKeyboardButton(default_text, callback_data=f"set_param:{param_name}:{default_value}")])
        elif default_value is None:
            skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == "ru" else "‚è≠Ô∏è Skip (auto)"
            keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])

    return keyboard, price_variants_text, display_values


async def prompt_for_specific_param(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    user_id: int,
    param_name: str,
    source: str = "manual_edit",
) -> int | None:
    if user_id not in user_sessions:
        logger.error("prompt_for_specific_param: session not found for user_id=%s", user_id)
        return None
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    param_info = properties.get(param_name, {})
    param_type = param_info.get('type', 'string')
    enum_values = _normalize_enum_values(param_info)
    user_lang = get_user_language(user_id)
    step_info = _get_step_info(session, param_name, user_lang)
    step_prefix = f"{step_info}: " if step_info else ""
    is_optional = not param_info.get('required', False)
    default_value = param_info.get('default')
    format_hint = _get_param_format_hint(param_type, enum_values, user_lang)
    example_hint = _get_param_example(param_name, param_info, user_lang, enum_values)
    required_label = _format_required_label(is_optional, user_lang)
    chat_id = _get_chat_id_from_update(update)
    correlation_id = ensure_correlation_id(update, context)
    free_counter_line = await _resolve_free_counter_line(
        user_id,
        user_lang,
        correlation_id,
        action_path=f"param_prompt:{param_name}",
        sku_id=session.get("sku_id"),
    )
    model_id = session.get("model_id", "")
    mode_index = _resolve_mode_index(model_id, session.get("params", {}), user_id)
    price_line = _build_current_price_line(
        session,
        user_lang=user_lang,
        model_id=model_id,
        mode_index=mode_index,
        gen_type=session.get("gen_type"),
        params=session.get("params", {}),
        correlation_id=correlation_id,
        update_id=update.update_id,
        action_path=f"param_prompt:{param_name}",
        user_id=user_id,
        chat_id=chat_id,
        is_admin=get_is_admin(user_id),
    )
    price_depends, param_price_map = _get_param_price_variants(
        model_id,
        param_name,
        session.get("params", {}),
    )

    logger.info(
        "üß≠ PARAM_PROMPT: action_path=%s model_id=%s param=%s waiting_for=%s current_param=%s outcome=prompt",
        source,
        session.get('model_id'),
        param_name,
        session.get('waiting_for'),
        session.get('current_param'),
    )

    if not chat_id:
        logger.error("Cannot determine chat_id in prompt_for_specific_param")
        return None

    if param_name in {"prompt", "text"} and user_lang == "ru":
        from app.helpers.copy import build_step1_prompt_text
        from app.pricing.ssot_catalog import get_sku_by_id, resolve_sku_for_params

        sku = None
        sku_id = session.get("sku_id")
        if sku_id:
            sku = get_sku_by_id(sku_id)
        if not sku:
            sku = resolve_sku_for_params(model_id, session.get("params", {}))
        price_quote = session.get("price_quote") or {}
        breakdown = price_quote.get("breakdown", {}) if isinstance(price_quote, dict) else {}
        price_rub = price_quote.get("price_rub") if isinstance(price_quote, dict) else None
        is_free = bool(breakdown.get("free_sku")) or str(price_rub) in {"0", "0.0", "0.00"}
        billing_ctx = {
            "price_text": price_line,
            "price_rub": price_rub,
            "is_free": is_free,
        }
        prompt_text = build_step1_prompt_text(
            model_id,
            sku,
            billing_ctx,
            get_is_admin(user_id),
            correlation_id=correlation_id,
        )
        keyboard = [
            [
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ],
            [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")],
        ]
        await context.bot.send_message(
            chat_id=chat_id,
            text=prompt_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="PARAM_PROMPTED",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            outcome="shown",
            param={"param_name": param_name, "type": param_type},
        )
        session['waiting_for'] = param_name
        session['current_param'] = param_name
        return INPUTTING_PARAMS

    if param_name in ['image_input', 'image_urls', 'image', 'mask_input', 'reference_image_input']:
        old_waiting_for = session.get("waiting_for")
        session['current_param'] = param_name
        session['waiting_for'] = param_name
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="WIZARD_TRANSITION",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            param={"from": old_waiting_for, "to": param_name, "reason": "image_prompt"},
            outcome="updated",
        )
        if param_name not in session:
            session[param_name] = []
        skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
        keyboard = [
            [
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ]
        ]
        if is_optional:
            keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
        keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
        instruction_line = _media_first_instruction(user_lang) if not is_optional else ""
        prompt_text = (
            f"üì∑ <b>{step_prefix}{param_name.replace('_', ' ').title()}</b>\n\n"
            f"{param_info.get('description', '')}\n\n"
            f"üí° {format_hint}\n"
            f"{required_label}\n"
        )
        if instruction_line:
            prompt_text += f"{instruction_line}\n"
        if example_hint:
            prompt_text += f"üß™ {example_hint}\n"
        prompt_text += "üìè –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 10 MB" if user_lang == 'ru' else "üìè Max size: 10 MB"
        prompt_text += f"\n\n{price_line}"
        prompt_text = _append_free_counter_text(prompt_text, free_counter_line)
        await context.bot.send_message(
            chat_id=chat_id,
            text=prompt_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="PARAM_PROMPTED",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            outcome="shown",
            param={"param_name": param_name, "media_kind": "image"},
        )
        return INPUTTING_PARAMS

    if param_name in ['audio_url', 'audio_input']:
        old_waiting_for = session.get("waiting_for")
        session['current_param'] = param_name
        session['waiting_for'] = param_name
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="WIZARD_TRANSITION",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            param={"from": old_waiting_for, "to": param_name, "reason": "audio_prompt"},
            outcome="updated",
        )
        skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
        keyboard = [
            [
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ]
        ]
        if is_optional:
            keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
        keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
        instruction_line = _media_first_instruction(user_lang) if not is_optional else ""
        prompt_text = (
            f"üé§ <b>{step_prefix}{param_name.replace('_', ' ').title()}</b>\n\n"
            f"{param_info.get('description', '')}\n\n"
            f"üí° {format_hint}\n"
            f"{required_label}\n"
        )
        if instruction_line:
            prompt_text += f"{instruction_line}\n"
        if example_hint:
            prompt_text += f"üß™ {example_hint}\n"
        prompt_text += (
            "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB" if user_lang == 'ru' else "Max size: 200 MB"
        )
        prompt_text += f"\n\n{price_line}"
        prompt_text = _append_free_counter_text(prompt_text, free_counter_line)
        await context.bot.send_message(
            chat_id=chat_id,
            text=prompt_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="PARAM_PROMPTED",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            outcome="shown",
            param={"param_name": param_name, "media_kind": "audio"},
        )
        return INPUTTING_PARAMS

    if param_type == 'boolean':
        true_label = "‚úÖ –î–∞ (true)"
        false_label = "‚ùå –ù–µ—Ç (false)"
        if price_depends and param_price_map:
            true_price = param_price_map.get("true")
            false_price = param_price_map.get("false")
            from app.pricing.price_resolver import format_price_rub
            if true_price is not None:
                true_label = f"{true_label} ‚Äî {format_price_rub(true_price)}‚ÇΩ"
            if false_price is not None:
                false_label = f"{false_label} ‚Äî {format_price_rub(false_price)}‚ÇΩ"
        keyboard = [
            [
                InlineKeyboardButton(true_label, callback_data=f"set_param:{param_name}:true"),
                InlineKeyboardButton(false_label, callback_data=f"set_param:{param_name}:false")
            ]
        ]
        if is_optional:
            if default_value is None:
                skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
                keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
            else:
                skip_text = "‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é" if user_lang == 'ru' else "‚è≠Ô∏è Use default"
                keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{str(default_value).lower()}")])
        keyboard.append([
            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
        ])
        keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
        description = param_info.get('description', '')
        detail_lines = [format_hint, required_label]
        if example_hint:
            detail_lines.append(example_hint)
        detail_text = "\n".join(detail_lines)
        price_rows = []
        if price_depends:
            price_rows = _format_param_price_rows(["true", "false"], param_price_map)
            if not price_rows:
                blocked_text = (
                    "‚õîÔ∏è <b>–ù–µ—Ç —Ü–µ–Ω—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞</b>"
                    if user_lang == "ru"
                    else "‚õîÔ∏è <b>No price for the selected parameter</b>"
                )
                blocked_keyboard = InlineKeyboardMarkup([
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu"),
                    ]
                ])
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=blocked_text,
                    reply_markup=blocked_keyboard,
                    parse_mode="HTML",
                )
                return INPUTTING_PARAMS
        price_variants_text = "\n".join(price_rows)
        detail_block = (
            f"üìù <b>{step_prefix}{param_name.replace('_', ' ').title()}</b>\n\n"
            f"{description}\n\n"
            f"üí° {detail_text}\n\n"
        )
        if price_variants_text:
            detail_block += f"{price_variants_text}\n\n"
        detail_block += f"{price_line}"
        message_text = _append_free_counter_text(detail_block, free_counter_line)
        await context.bot.send_message(
            chat_id=chat_id,
            text=message_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="PARAM_PROMPTED",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            outcome="shown",
            param={"param_name": param_name, "type": param_type},
        )
        session['waiting_for'] = param_name
        session['current_param'] = param_name
        return INPUTTING_PARAMS

    if enum_values:
        keyboard, price_variants_text, display_values = build_enum_keyboard_with_prices(
            param_name=param_name,
            enum_values=enum_values,
            is_optional=is_optional,
            default_value=default_value,
            user_lang=user_lang,
            model_id=model_id,
            current_params=session.get("params", {}),
        )
        if not display_values:
            blocked_text = (
                "‚õîÔ∏è <b>–ù–µ—Ç —Ü–µ–Ω—ã –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</b>"
                if user_lang == "ru"
                else "‚õîÔ∏è <b>No price for available variants</b>"
            )
            blocked_keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu"),
                ]
            ])
            await context.bot.send_message(
                chat_id=chat_id,
                text=blocked_text,
                reply_markup=blocked_keyboard,
                parse_mode="HTML",
            )
            return INPUTTING_PARAMS
        keyboard.append([
            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
        ])
        keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
        description = param_info.get('description', '')
        detail_lines = [format_hint, required_label]
        if example_hint:
            detail_lines.append(example_hint)
        detail_text = "\n".join(detail_lines)
        detail_block = (
            f"üìù <b>{step_prefix}{param_name.replace('_', ' ').title()}</b>\n\n"
            f"{description}\n\n"
            f"üí° {detail_text}\n\n"
        )
        if price_variants_text:
            detail_block += f"{price_variants_text}\n\n"
        detail_block += f"{price_line}"
        message_text = _append_free_counter_text(detail_block, free_counter_line)
        await context.bot.send_message(
            chat_id=chat_id,
            text=message_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="PARAM_PROMPTED",
            action_path="prompt_for_specific_param",
            model_id=session.get("model_id"),
            outcome="shown",
            param={"param_name": param_name, "type": param_type},
        )
        session['waiting_for'] = param_name
        session['current_param'] = param_name
        return INPUTTING_PARAMS

    keyboard = []
    if is_optional:
        if default_value:
            default_text = f" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value})" if user_lang == 'ru' else f" (default: {default_value})"
            keyboard.append([InlineKeyboardButton(f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é{default_text}", callback_data=f"set_param:{param_name}:{default_value}")])
        else:
            skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
            keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
    keyboard.append([
        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
    ])
    keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
    description = param_info.get('description', '')
    detail_lines = [format_hint, required_label]
    if example_hint:
        detail_lines.append(example_hint)
    detail_text = "\n".join(detail_lines)
    message_text = _append_free_counter_text(
        (
            f"üìù <b>{step_prefix}{param_name.replace('_', ' ').title()}</b>\n\n"
            f"{description}\n\n"
            f"üí° {detail_text}\n\n"
            f"{price_line}"
        ),
        free_counter_line,
    )
    await context.bot.send_message(
        chat_id=chat_id,
        text=message_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML'
    )
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        action="PARAM_PROMPTED",
        action_path="prompt_for_specific_param",
        model_id=session.get("model_id"),
        outcome="shown",
        param={"param_name": param_name, "type": param_type},
    )
    session['waiting_for'] = param_name
    session['current_param'] = param_name
    return INPUTTING_PARAMS


async def send_confirmation_message(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    user_id: int,
    source: str = "confirmation",
) -> int | None:
    if user_id not in user_sessions:
        return None
    correlation_id = ensure_correlation_id(update, context)
    session = user_sessions[user_id]
    model_id = session.get('model_id', '')
    model_name = session.get('model_info', {}).get('name', 'Unknown')
    params = session.get('params', {})
    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
    user_lang = get_user_language(user_id)
    is_admin_user = get_is_admin(user_id)
    sku_id = session.get("sku_id", "")
    is_free = await is_free_generation_available(user_id, sku_id)
    mode_index = _resolve_mode_index(model_id, params, user_id)
    price_quote = _update_price_quote(
        session,
        model_id=model_id,
        mode_index=mode_index,
        gen_type=session.get("gen_type"),
        params=params,
        correlation_id=correlation_id,
        update_id=update.update_id,
        action_path="confirm_screen",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        is_admin=is_admin_user,
    )
    if is_free:
        price_display = "0.00"
    elif price_quote:
        from app.pricing.price_resolver import format_price_rub as format_price_value

        price_display = format_price_value(price_quote.get("price_rub"))
    else:
        price_display = None
    if not is_free and not price_display:
        blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
        if update.callback_query:
            await update.callback_query.edit_message_text(blocked_text, parse_mode="HTML")
        elif update.message:
            await update.message.reply_text(blocked_text, parse_mode="HTML")
        else:
            await context.bot.send_message(chat_id=user_id, text=blocked_text, parse_mode="HTML")
        return ConversationHandler.END
    price_str = price_display
    price_line = (
        f"–¶–µ–Ω–∞ –ø–æ –ø—Ä–∞–π—Å—É: {price_display} ‚ÇΩ"
        if price_display and user_lang == "ru"
        else (
            f"Price (RUB): {price_display} ‚ÇΩ"
            if price_display
            else ("–¶–µ–Ω–∞: —É—Ç–æ—á–Ω—è–µ—Ç—Å—è" if user_lang == "ru" else "Price: —É—Ç–æ—á–Ω—è–µ—Ç—Å—è")
        )
    )
    if is_free:
        remaining = await get_user_free_generations_remaining(user_id)
        price_info = (
            f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å\n{price_line}"
            if user_lang == 'ru'
            else f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day\n{price_line}"
        )
    elif not price_display:
        price_info = price_line
    else:
        price_info = (
            f"üí∞ <b>{price_line}</b>"
            if user_lang == 'ru'
            else f"üí∞ <b>{price_line}</b>"
        )

    free_counter_line = ""
    sku_id = session.get("sku_id")
    try:
        free_counter_line = await get_free_counter_line(
            user_id,
            user_lang=user_lang,
            correlation_id=correlation_id,
            action_path="confirm_screen",
            sku_id=sku_id,
        )
    except Exception as exc:
        logger.warning("Failed to resolve free counter line: %s", exc)

    settings_label = _get_settings_label(user_lang)
    keyboard = [
        [InlineKeyboardButton(settings_label, callback_data="show_parameters")],
        [
            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
        ],
        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
    ]
    if price_str:
        keyboard.insert(0, [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")])

    # Extract numeric price from quote
    price_numeric = 0.0
    if is_free:
        price_numeric = 0.0
    elif price_quote:
        price_numeric = float(price_quote.get("price_rub", 0.0))
    
    user_balance = await get_user_balance_async(user_id)
    # Build enhanced confirmation message
    confirm_msg_base = build_confirmation_text(
        model_id=model_id,
        model_name=model_name,
        params=params,
        price=price_numeric,
        user_id=user_id,
        lang=user_lang,
        is_free=is_free,
        bonus_available=0.0,
        discount=None,
        user_balance=user_balance,
        correlation_id=correlation_id,
    )
    confirm_msg = _append_free_counter_text(confirm_msg_base, free_counter_line)

    logger.info(
        "‚úÖ CONFIRMATION: action_path=%s model_id=%s waiting_for=%s current_param=%s outcome=sent",
        source,
        model_id,
        session.get('waiting_for'),
        session.get('current_param'),
    )

    if update.callback_query:
        await update.callback_query.edit_message_text(
            confirm_msg,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
    elif update.message:
        await update.message.reply_text(
            confirm_msg,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
    else:
        await context.bot.send_message(
            chat_id=user_id,
            text=confirm_msg,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
    return CONFIRMING_GENERATION


async def start_next_parameter(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int):
    """Start input for next parameter."""
    if user_id not in user_sessions:
        logger.error(f"User {user_id} session not found in start_next_parameter")
        return None
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    params = session.get('params', {})
    required = session.get('required', [])
    model_id = session.get('model_id', '')
    sku_id = session.get("sku_id")
    user_lang = get_user_language(user_id)
    correlation_id = ensure_correlation_id(update, context)
    mode_index = _resolve_mode_index(model_id, params, user_id)
    price_line = _build_current_price_line(
        session,
        user_lang=user_lang,
        model_id=model_id,
        mode_index=mode_index,
        gen_type=session.get("gen_type"),
        params=params,
        correlation_id=correlation_id,
        update_id=update.update_id,
        action_path="start_next_parameter",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        is_admin=get_is_admin(user_id),
    )

    logger.info(
        "üß≠üß≠üß≠ START_NEXT_PARAMETER: user_id=%s model_id=%s required=%s params_keys=%s properties_keys=%s session_keys=%s",
        user_id,
        model_id,
        required[:20],
        list(params.keys())[:20],
        list(properties.keys())[:20],
        list(session.keys())[:20],
    )
    trace_event(
        "info",
        correlation_id,
        event="TRACE_IN",
        stage="SESSION_LOAD",
        update_type="message" if update.message else "callback",
        action="PARAM_NEXT",
        action_path="start_next_parameter",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        session_exists=True,
        model_id=model_id,
        waiting_for=session.get("waiting_for"),
        current_param=session.get("current_param"),
        params_keys=list(params.keys())[:15],
        required=required[:15],
        param_order=session.get("param_order")[:15] if session.get("param_order") else None,
    )

    param_order = session.get("param_order") or _build_param_order(properties)
    session["param_order"] = param_order
    required_order = [param_name for param_name in param_order if param_name in required]
    if not required_order:
        required_order = [param_name for param_name in required if param_name in properties]

    for param_name in required_order:
        if param_name in params:
            continue

        param_info = properties.get(param_name, {})
        param_type = param_info.get('type', 'string')
        enum_values = _normalize_enum_values(param_info)
        is_optional = not param_info.get('required', False)
        if param_name in required:
            is_optional = False
        required_label = _format_required_label(is_optional, user_lang)
        session['current_param'] = param_name
        media_kind = _get_media_kind(param_name)
        reason = "missing_required"
        if enum_values:
            reason = "enum_buttons"
        trace_event(
            "info",
            correlation_id,
            event="TRACE_IN",
            stage="STATE_VALIDATE",
            update_type="message" if update.message else "callback",
            action="PARAM_SELECT",
            action_path="start_next_parameter",
            user_id=user_id,
            chat_id=update.effective_chat.id if update.effective_chat else None,
            list_to_check=param_order[:15],
            selected_param=param_name,
            reason=reason,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=update.effective_chat.id if update.effective_chat else None,
            action="PARAM_SELECT",
            action_path="start_next_parameter",
            param={"param_name": param_name, "reason": reason},
            outcome="selected",
        )

        chat_id = None
        if hasattr(update, 'effective_chat') and update.effective_chat:
            chat_id = update.effective_chat.id
        elif hasattr(update, 'message') and update.message:
            chat_id = update.message.chat_id
        elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
            chat_id = update.callback_query.message.chat_id

        if not chat_id:
            logger.error("Cannot determine chat_id in start_next_parameter")
            return None

        if media_kind:
            old_waiting_for = session.get("waiting_for")
            session['waiting_for'] = param_name
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="WIZARD_TRANSITION",
                action_path="start_next_parameter",
                model_id=model_id,
                param={
                    "from": old_waiting_for,
                    "to": param_name,
                    "reason": "media_input",
                },
                outcome="updated",
            )
            param_desc = param_info.get('description', '')
            step_info = _get_step_info(session, param_name, user_lang)
            step_prefix = f"{step_info}: " if step_info else ""
            format_hint = _get_param_format_hint(param_type, enum_values, user_lang)
            example_hint = _get_param_example(param_name, param_info, user_lang, enum_values)
            example_line = f"üß™ {example_hint}\n" if example_hint else ""
            free_counter_line = await _resolve_free_counter_line(
                user_id,
                user_lang,
                correlation_id,
                action_path=f"param_prompt:{param_name}",
                sku_id=sku_id,
            )
            title_map = {
                "image": "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
                "video": "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤–∏–¥–µ–æ",
                "audio": "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ",
            }
            title = title_map.get(media_kind, "–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª")
            instruction_line = _media_first_instruction(user_lang) if not is_optional else ""
            prompt_text = (
                f"üì• <b>{step_prefix}{title}</b>\n\n"
                f"{param_desc}\n\n"
                f"üí° {format_hint}\n"
                f"{required_label}\n"
            )
            if instruction_line:
                prompt_text += f"{instruction_line}\n"
            if example_hint:
                prompt_text += f"{example_line}"
            prompt_text += (
                f"üìè –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 30 MB\n\n"
                f"{price_line}"
            )
            prompt_text = _append_free_counter_text(prompt_text, free_counter_line)
            keyboard = [[
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ]]
            if is_optional:
                skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
                keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])

            await context.bot.send_message(
                chat_id=chat_id,
                text=prompt_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="PARAM_PROMPTED",
                action_path="start_next_parameter",
                model_id=model_id,
                outcome="shown",
                param={"param_name": param_name, "media_kind": media_kind},
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="UX_STEP_PROMPTED",
                action_path="start_next_parameter",
                model_id=model_id,
                gen_type=session.get("gen_type"),
                waiting_for=param_name,
                outcome="shown",
                param={
                    "param_name": param_name,
                    "media_kind": media_kind,
                    "optional": is_optional,
                },
            )
            return INPUTTING_PARAMS

        if param_type == 'boolean':
            default_value = param_info.get('default')
            keyboard = [[
                InlineKeyboardButton("‚úÖ –î–∞ (true)", callback_data=f"set_param:{param_name}:true"),
                InlineKeyboardButton("‚ùå –ù–µ—Ç (false)", callback_data=f"set_param:{param_name}:false")
            ]]
            if is_optional:
                if default_value is None:
                    skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
                    keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
                else:
                    skip_text = "‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é" if user_lang == 'ru' else "‚è≠Ô∏è Use default"
                    keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{str(default_value).lower()}")])

            keyboard.append([
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])

            param_desc = param_info.get('description', '')
            default_text = ""
            if is_optional and default_value is not None:
                default_text = f"\n\n–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: {'–î–∞' if default_value else '–ù–µ—Ç'}"
            step_info = _get_step_info(session, param_name, user_lang)
            step_prefix = f"{step_info}: " if step_info else ""
            format_hint = _get_param_format_hint(param_type, enum_values, user_lang)
            example_hint = _get_param_example(param_name, param_info, user_lang, enum_values)
            example_line = f"üß™ {example_hint}\n" if example_hint else ""
            details_text = "\n".join([format_hint, required_label, example_hint] if example_hint else [format_hint, required_label])
            free_counter_line = await _resolve_free_counter_line(
                user_id,
                user_lang,
                correlation_id,
                action_path=f"param_prompt:{param_name}",
                sku_id=sku_id,
            )
            message_text = _append_free_counter_text(
                (
                    f"üìù <b>{step_prefix}–í—ã–±–µ—Ä–∏—Ç–µ {param_name}:</b>\n\n"
                    f"{param_desc}{default_text}\n\n"
                    f"üí° {details_text}\n{example_line}\n"
                    f"{price_line}"
                ),
                free_counter_line,
            )
            await context.bot.send_message(
                chat_id=chat_id,
                text=message_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="PARAM_PROMPTED",
                action_path="start_next_parameter",
                model_id=model_id,
                outcome="shown",
                param={"param_name": param_name, "type": param_type},
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="UX_STEP_PROMPTED",
                action_path="start_next_parameter",
                model_id=model_id,
                gen_type=session.get("gen_type"),
                waiting_for=param_name,
                outcome="shown",
                param={
                    "param_name": param_name,
                    "type": param_type,
                    "optional": is_optional,
                },
            )
            session['waiting_for'] = param_name
            return INPUTTING_PARAMS

        if enum_values:
            default_value = param_info.get('default')
            price_depends, param_price_map = _get_param_price_variants(
                model_id,
                param_name,
                session.get("params", {}),
            )
            display_values = list(enum_values)
            if price_depends:
                display_values = [value for value in enum_values if str(value) in param_price_map]
                if not display_values:
                    blocked_text = (
                        "‚õîÔ∏è <b>–ù–µ—Ç —Ü–µ–Ω—ã –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</b>"
                        if user_lang == "ru"
                        else "‚õîÔ∏è <b>No price for available variants</b>"
                    )
                    blocked_keyboard = InlineKeyboardMarkup([
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu"),
                        ]
                    ])
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=blocked_text,
                        reply_markup=blocked_keyboard,
                        parse_mode="HTML",
                    )
                    return INPUTTING_PARAMS

            price_variants_text = ""
            if price_depends:
                price_rows = _format_param_price_rows([str(value) for value in display_values], param_price_map)
                price_variants_text = "\n".join(price_rows)

            keyboard = []
            if price_depends:
                from app.pricing.price_resolver import format_price_rub
            for i in range(0, len(display_values), 2):
                first_value = display_values[i]
                first_label = str(first_value)
                if price_depends:
                    price_value = param_price_map.get(str(first_value))
                    if price_value is not None:
                        first_label = f"{first_label} ‚Äî {format_price_rub(price_value)}‚ÇΩ"
                row = [
                    InlineKeyboardButton(first_label, callback_data=f"set_param:{param_name}:{first_value}")
                ]
                if i + 1 < len(display_values):
                    second_value = display_values[i + 1]
                    second_label = str(second_value)
                    if price_depends:
                        price_value = param_price_map.get(str(second_value))
                        if price_value is not None:
                            second_label = f"{second_label} ‚Äî {format_price_rub(price_value)}‚ÇΩ"
                    row.append(InlineKeyboardButton(second_label, callback_data=f"set_param:{param_name}:{second_value}"))
                keyboard.append(row)

            if is_optional:
                if default_value is not None and default_value in display_values:
                    default_text = (
                        f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ({default_value})"
                        if user_lang == "ru"
                        else f"‚è≠Ô∏è Use default ({default_value})"
                    )
                    keyboard.append([InlineKeyboardButton(default_text, callback_data=f"set_param:{param_name}:{default_value}")])
                elif default_value is None:
                    skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == "ru" else "‚è≠Ô∏è Skip (auto)"
                    keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])

            keyboard.append([
                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
            ])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])

            param_desc = param_info.get('description', '')
            default_info = ""
            if default_value and default_value in display_values:
                default_info = (
                    f"\n\nüí° –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: <b>{default_value}</b>"
                    if user_lang == 'ru'
                    else f"\n\nüí° Default: <b>{default_value}</b>"
                )
            param_label = _humanize_param_name(param_name, user_lang)
            free_counter_line = await _resolve_free_counter_line(
                user_id,
                user_lang,
                correlation_id,
                action_path=f"param_prompt:{param_name}",
                sku_id=sku_id,
            )
            header_text = (
                f"‚öôÔ∏è <b>–í—ã–±–µ—Ä–∏—Ç–µ {param_label}:</b>"
                if user_lang == "ru"
                else f"‚öôÔ∏è <b>Select {param_label}:</b>"
            )
            instructions_text = (
                "üí° –ù–∞–∂–º–∏—Ç–µ –æ–¥–Ω—É –∏–∑ –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ"
                if user_lang == "ru"
                else "üí° Tap one of the buttons below"
            )
            variants_block = f"\n\n{price_variants_text}" if price_variants_text else ""
            message_text = _append_free_counter_text(
                (
                    f"{header_text}\n\n"
                    f"{param_desc}{default_info}\n\n"
                    f"{instructions_text}"
                    f"{variants_block}\n\n"
                    f"{price_line}"
                ),
                free_counter_line,
            )
            await context.bot.send_message(
                chat_id=chat_id,
                text=message_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="PARAM_PROMPTED",
                action_path="start_next_parameter",
                model_id=model_id,
                outcome="shown",
                param={"param_name": param_name, "type": param_type},
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="UX_STEP_PROMPTED",
                action_path="start_next_parameter",
                model_id=model_id,
                gen_type=session.get("gen_type"),
                waiting_for=param_name,
                outcome="shown",
                param={
                    "param_name": param_name,
                    "type": param_type,
                    "optional": is_optional,
                },
            )
            session['waiting_for'] = param_name
            return INPUTTING_PARAMS

        param_desc = param_info.get('description', '')
        max_length = param_info.get('max') or param_info.get('max_length')
        max_text = f"\n\n–ú–∞–∫—Å. –¥–ª–∏–Ω–∞: {max_length} —Å–∏–º–≤–æ–ª–æ–≤" if max_length else ""
        default_value = param_info.get('default')
        format_hint = _get_param_format_hint(param_type, enum_values, user_lang)
        example_hint = _get_param_example(param_name, param_info, user_lang, enum_values)
        example_line = f"üß™ {example_hint}\n" if example_hint else ""

        keyboard = []
        if is_optional:
            if default_value:
                default_text = f" (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value})" if default_value else ""
                keyboard.append([InlineKeyboardButton(f"‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é{default_text}", callback_data=f"set_param:{param_name}:{default_value}")])
            else:
                skip_text = "‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)" if user_lang == 'ru' else "‚è≠Ô∏è Skip (auto)"
                keyboard.append([InlineKeyboardButton(skip_text, callback_data=f"set_param:{param_name}:{SKIP_PARAM_VALUE}")])
        keyboard.append([
            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
        ])
        keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])

        if param_name in {"prompt", "text"} and user_lang == "ru":
            from app.helpers.copy import build_step1_prompt_text
            from app.pricing.ssot_catalog import get_sku_by_id, resolve_sku_for_params

            sku = None
            if sku_id:
                sku = get_sku_by_id(sku_id)
            if not sku:
                sku = resolve_sku_for_params(model_id, params)
            price_quote = session.get("price_quote") or {}
            breakdown = price_quote.get("breakdown", {}) if isinstance(price_quote, dict) else {}
            price_rub = price_quote.get("price_rub") if isinstance(price_quote, dict) else None
            is_free = bool(breakdown.get("free_sku")) or str(price_rub) in {"0", "0.0", "0.00"}
            billing_ctx = {
                "price_text": price_line,
                "price_rub": price_rub,
                "is_free": is_free,
            }
            message_text = build_step1_prompt_text(
                model_id,
                sku,
                billing_ctx,
                get_is_admin(user_id),
                correlation_id=correlation_id,
            )
        else:
            default_info = f"\n\n–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: {default_value}" if default_value and is_optional else ""
            optional_text = "\n\n(–≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π)" if is_optional else ""
            param_display_name = param_name.replace('_', ' ').title()
            step_info = _get_step_info(session, param_name, user_lang)
            step_prefix = f"{step_info}: " if step_info else ""
            if default_value:
                action_hint = "‚Ä¢ –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É ¬´‚è≠Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é¬ª –Ω–∏–∂–µ"
            elif is_optional:
                action_hint = "‚Ä¢ –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É ¬´‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (auto)¬ª –Ω–∏–∂–µ"
            else:
                action_hint = "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–º"
            if user_lang != 'ru':
                if default_value:
                    action_hint = "‚Ä¢ Or use the ‚Äú‚è≠Ô∏è Use default‚Äù button below"
                elif is_optional:
                    action_hint = "‚Ä¢ Or use the ‚Äú‚è≠Ô∏è Skip (auto)‚Äù button below"
                else:
                    action_hint = "‚Ä¢ Send the value as text"

            free_counter_line = await _resolve_free_counter_line(
                user_id,
                user_lang,
                correlation_id,
                action_path=f"param_prompt:{param_name}",
                sku_id=sku_id,
            )
            message_text = _append_free_counter_text(
                (
                    f"üìù <b>{step_prefix}–í–≤–µ–¥–∏—Ç–µ {param_display_name.lower()}:</b>\n\n"
                    f"{param_desc}{max_text}{default_info}{optional_text}\n\n"
                    f"üí° {format_hint}\n"
                    f"{example_line}\n"
                    f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                    f"‚Ä¢ –í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏\n"
                    f"{action_hint}\n\n"
                    f"{price_line}"
                ),
                free_counter_line,
            )

        await context.bot.send_message(
            chat_id=chat_id,
            text=message_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="PARAM_PROMPTED",
            action_path="start_next_parameter",
            model_id=model_id,
            outcome="shown",
            param={"param_name": param_name, "type": param_type},
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="UX_STEP_PROMPTED",
            action_path="start_next_parameter",
            model_id=model_id,
            gen_type=session.get("gen_type"),
            waiting_for=param_name,
            outcome="shown",
            param={
                "param_name": param_name,
                "type": param_type,
                "optional": is_optional,
            },
        )
        session['waiting_for'] = param_name
        return INPUTTING_PARAMS

    trace_event(
        "info",
        correlation_id,
        event="TRACE_IN",
        stage="STATE_VALIDATE",
        update_type="message" if update.message else "callback",
        action="PARAM_SELECT",
        action_path="start_next_parameter",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
        fallback_mode=True,
        reason="no_next_param",
    )
    return None


async def input_parameters(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Latency wrapper for parameter input."""
    start_ts = time.monotonic()
    try:
        return await _input_parameters_impl(update, context)
    finally:
        _log_handler_latency("input_parameters", start_ts, update)


async def _input_parameters_impl(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle parameter input."""
    import time
    start_time = time.time()
    user_id = update.effective_user.id
    _create_background_task(
        upsert_user_registry_entry(update.effective_user),
        action="user_registry_upsert",
    )
    
    # ==================== NO-SILENCE GUARD: Track outgoing actions ====================
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
    guard = get_no_silence_guard()
    _create_background_task(
        _check_and_deliver_pending_results(update, context),
        action="pending_result_check",
    )
    update_id = update.update_id
    # ==================== END NO-SILENCE GUARD ====================

    # CRITICAL: Log function entry IMMEDIATELY
    logger.info(f"üö®üö®üö® INPUT_PARAMETERS FUNCTION CALLED: user_id={user_id}, update_type={type(update).__name__}")
    
    # üî• MAXIMUM LOGGING: Log ALL input_parameters calls
    has_photo = bool(update.message and update.message.photo)
    has_text = bool(update.message and update.message.text)
    has_audio = bool(update.message and (update.message.audio or update.message.voice))
    has_document = bool(update.message and update.message.document)
    logger.debug(f"üî•üî•üî• INPUT_PARAMETERS ENTRY: user_id={user_id}, has_photo={has_photo}, has_text={has_text}, has_audio={has_audio}, has_document={has_document}, update_type={type(update).__name__}")

    correlation_id = ensure_correlation_id(update, context)
    if _should_dedupe_update(
        update,
        context,
        action="INPUT",
        action_path="input_parameters",
        user_id=user_id,
        chat_id=update.message.chat_id if update.message else None,
    ):
        return ConversationHandler.END
    input_type = "unknown"
    if has_text:
        input_type = "text"
    elif has_photo:
        input_type = "photo"
    elif has_audio:
        input_type = "audio"
    elif has_document:
        input_type = "document"
    chat_id = update.message.chat_id if update.message else None
    guard.set_trace_context(
        update,
        context,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        message_id=update.message.message_id if update.message else None,
        update_type="message",
        correlation_id=correlation_id,
        action="INPUT",
        action_path="input_parameters",
        stage="UI_ROUTER",
        outcome="received",
        input_type=input_type,
    )
    trace_event(
        "info",
        correlation_id,
        event="TRACE_IN",
        stage="UI_ROUTER",
        update_type="message",
        action="INPUT",
        action_path="input_parameters",
        user_id=user_id,
        chat_id=chat_id,
        input_type=input_type,
        message_id=update.message.message_id if update.message else None,
    )
    session = user_sessions.get(user_id, {})
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update_id,
        action="INPUT_COLLECT",
        action_path="input_parameters",
        model_id=session.get("model_id") if isinstance(session, dict) else None,
        gen_type=session.get("gen_type") if isinstance(session, dict) else None,
        stage="INPUT_COLLECT",
        param={
            "waiting_for": session.get("waiting_for") if isinstance(session, dict) else None,
            "current_param": session.get("current_param") if isinstance(session, dict) else None,
            "input_type": input_type,
        },
        outcome="received",
    )
    
    # CRITICAL: Log photo details if photo is present
    if has_photo and update.message and update.message.photo:
        photo_count = len(update.message.photo) if update.message.photo else 0
        photo_file_id = update.message.photo[-1].file_id if update.message.photo else 'None'
        logger.debug(f"üî•üî•üî• PHOTO DETECTED: user_id={user_id}, photo_count={photo_count}, file_id={photo_file_id}")
    
    if update.message:
        logger.debug(f"üî•üî•üî• INPUT_PARAMETERS MESSAGE: message_id={update.message.message_id}, chat_id={update.message.chat_id}, date={update.message.date}, from_user_id={update.message.from_user.id if update.message.from_user else 'None'}")
        if has_photo:
            photo_count = len(update.message.photo) if update.message.photo else 0
            logger.debug(f"üî•üî•üî• INPUT_PARAMETERS PHOTO: photo_count={photo_count}, file_id={update.message.photo[-1].file_id if update.message.photo else 'None'}, file_size={update.message.photo[-1].file_size if update.message.photo and update.message.photo[-1].file_size else 'Unknown'}")
    
    if user_id not in user_sessions:
        logger.error(f"‚ùå‚ùå‚ùå CRITICAL ERROR: User {user_id} not in user_sessions in input_parameters!")
        logger.error(f"   This means session was lost. User needs to select model again.")
        logger.error(f"   Available sessions: {list(user_sessions.keys())[:10]}")
        logger.error(f"   Total sessions: {len(user_sessions)}")
        if update.message:
            if has_photo:
                # Photo sent but no session - try to help user
                await update.message.reply_text(
                    "‚ùå <b>–°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</b>\n\n"
                    "–ü–æ—Ö–æ–∂–µ, —Å–µ—Å—Å–∏—è –±—ã–ª–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                    "1. –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ /start\n"
                    "2. –ó–∞—Ç–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n\n"
                    "–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
            else:
                await update.message.reply_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
        return ConversationHandler.END
    
    session = user_sessions[user_id]
    model_id = session.get('model_id', 'Unknown')
    waiting_for = session.get('waiting_for', 'None')
    _log_route_decision_once(
        update,
        context,
        waiting_for=waiting_for if waiting_for != "None" else None,
        chosen_handler="input_parameters",
        reason="conversation_handler",
    )
    properties = session.get('properties', {})
    params = session.get('params', {})
    has_image_input = 'image_input' in properties
    has_image_urls = 'image_urls' in properties
    logger.debug(f"üî•üî•üî• INPUT_PARAMETERS SESSION: user_id={user_id}, model_id={model_id}, waiting_for={waiting_for}, has_image_input={has_image_input}, has_image_urls={has_image_urls}")
    
    image_only_model = _is_image_only_model(properties)
    logger.debug(f"üî•üî•üî• INPUT_PARAMETERS SESSION KEYS: {list(session.keys())[:15]}")
    logger.debug(f"üî•üî•üî• INPUT_PARAMETERS PARAMS: keys={list(params.keys())}, values={[(k, type(v).__name__, len(v) if isinstance(v, (list, dict)) else 'N/A') for k, v in params.items()][:5]}")

    missing_media = _collect_missing_required_media(session) if model_id and properties else []
    if update.message and update.message.text and missing_media:
        user_lang = get_user_language(user_id) if user_id else "ru"
        missing_param = missing_media[0]
        param_label = _humanize_param_name(missing_param, user_lang)
        media_kind = _get_media_kind(missing_param) or "media"
        media_label_ru = {
            "image": "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
            "video": "–≤–∏–¥–µ–æ",
            "audio": "–∞—É–¥–∏–æ",
            "document": "—Ñ–∞–π–ª",
            "media": "–º–µ–¥–∏–∞",
        }.get(media_kind, "–º–µ–¥–∏–∞")
        media_label_en = {
            "image": "image",
            "video": "video",
            "audio": "audio",
            "document": "file",
            "media": "media",
        }.get(media_kind, "media")
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="MEDIA_REQUIRED_FIRST",
            action_path="input_parameters",
            model_id=model_id,
            stage="INPUT_GUARD",
            waiting_for=waiting_for,
            outcome="blocked",
            param={"missing_media": missing_media},
        )
        await update.message.reply_text(
            (
                f"üìé <b>–°–Ω–∞—á–∞–ª–∞ –Ω—É–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å {media_label_ru}</b>\n\n"
                f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ: <b>{param_label}</b>.\n"
                "–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã."
                if user_lang == "ru"
                else (
                    f"üìé <b>Please upload the required {media_label_en} first</b>\n\n"
                    f"Please upload: <b>{param_label}</b>.\n"
                    "After upload you can enter text and parameters."
                )
            ),
            parse_mode="HTML",
        )
        await prompt_for_specific_param(update, context, user_id, missing_param, source="media_first_guard")
        return INPUTTING_PARAMS

    trace_event(
        "info",
        correlation_id,
        event="TRACE_IN",
        stage="SESSION_LOAD",
        update_type="message",
        action="INPUT",
        action_path="input_parameters",
        user_id=user_id,
        chat_id=chat_id,
        session_exists=True,
        model_id=model_id,
        waiting_for=waiting_for,
        current_param=session.get("current_param"),
        params_keys=list(params.keys())[:15],
        required=session.get("required", [])[:15],
        param_order=session.get("param_order")[:15] if session.get("param_order") else None,
    )

    def _trace_param_saved(param_name: str, value: Any, source: str) -> None:
        summary: Dict[str, Any] = {
            "param_name": param_name,
            "value_type": type(value).__name__,
            "source": source,
        }
        if isinstance(value, str):
            summary.update(prompt_summary(value))
        elif isinstance(value, list):
            summary["value_len"] = len(value)
        elif isinstance(value, dict):
            summary["value_keys"] = list(value.keys())[:10]
        trace_event(
            "info",
            correlation_id,
            event="TRACE_IN",
            stage="STATE_VALIDATE",
            update_type="message",
            action="PARAM_SAVE",
            action_path="input_parameters",
            user_id=user_id,
            chat_id=chat_id,
            **summary,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="PARAM_SAVE",
            action_path="input_parameters",
            param=summary,
            outcome="saved",
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="PARAM_SET",
            action_path="input_parameters",
            param=summary,
            outcome="stored",
        )
    
    # CRITICAL: If photo is sent but session doesn't have waiting_for set, log warning
    if has_photo and not waiting_for:
        logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PHOTO SENT BUT waiting_for is None! user_id={user_id}, model_id={model_id}, properties={list(properties.keys())}, session_keys={list(session.keys())[:10]}")
    
    # Universal handling for schema-based text/number inputs
    if update.message and update.message.text and waiting_for in properties:
        param_info = properties.get(waiting_for, {})
        param_type = param_info.get('type', 'string')
        enum_values = _normalize_enum_values(param_info)
        value_text = update.message.text.strip()

        if param_type in ('number', 'integer', 'float'):
            try:
                value = float(value_text)
                if param_type == 'integer':
                    value = int(value)
            except ValueError:
                await update.message.reply_text(
                    "‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —á–∏—Å–ª–∞</b>\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS

            min_value = param_info.get('min')
            max_value = param_info.get('max')
            if min_value is not None and value < min_value:
                await update.message.reply_text(
                    f"‚ùå <b>–ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –º–µ–Ω—å—à–µ {min_value}</b>",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            if max_value is not None and value > max_value:
                await update.message.reply_text(
                    f"‚ùå <b>–ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –±–æ–ª—å—à–µ {max_value}</b>",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS

            params[waiting_for] = value
            session['params'] = params
            session['waiting_for'] = None
            _trace_param_saved(waiting_for, value, "number_input")
            next_param_result = await start_next_parameter(update, context, user_id)
            if next_param_result is None:
                return await send_confirmation_message(update, context, user_id, source="number_input")
            return next_param_result

        if enum_values:
            if value_text not in enum_values:
                await update.message.reply_text(
                    "‚ùå <b>–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ –∏–∑ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            params[waiting_for] = value_text
            session['params'] = params
            session['waiting_for'] = None
            _trace_param_saved(waiting_for, value_text, "enum_input")
            next_param_result = await start_next_parameter(update, context, user_id)
            if next_param_result is None:
                return await send_confirmation_message(update, context, user_id, source="enum_input")
            return next_param_result

        if param_type == 'boolean':
            normalized = value_text.lower()
            if normalized in {'true', '1', 'yes', '–¥–∞'}:
                params[waiting_for] = True
            elif normalized in {'false', '0', 'no', '–Ω–µ—Ç'}:
                params[waiting_for] = False
            else:
                await update.message.reply_text(
                    "‚ùå <b>–í–≤–µ–¥–∏—Ç–µ –î–∞/–ù–µ—Ç</b>",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            session['params'] = params
            session['waiting_for'] = None
            _trace_param_saved(waiting_for, params[waiting_for], "boolean_input")
            next_param_result = await start_next_parameter(update, context, user_id)
            if next_param_result is None:
                return await send_confirmation_message(update, context, user_id, source="boolean_input")
            return next_param_result

        # Default string handling
        params[waiting_for] = value_text
        session['params'] = params
        session['waiting_for'] = None
        _trace_param_saved(waiting_for, value_text, "text_input")
        next_param_result = await start_next_parameter(update, context, user_id)
        if next_param_result is None:
            return await send_confirmation_message(update, context, user_id, source="text_input")
        return next_param_result

    # Handle admin OCR test
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'admin_test_ocr':
        if update.message.photo:
            photo = update.message.photo[-1]
            loading_msg = await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")
            
            try:
                file = await context.bot.get_file(photo.file_id)
                image_data = await file.download_as_bytearray()
                
                # Test OCR - extract text
                try:
                    image = Image.open(BytesIO(image_data))
                    try:
                        extracted_text = pytesseract.image_to_string(image, lang='rus+eng')
                    except Exception as e:
                        logger.warning(f"Error with rus+eng, trying eng only: {e}")
                        try:
                            extracted_text = pytesseract.image_to_string(image, lang='eng')
                        except Exception as e2:
                            logger.warning(f"Error with eng, trying default: {e2}")
                            extracted_text = pytesseract.image_to_string(image)
                except Exception as e:
                    error_msg = str(e)
                    if "tesseract is not installed" in error_msg.lower() or "not in your path" in error_msg.lower():
                        raise Exception("Tesseract OCR –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ PATH.")
                    else:
                        raise Exception(f"–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞: {error_msg}")
                
                extracted_text_lower = extracted_text.lower()
                
                # Find amounts in text (improved patterns)
                amount_patterns = [
                    # With currency symbols
                    r'(\d+[.,]\d+)\s*[‚ÇΩ—Ä—É–±–†]',
                    r'(\d+)\s*[‚ÇΩ—Ä—É–±–†]',
                    r'[‚ÇΩ—Ä—É–±–†]\s*(\d+[.,]\d+)',
                    r'[‚ÇΩ—Ä—É–±–†]\s*(\d+)',
                    # Near payment keywords
                    r'(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)[:\s]+(\d+[.,]?\d*)',
                    r'(\d+[.,]?\d*)\s*(?:—Å—É–º–º–∞|–∏—Ç–æ–≥–æ|–ø–µ—Ä–µ–≤–æ–¥|amount|total)',
                    # Misrecognized currency (B instead of –†, 2 instead of –†)
                    r'(\d+)\s*[B2]',
                    r'(\d+)\s*[‚ÇΩ—Ä—É–±–†B2]',
                    # Standalone numbers (filtered later)
                    r'\b(\d{2,6})\b',
                ]
                
                found_amounts = []
                for pattern in amount_patterns:
                    matches = re.findall(pattern, extracted_text, re.IGNORECASE)
                    for match in matches:
                        try:
                            amount = float(match.replace(',', '.'))
                            # Filter reasonable amounts (10-100000 rubles)
                            if 10 <= amount <= 100000:
                                found_amounts.append(amount)
                        except:
                            continue
                
                # Check for payment keywords
                payment_keywords = [
                    '–ø–µ—Ä–µ–≤–æ–¥', '–æ–ø–ª–∞—Ç–∞', '–ø–ª–∞—Ç–µ–∂', '—Å–ø–±', '—Å–±–ø', 'payment', 'transfer',
                    '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ', '—É—Å–ø–µ—à–Ω–æ', 'success', '–ø–æ–ª—É—á–∞—Ç–µ–ª—å', '—Å—É–º–º–∞', '–∏—Ç–æ–≥–æ',
                    '–∫–≤–∏—Ç–∞–Ω—Ü–∏—è', 'receipt', '—Å—Ç–∞—Ç—É—Å', 'status', '–∫–æ–º–∏—Å—Å–∏—è', 'commission'
                ]
                has_keywords = any(keyword in extracted_text_lower for keyword in payment_keywords)
                
                # Prepare result
                result_text = "üß™ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∞ OCR:</b>\n\n"
                
                result_text += f"üìù <b>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (–ø–µ—Ä–≤—ã–µ 300 —Å–∏–º–≤–æ–ª–æ–≤):</b>\n"
                result_text += f"<code>{extracted_text[:300].replace('<', '&lt;').replace('>', '&gt;')}</code>\n\n"
                
                if found_amounts:
                    result_text += f"üí∞ <b>–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Å—É–º–º—ã:</b>\n"
                    for amt in sorted(set(found_amounts), reverse=True)[:5]:
                        result_text += f"  ‚Ä¢ {format_rub_amount(amt)}\n"
                    result_text += "\n"
                else:
                    result_text += "‚ö†Ô∏è <b>–°—É–º–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</b>\n\n"
                
                if has_keywords:
                    result_text += "‚úÖ <b>–ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</b>\n"
                else:
                    result_text += "‚ö†Ô∏è <b>–ü—Ä–∏–∑–Ω–∞–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</b>\n"
                
                result_text += f"\nüìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
                result_text += f"  ‚Ä¢ –°–∏–º–≤–æ–ª–æ–≤ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {len(extracted_text)}\n"
                result_text += f"  ‚Ä¢ –°—É–º–º –Ω–∞–π–¥–µ–Ω–æ: {len(found_amounts)}\n"
                result_text += f"  ‚Ä¢ –ö–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤: {'–î–∞' if has_keywords else '–ù–µ—Ç'}\n"
                
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                keyboard = [
                    [InlineKeyboardButton("üîÑ –¢–µ—Å—Ç –µ—â–µ —Ä–∞–∑", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    result_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                
                # Clean up session
                if user_id in user_sessions:
                    del user_sessions[user_id]
                
                return ConversationHandler.END
            except Exception as e:
                logger.error(f"Error in admin OCR test: {e}", exc_info=True)
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                error_msg = str(e)
                help_text = ""
                if "tesseract is not installed" in error_msg.lower() or "not in your path" in error_msg.lower() or "tesseract" in error_msg.lower():
                    help_text = (
                        "\n\nüí° <b>–†–µ—à–µ–Ω–∏–µ:</b>\n"
                        "1. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ Tesseract —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\n"
                        "2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å: C:\\Program Files\\Tesseract-OCR\\tesseract.exe\n"
                        "3. –ò–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ Tesseract –≤ PATH —Å–∏—Å—Ç–µ–º—ã\n"
                        "4. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏"
                    )
                
                keyboard = [
                    [InlineKeyboardButton("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑", callback_data="admin_test_ocr")],
                    [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
                ]
                
                await update.message.reply_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞ OCR:</b>\n\n{error_msg}{help_text}\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ADMIN_TEST_OCR
        else:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (—Ñ–æ—Ç–æ).\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return ADMIN_TEST_OCR
    
    # Handle broadcast message
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'broadcast_message':
        import time
        from datetime import datetime
        
        # Get message content
        message_text = None
        message_photo = None
        
        if update.message.text:
            message_text = update.message.text
        elif update.message.caption:
            message_text = update.message.caption
        
        if update.message.photo:
            message_photo = update.message.photo[-1]
        
        if not message_text and not message_photo:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_BROADCAST_MESSAGE
        
        # Get all users
        all_users = get_all_users()
        total_users = len(all_users)
        
        if total_users == 0:
            await update.message.reply_text(
                "‚ùå <b>–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
                "–í –±–∞–∑–µ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
                parse_mode='HTML'
            )
            if user_id in user_sessions:
                del user_sessions[user_id]['waiting_for']
            return ConversationHandler.END
        
        # Create broadcast record
        broadcast_data = {
            'id': len(get_broadcasts()) + 1,
            'message': message_text or '[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]',
            'created_at': int(time.time()),
            'created_by': user_id,
            'total_users': total_users,
            'sent': 0,
            'delivered': 0,
            'failed': 0,
            'user_ids': []
        }
        
        broadcast_id = save_broadcast(broadcast_data)
        
        # Confirm and start sending
        await update.message.reply_text(
            f"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
            f"üë• <b>–ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π:</b> {total_users}\n"
            f"üìù <b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b> {message_text[:50] + '...' if message_text and len(message_text) > 50 else message_text or '[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ]'}\n\n"
            f"‚è≥ –ù–∞—á–∏–Ω–∞—é –æ—Ç–ø—Ä–∞–≤–∫—É...",
            parse_mode='HTML'
        )
        
        # Clear waiting state
        if user_id in user_sessions:
            del user_sessions[user_id]['waiting_for']
        
        # Start broadcast in background
        _create_background_task(
            send_broadcast(context, broadcast_id, all_users, message_text, message_photo),
            action="send_broadcast",
        )
        
        return ConversationHandler.END
    
    # Handle currency rate input
    if user_id == ADMIN_ID and user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'currency_rate':
        if not update.message.text:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –≤–∞–ª—é—Ç—ã.\n\n"
                "–ù–∞–ø—Ä–∏–º–µ—Ä: <code>100</code> –∏–ª–∏ <code>95.5</code>\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
        
        try:
            # Parse currency rate
            rate_text = update.message.text.strip().replace(',', '.')
            new_rate = float(rate_text)
            
            if new_rate <= 0:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                    "–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\n\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                    parse_mode='HTML'
                )
                return WAITING_CURRENCY_RATE
            
            # Save currency rate (locked from pricing config)
            if set_usd_to_rub_rate(new_rate):
                current_rate = get_usd_to_rub_rate()
                await update.message.reply_text(
                    f"‚úÖ <b>–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω!</b>\n\n"
                    f"üìä <b>–ù–æ–≤—ã–π –∫—É—Ä—Å:</b>\n"
                    f"1 USD = {current_rate:.2f} RUB\n\n"
                    f"üí° –í—Å–µ —Ü–µ–Ω—ã –±—É–¥—É—Ç –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ.",
                    parse_mode='HTML'
                )
                if user_id in user_sessions:
                    del user_sessions[user_id]['waiting_for']
                return ConversationHandler.END

            current_rate = get_usd_to_rub_rate()
            await update.message.reply_text(
                "‚ùå <b>–ö—É—Ä—Å –≤–∞–ª—é—Ç—ã –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω</b>\n\n"
                f"1 USD = {current_rate:.2f} RUB\n\n"
                "–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–æ.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
                
        except ValueError:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —á–∏—Å–ª–∞.\n\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä: <code>100</code> –∏–ª–∏ <code>95.5</code>\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
        except Exception as e:
            logger.error(f"Error setting currency rate: {e}")
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
                parse_mode='HTML'
            )
            return WAITING_CURRENCY_RATE
    
    # Handle payment screenshot
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'payment_screenshot':
        if update.message and update.message.text:
            cancel_text = update.message.text.strip().lower()
            if cancel_text in ['/cancel', '–æ—Ç–º–µ–Ω–∞', 'cancel']:
                user_sessions.pop(user_id, None)
                return await cancel(update, context)
        if update.message.photo:
            # User sent payment screenshot
            if user_id not in user_sessions:
                await update.message.reply_text("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
                return ConversationHandler.END
            
            photo = update.message.photo[-1]
            screenshot_file_id = photo.file_id
            
            session = user_sessions[user_id]
            amount = session.get('topup_amount', 0)
            
            # Download and analyze screenshot (if OCR available)
            if OCR_AVAILABLE and PIL_AVAILABLE:
                loading_msg = await update.message.reply_text("üîç <b>–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–ª–∞—Ç–µ–∂–∞ –°–ë–ü...</b>\n\n‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é —Å—É–º–º—É, –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ —Å—Ç–∞—Ç—É—Å –ø–µ—Ä–µ–≤–æ–¥–∞...", parse_mode='HTML')
            else:
                loading_msg = await update.message.reply_text("‚è≥ <b>–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –ø–ª–∞—Ç–µ–∂...</b>", parse_mode='HTML')
            
            try:
                # Check for duplicate screenshot
                if check_duplicate_payment(screenshot_file_id):
                    await loading_msg.delete()
                    await update.message.reply_text(
                        f"‚ö†Ô∏è <b>–≠—Ç–æ—Ç —Å–∫—Ä–∏–Ω—à–æ—Ç —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω</b>\n\n"
                        f"‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞.\n\n"
                        f"üí° –ï—Å–ª–∏ –≤—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —ç—Ç–æ –Ω–æ–≤—ã–π –ø–ª–∞—Ç–µ–∂, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É (@ferixdiii).",
                        parse_mode='HTML'
                    )
                    return WAITING_PAYMENT_SCREENSHOT
                
                file = await context.bot.get_file(photo.file_id)
                image_data = await file.download_as_bytearray()
                
                # Get expected phone from .env
                expected_phone = os.getenv('PAYMENT_PHONE', '')
                
                # Analyze screenshot (ALWAYS - strict check)
                analysis = None
                analysis_error = None
                
                if OCR_AVAILABLE and PIL_AVAILABLE:
                    try:
                        # STRICT OCR ANALYSIS - validates real receipt
                        analysis = await analyze_payment_screenshot(image_data, amount, expected_phone if expected_phone else None)
                        logger.info(f"‚úÖ Payment analysis result: valid={analysis.get('valid')}, amount={analysis.get('found_amount')}, phone={analysis.get('phone_found')}")
                    except Exception as e:
                        logger.error(f"‚ùå OCR API ERROR in analyze_payment_screenshot: {e}", exc_info=True)
                        analysis_error = str(e)
                        # STRICT: On error, require manual review (don't auto-credit)
                        analysis = {
                            'valid': False,
                            'message': f'‚ùå <b>–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞:</b> {analysis_error}\n\n–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–±—É–µ—Ç <b>—Ä—É—á–Ω–æ–π –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏</b> –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.'
                        }
                else:
                    # OCR not available - require manual review
                    logger.warning(f"‚ö†Ô∏è OCR not available, requiring manual payment verification")
                    analysis = {
                        'valid': False,
                        'message': '‚ùå <b>–°–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</b>\n\n–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ —Ç—Ä–µ–±—É–µ—Ç <b>—Ä—É—á–Ω–æ–π –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏</b> –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.\n\n–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É: @ferixdiii'
                    }
                
                # Delete loading message
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                # Check if screenshot passed validation - STRICT (default False)
                is_valid_payment = analysis.get('valid', False)
                
                if not is_valid_payment:
                    # Payment validation FAILED - reject and show error
                    support_info = get_support_contact()
                    
                    error_message = (
                        f"‚ùå <b>–ü–õ–ê–¢–ï–ñ –ù–ï –ü–û–î–¢–í–ï–†–ñ–î–ï–ù</b>\n\n"
                        f"{analysis.get('message', '–°–∫—Ä–∏–Ω—à–æ—Ç –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º')}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                        f"1Ô∏è‚É£ –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ—Ç–∫–∏–π –∏ –≤–∏–¥–Ω–æ:\n"
                        f"   ‚Ä¢ –°—É–º–º—É –ø–µ—Ä–µ–≤–æ–¥–∞ ({format_rub_amount(amount)})\n"
                        f"   ‚Ä¢ –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–æ–ª—É—á–∞—Ç–µ–ª—è\n"
                        f"   ‚Ä¢ –°—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞ (\"—É—Å–ø–µ—à–Ω–æ\", \"–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ\", \"–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\")\n\n"
                        f"2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ—Ä–µ–∑ üîÑ <b>–ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å</b>\n\n"
                        f"3Ô∏è‚É£ –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è, –Ω–∞–ø–∏—à–∏—Ç–µ @ferixdiii –¥–ª—è —Ä—É—á–Ω–æ–π –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏\n\n"
                        f"{support_info}"
                    )
                    
                    await update.message.reply_text(
                        error_message,
                        parse_mode='HTML'
                    )
                    
                    # Keep session for retry
                    return WAITING_PAYMENT_SCREENSHOT
                
                # PAYMENT PASSED VALIDATION - Add balance and credit user
                logger.info(f"‚úÖ Payment validation PASSED for user {user_id}, amount {amount} RUB")
                
                # Show success analysis details
                analysis_msg = await update.message.reply_text(
                    f"{analysis.get('message', '')}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"‚è≥ –ù–∞—á–∏—Å–ª—è—é –±–∞–ª–∞–Ω—Å...",
                    parse_mode='HTML'
                )
                
                # Add payment and auto-credit balance
                payment = await add_payment_async(user_id, amount, screenshot_file_id)
                new_balance = await get_user_balance_async(user_id)
                balance_str = format_rub_amount(new_balance)
                
                logger.info(f"‚úÖ Balance credited: user={user_id}, added={amount} RUB, new_balance={new_balance} RUB")
                
                # Delete analysis message
                if analysis_msg:
                    try:
                        await analysis_msg.delete()
                    except:
                        pass
                
                # Clean up session
                if user_id in user_sessions:
                    del user_sessions[user_id]
                
                # Get user language for messages
                user_lang = get_user_language(user_id)
                
                # Create keyboard with main menu button
                keyboard = [
                    [
                        InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                        InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                    ],
                    [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                ]
                
                if user_lang == 'ru':
                    payment_success_msg = (
                        f"‚úÖ <b>–û–ü–õ–ê–¢–ê –ü–û–õ–£–ß–ï–ù–ê –ò –ü–†–û–í–ï–†–ï–ù–ê!</b> ‚úÖ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üíµ <b>–°—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞:</b> {format_rub_amount(amount)}\n"
                        f"üí∞ <b>–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å:</b> {balance_str}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üéâ <b>–û—Ç–ª–∏—á–Ω–æ! –ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω!</b>\n\n"
                        f"üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n"
                        f"‚Ä¢ –ù–∞—á–Ω–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å\n"
                        f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ª—é–±—É—é –º–æ–¥–µ–ª—å –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞\n"
                        f"‚Ä¢ –ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –ø—Ä–µ–º–∏—É–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏!\n\n"
                        f"‚ú® <b>–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–≤–µ—Ä–∏–µ!</b>"
                    )
                else:
                    payment_success_msg = (
                        f"‚úÖ <b>PAYMENT RECEIVED AND VERIFIED!</b> ‚úÖ\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üíµ <b>Amount:</b> {format_rub_amount(amount)}\n"
                        f"üí∞ <b>New balance:</b> {balance_str}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üéâ <b>Great! Balance topped up!</b>\n\n"
                        f"üí° <b>What's next:</b>\n"
                        f"‚Ä¢ Start content generation right now\n"
                        f"‚Ä¢ Use any model from the catalog\n"
                        f"‚Ä¢ Enjoy premium features!\n\n"
                        f"‚ú® <b>Thank you for your trust!</b>"
                    )
                
                await update.message.reply_text(
                    payment_success_msg,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                return ConversationHandler.END
                
            except Exception as e:
                logger.error(f"‚ùå Error processing payment screenshot: {e}", exc_info=True)
                try:
                    await loading_msg.delete()
                except:
                    pass
                
                support_info = get_support_contact()
                await update.message.reply_text(
                    f"‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞</b>\n\n"
                    f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞:\n"
                    f"<code>{str(e)[:100]}</code>\n\n"
                    f"üí° <b>–†–µ—à–µ–Ω–∏–µ:</b>\n"
                    f"‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –µ—â–µ —Ä–∞–∑\n"
                    f"‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ—Ç–∫–∏–π –∏ —Ö–æ—Ä–æ—à–æ –≤–∏–¥–µ–Ω\n"
                    f"‚Ä¢ –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –ø–æ–≤—Ç–æ—Ä–∏—Ç—Å—è, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É\n\n"
                    f"{support_info}",
                    parse_mode='HTML'
                )
                return WAITING_PAYMENT_SCREENSHOT
        else:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–∫—Ä–∏–Ω—à–æ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞ (—Ñ–æ—Ç–æ).\n\n"
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return WAITING_PAYMENT_SCREENSHOT

    # Handle admin user lookup
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'admin_user_lookup':
        if not is_admin(user_id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            user_sessions.pop(user_id, None)
            return ConversationHandler.END
        if not update.message or not update.message.text:
            await update.message.reply_text("‚ùå –û—Ç–ø—Ä–∞–≤—å—Ç–µ user_id —Ç–µ–∫—Å—Ç–æ–º.")
            return ConversationHandler.END
        try:
            target_user_id = int(update.message.text.strip())
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
            return ConversationHandler.END
        user_sessions.pop(user_id, None)
        text, keyboard = await build_admin_user_overview(target_user_id)
        await update.message.reply_text(text, reply_markup=keyboard, parse_mode='HTML')
        return ConversationHandler.END

    # Handle admin manual topup
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'admin_manual_topup_amount':
        if not is_admin(user_id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            user_sessions.pop(user_id, None)
            return ConversationHandler.END
        if not update.message or not update.message.text:
            await update.message.reply_text("‚ùå –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—É–º–º—É —Ç–µ–∫—Å—Ç–æ–º.")
            return ConversationHandler.END
        session = user_sessions[user_id]
        target_user_id = session.get("admin_target_user_id")
        if target_user_id is None:
            await update.message.reply_text("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–ª—è –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è.")
            user_sessions.pop(user_id, None)
            return ConversationHandler.END
        try:
            amount = float(update.message.text.strip().replace(",", "."))
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
            return ConversationHandler.END
        if amount <= 0:
            await update.message.reply_text("‚ùå –°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0.")
            return ConversationHandler.END
        await add_payment_async(int(target_user_id), amount, screenshot_file_id=None)
        user_sessions.pop(user_id, None)
        text, keyboard = await build_admin_user_overview(int(target_user_id))
        await update.message.reply_text(
            f"‚úÖ –ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–µ–Ω.\n\n{text}",
            reply_markup=keyboard,
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    # Handle custom topup amount input
    if user_id in user_sessions and user_sessions[user_id].get('waiting_for') == 'topup_amount_input':
        try:
            amount = float(update.message.text.replace(',', '.'))
            user_lang = get_user_language(user_id)
            
            if amount < 50:
                if user_lang == 'ru':
                    await update.message.reply_text("‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50 ‚ÇΩ")
                else:
                    await update.message.reply_text("‚ùå Minimum top-up amount: 50 ‚ÇΩ")
                return SELECTING_AMOUNT
            
            if amount > 50000:
                if user_lang == 'ru':
                    await update.message.reply_text("‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50000 ‚ÇΩ")
                else:
                    await update.message.reply_text("‚ùå Maximum top-up amount: 50000 ‚ÇΩ")
                return SELECTING_AMOUNT
            
            # Calculate what user can generate
            examples_count = int(amount / 0.62)  # free tools price
            video_count = int(amount / 3.86)  # Basic video price
            
            # Show payment method selection
            amount_display = format_rub_amount(amount)
            if user_lang == 'ru':
                payment_text = (
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê {amount_display}</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ:</b> {amount_display}\n\n'
                    f'üéØ <b>–ß–¢–û –¢–´ –ü–û–õ–£–ß–ò–®–¨:</b>\n'
                    f'‚Ä¢ ~{examples_count} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (free tools)\n'
                    f'‚Ä¢ ~{video_count} –≤–∏–¥–µ–æ (–±–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å)\n'
                    f'‚Ä¢ –ò–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Ä–∞–∑–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>–û–ü–õ–ê–¢–ê –¢–û–õ–¨–ö–û –ü–û –°–ë–ü:</b>'
                )
            else:
                payment_text = (
                    f'üí≥ <b>PAYMENT {amount_display}</b> üí≥\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üíµ <b>Amount to pay:</b> {amount_display}\n\n'
                    f'üéØ <b>WHAT YOU WILL GET:</b>\n'
                    f'‚Ä¢ ~{examples_count} images (free tools)\n'
                    f'‚Ä¢ ~{video_count} videos (basic model)\n'
                    f'‚Ä¢ Or a combination of different models!\n\n'
                    f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
                    f'üí≥ <b>PAYMENT ONLY VIA SBP:</b>'
                )
            
            # Store amount in session
            user_sessions[user_id] = {
                'topup_amount': amount,
                'waiting_for': 'payment_method'
            }
            
            keyboard = [
                [InlineKeyboardButton("üí≥ –°–ë–ü / SBP", callback_data=f"pay_sbp:{amount}")],
                [
                    InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                    InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                ],
                [
                    InlineKeyboardButton(t('btn_support', lang=user_lang), callback_data="support_contact"),
                    InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")
                ]
            ]
            
            await update.message.reply_text(
                payment_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            return SELECTING_AMOUNT
        except ValueError:
            user_lang = get_user_language(user_id)
            if user_lang == 'ru':
                await update.message.reply_text(
                    "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1500)\n\n"
                    "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
                )
            else:
                await update.message.reply_text(
                    "‚ùå Please enter a number (e.g., 1500)\n\n"
                    "Or press /cancel to cancel."
                )
            return SELECTING_AMOUNT
    
    if user_id not in user_sessions:
        logger.warning(f"Session not found for user {user_id} in input_parameters")
        user_lang = get_user_language(user_id)
        error_msg = t('error_session_empty', lang=user_lang) if user_lang else "‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start"
        await update.message.reply_text(error_msg)
        return ConversationHandler.END
    
    session = user_sessions[user_id]
    properties = session.get('properties', {})
    
    # CRITICAL: Log session state for debugging
    logger.info(f"Session state: user_id={user_id}, model_id={session.get('model_id', 'Unknown')}, waiting_for={session.get('waiting_for', 'None')}, has_properties={bool(properties)}")
    
    # Handle audio input (for audio_url or audio_input)
    waiting_for_audio = session.get('waiting_for') in ['audio_url', 'audio_input']
    if (update.message.audio or update.message.voice or (update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith('audio/'))) and waiting_for_audio:
        # Get audio file
        audio_file = None
        if update.message.audio:
            audio_file = update.message.audio
        elif update.message.voice:
            audio_file = update.message.voice
        elif update.message.document:
            audio_file = update.message.document
        
        if not audio_file:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
            return INPUTTING_PARAMS
        
        file = await context.bot.get_file(audio_file.file_id)
        
        # Download audio from Telegram
        loading_msg = None
        try:
            # Show loading message
            loading_msg = await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∑–∫–∞ –∞—É–¥–∏–æ...")
            
            # Download audio
            try:
                audio_data = await file.download_as_bytearray()
            except Exception as e:
                logger.error(f"Error downloading audio file from Telegram: {e}", exc_info=True)
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª –∏–∑ Telegram.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Check file size (max 200MB as per API)
            if len(audio_data) > 200 * 1024 * 1024:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
                    "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            if len(audio_data) == 0:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ê—É–¥–∏–æ-—Ñ–∞–π–ª –ø—É—Å—Ç–æ–π.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Downloaded audio: {len(audio_data)} bytes")
            
            # Determine file extension
            file_extension = "mp3"
            if update.message.audio:
                if update.message.audio.mime_type:
                    if "wav" in update.message.audio.mime_type:
                        file_extension = "wav"
                    elif "ogg" in update.message.audio.mime_type:
                        file_extension = "ogg"
                    elif "aac" in update.message.audio.mime_type:
                        file_extension = "aac"
                    elif "mp4" in update.message.audio.mime_type:
                        file_extension = "m4a"
            elif update.message.document and update.message.document.mime_type:
                if "wav" in update.message.document.mime_type:
                    file_extension = "wav"
                elif "ogg" in update.message.document.mime_type:
                    file_extension = "ogg"
                elif "aac" in update.message.document.mime_type:
                    file_extension = "aac"
                elif "mp4" in update.message.document.mime_type:
                    file_extension = "m4a"
            
            # Upload to public hosting
            filename = f"audio_{user_id}_{audio_file.file_id[:8]}.{file_extension}"
            public_url = await upload_image_to_hosting(audio_data, filename=filename)
            
            # Delete loading message
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            if not public_url:
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.info(f"Successfully uploaded audio to: {public_url}")
            
            # Set audio_url parameter
            audio_param_name = session.get('waiting_for', 'audio_url')
            if 'params' not in session:
                session['params'] = {}
            session['params'][audio_param_name] = public_url
            session[audio_param_name] = public_url  # Also store in session for consistency
            session['waiting_for'] = None
            session['current_param'] = None
            
            # Confirm audio was set
            await update.message.reply_text(
                f"‚úÖ <b>–ê—É–¥–∏–æ-—Ñ–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω!</b>\n\n"
                f"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...",
                parse_mode='HTML'
            )
            
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    params = session.get('params', {})
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}{'...' if len(str(v)) > 50 else ''}" for k, v in params.items()])
                    
                    user_lang = get_user_language(user_id)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    await update.message.reply_text(
                        f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                        f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                        f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}\n\n"
                        f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
            except Exception as e:
                logger.error(f"Error after audio input: {e}", exc_info=True)
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É.")
            
            return INPUTTING_PARAMS
            
        except Exception as e:
            logger.error(f"Error processing audio: {e}", exc_info=True)
            # Try to delete loading message if exists
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n\n"
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
    
    # Handle image input (for image_input, image_urls, mask_input, reference_image_input or 'image')
    waiting_for = session.get('waiting_for')
    waiting_for_image = waiting_for in ['image_input', 'image_urls', 'image', 'mask_input', 'reference_image_input']
    
    # CRITICAL: Log for debugging
    model_id = session.get('model_id', 'Unknown')
    properties = session.get('properties', {})
    logger.info(f"üîçüîçüîç Image input check: user_id={user_id}, waiting_for={waiting_for}, waiting_for_image={waiting_for_image}, has_photo={bool(update.message.photo)}, model_id={model_id}, has_image_input={bool('image_input' in properties)}, has_image_urls={bool('image_urls' in properties)}, session_keys={list(session.keys())[:10]}")
    
    # CRITICAL: If photo is sent and model requires image, but waiting_for is not set, auto-fix immediately
    if update.message.photo and not waiting_for_image:
        # Check if model requires image_input or image_urls
        if 'image_input' in properties or 'image_urls' in properties:
            # Determine which parameter name to use
            if 'image_input' in properties:
                image_param_name = 'image_input'
            elif 'image_urls' in properties:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'  # Default fallback
            
            # Check if this parameter is required
            param_info = properties.get(image_param_name, {})
            is_required = param_info.get('required', False)
            
            # Models that definitely require image first
            models_require_image = [
                "recraft/remove-background",
                "recraft/crisp-upscale",
                "ideogram/v3-reframe",
                "topaz/image-upscale",
                "nano-banana-pro"
            ]
            
            # Auto-fix if model requires image or is in the list
            if model_id in models_require_image or is_required:
                logger.warning(f"üîß AUTO-FIX: Photo sent for {model_id} but waiting_for={waiting_for}, fixing session immediately...")
                session['waiting_for'] = image_param_name
                session['current_param'] = image_param_name
                if image_param_name not in session:
                    session[image_param_name] = []
                waiting_for_image = True
                waiting_for = image_param_name
                logger.info(f"‚úÖ‚úÖ‚úÖ AUTO-FIX COMPLETE: waiting_for={image_param_name}, model={model_id}, continuing image processing...")
    
    # CRITICAL: Check if waiting for URL parameter but file was sent
    waiting_for = session.get('waiting_for')
    if waiting_for and waiting_for.endswith('_url') and waiting_for != 'image_urls':
        # For URL parameters (except image_urls which accepts files), check if file was sent
        if update.message.photo or update.message.video or update.message.document or update.message.audio:
            user_lang = get_user_language(user_id)
            param_name = waiting_for.replace('_url', '').replace('_', ' ').title()
            if user_lang == 'en':
                error_msg = (
                    f"‚ùå <b>URL required, not file</b>\n\n"
                    f"Parameter <b>{waiting_for}</b> requires a URL (link), not a file.\n\n"
                    f"Please send the URL as text (e.g., https://example.com/file.mp4)\n\n"
                    f"If you have a file, upload it to a hosting service first and send the URL."
                )
            else:
                error_msg = (
                    f"‚ùå <b>–¢—Ä–µ–±—É–µ—Ç—Å—è URL, –∞ –Ω–µ —Ñ–∞–π–ª</b>\n\n"
                    f"–ü–∞—Ä–∞–º–µ—Ç—Ä <b>{waiting_for}</b> —Ç—Ä–µ–±—É–µ—Ç URL (—Å—Å—ã–ª–∫—É), –∞ –Ω–µ —Ñ–∞–π–ª.\n\n"
                    f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ URL —Ç–µ–∫—Å—Ç–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://example.com/file.mp4)\n\n"
                    f"–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å —Ñ–∞–π–ª, —Å–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –µ–≥–æ –Ω–∞ —Ö–æ—Å—Ç–∏–Ω–≥ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ URL."
                )
            await update.message.reply_text(error_msg, parse_mode='HTML')
            return INPUTTING_PARAMS
    
    # If photo sent but not waiting for image, try to auto-fix session
    if update.message.photo and not waiting_for_image:
        model_id = session.get('model_id', 'Unknown')
        user_lang = get_user_language(user_id)
        
        # Check if model requires image_input
        properties = session.get('properties', {})
        has_image_param = 'image_input' in properties or 'image_urls' in properties
        
        # CRITICAL: Auto-fix session for models that require image_input
        # This handles cases where photo is sent but session state is lost or incorrect
        if has_image_param:
            # Check which parameter name to use
            if 'image_input' in properties:
                image_param_name = 'image_input'
            elif 'image_urls' in properties:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'  # Default fallback
            
            # Auto-fix for models that require image (nano-banana-pro, recraft models, ideogram, topaz, etc.)
            models_require_image_first = [
                "nano-banana-pro",
                "recraft/remove-background",
                "recraft/crisp-upscale",
                "ideogram/v3-reframe",
                "topaz/image-upscale",
                "recraft/remove-background"  # Explicitly include this
            ]
            if model_id in models_require_image_first or \
               (properties.get(image_param_name, {}).get('required', False)):
                logger.warning(f"‚ö†Ô∏è Photo sent for {model_id} but waiting_for={waiting_for}, fixing session...")
                session['waiting_for'] = image_param_name
                session['current_param'] = image_param_name
                if image_param_name not in session:
                    session[image_param_name] = []
                # Update local variables to continue processing
                waiting_for_image = True
                waiting_for = image_param_name
                logger.info(f"‚úÖ‚úÖ‚úÖ Session fixed: waiting_for={image_param_name}, model={model_id}, continuing image processing...")
                # Continue to process the image below
            else:
                # Photo sent but not expected - show helpful message
                if user_lang == 'en':
                    error_msg = (
                        "‚ö†Ô∏è <b>Image not expected now</b>\n\n"
                        f"Current step: {waiting_for or 'none'}\n\n"
                        "Please follow the instructions or use /cancel to start over."
                    )
                else:
                    error_msg = (
                        "‚ö†Ô∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è —Å–µ–π—á–∞—Å</b>\n\n"
                        f"–¢–µ–∫—É—â–∏–π —à–∞–≥: {waiting_for or '–Ω–µ—Ç'}\n\n"
                        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –Ω–∞—á–∞–ª–∞ –∑–∞–Ω–æ–≤–æ."
                    )
                await update.message.reply_text(error_msg, parse_mode='HTML')
                return INPUTTING_PARAMS
        else:
            # Photo sent but not expected - show helpful message
            if user_lang == 'en':
                error_msg = (
                    "‚ö†Ô∏è <b>Image not expected now</b>\n\n"
                    f"Current step: {waiting_for or 'none'}\n\n"
                    "Please follow the instructions or use /cancel to start over."
                )
            else:
                error_msg = (
                    "‚ö†Ô∏è <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è —Å–µ–π—á–∞—Å</b>\n\n"
                    f"–¢–µ–∫—É—â–∏–π —à–∞–≥: {waiting_for or '–Ω–µ—Ç'}\n\n"
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel –¥–ª—è –Ω–∞—á–∞–ª–∞ –∑–∞–Ω–æ–≤–æ."
                )
            await update.message.reply_text(error_msg, parse_mode='HTML')
            return INPUTTING_PARAMS
    
    # Process image if photo is sent and we're waiting for image
    if update.message.photo and waiting_for_image:
        logger.info(f"‚úÖ‚úÖ‚úÖ Processing image for user {user_id}, waiting_for={waiting_for}, model={session.get('model_id', 'Unknown')}, image_param_name will be determined from waiting_for")
        photo = update.message.photo[-1]  # Get largest photo
        file = await context.bot.get_file(photo.file_id)
        
        # Download image from Telegram
        loading_msg = None
        try:
            # Show loading message
            loading_msg = await update.message.reply_text("üì§ –ó–∞–≥—Ä—É–∑–∫–∞...")
            
            # Download image
            try:
                image_data = await file.download_as_bytearray()
            except Exception as e:
                logger.error(f"‚ùå‚ùå‚ùå ERROR DOWNLOADING IMAGE: user_id={user_id}, error={str(e)}, error_type={type(e).__name__}, file_id={photo.file_id if 'photo' in locals() else 'Unknown'}", exc_info=True)
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ Telegram.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Check file size (max 30MB as per KIE API)
            if len(image_data) > 30 * 1024 * 1024:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
                    "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 30 MB.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            if len(image_data) == 0:
                if loading_msg:
                    try:
                        await loading_msg.delete()
                    except:
                        pass
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</b>\n\n"
                    "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—É—Å—Ç–æ–µ.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.debug(f"üî•üî•üî• IMAGE DOWNLOADED: size={len(image_data)} bytes, user_id={user_id}, file_id={photo.file_id[:8]}")
            
            # Upload to public hosting
            logger.debug(f"üî•üî•üî• UPLOADING TO HOSTING: user_id={user_id}, filename=image_{user_id}_{photo.file_id[:8]}.jpg")
            # üî¥ API CALL: File Upload API - upload_image_to_hosting
            try:
                public_url = await upload_image_with_fallback(
                    image_data,
                    filename=f"image_{user_id}_{photo.file_id[:8]}.jpg",
                )
            except Exception as e:
                logger.error(f"‚ùå‚ùå‚ùå FILE UPLOAD API ERROR in upload_image_to_hosting (image): {e}", exc_info=True)
                user_lang = get_user_language(user_id) if user_id else 'ru'
                error_msg = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ" if user_lang == 'ru' else "Server error, please try later"
                await update.message.reply_text(
                    f"‚ùå <b>{error_msg}</b>\n\n"
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Delete loading message
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            if not public_url:
                logger.error(f"‚ùå‚ùå‚ùå IMAGE UPLOAD FAILED: user_id={user_id}, model_id={session.get('model_id', 'Unknown')}, file_size={len(image_data)} bytes, upload_image_to_hosting returned None")
                try:
                    log_structured_event(
                        correlation_id=ensure_correlation_id(update, context),
                        user_id=user_id,
                        chat_id=update.effective_chat.id if update.effective_chat else None,
                        update_id=update.update_id,
                        action="IMAGE_UPLOAD",
                        action_path="image_upload>fallback",
                        stage="image_upload",
                        outcome="upload_unavailable",
                        error_code="IMAGE_HOSTING_HTTP_CLIENT_NOT_INITIALIZED",
                        fix_hint="declare_global_http_client_and_init_aiohttp_session",
                    )
                except Exception as log_error:
                    logger.warning("STRUCTURED_LOG image upload unavailable failed: %s", log_error, exc_info=True)
                await update.message.reply_text(
                    "‚ö†Ô∏è <b>–ê–ø–ª–æ–∞–¥ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</b>\n\n"
                    "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.debug(f"üî•üî•üî• IMAGE UPLOADED TO HOSTING: public_url={public_url}, user_id={user_id}, file_size={len(image_data)} bytes, model_id={session.get('model_id', 'Unknown')}")
            
            # Add to image_input array
            # Determine which parameter name to use
            waiting_for = session.get('waiting_for', 'image_input')
            logger.debug(f"üî•üî•üî• IMAGE PROCESSING: waiting_for={waiting_for}, user_id={user_id}, model_id={session.get('model_id', 'Unknown')}")
            # Normalize: if waiting_for is 'image', use the actual parameter name from properties
            if waiting_for == 'image':
                properties = session.get('properties', {})
                if 'image_input' in properties:
                    image_param_name = 'image_input'
                elif 'image_urls' in properties:
                    image_param_name = 'image_urls'
                else:
                    image_param_name = 'image_input'  # Default fallback
            else:
                image_param_name = waiting_for  # image_input or image_urls
            if image_param_name not in session:
                session[image_param_name] = []
            session[image_param_name].append(public_url)
            logger.debug(f"üî•üî•üî• IMAGE ADDED TO SESSION: param={image_param_name}, count={len(session[image_param_name])}, model={session.get('model_id', 'Unknown')}, user_id={user_id}, urls={session[image_param_name][:2]}")
            
        except Exception as e:
            logger.error(f"‚ùå‚ùå‚ùå ERROR PROCESSING IMAGE: user_id={user_id}, error={str(e)}, error_type={type(e).__name__}", exc_info=True)
            if user_id in user_sessions:
                session_error = user_sessions[user_id]
                logger.error(f"‚ùå‚ùå‚ùå ERROR CONTEXT: model_id={session_error.get('model_id', 'Unknown')}, waiting_for={session_error.get('waiting_for', 'None')}, session_keys={list(session_error.keys())[:10]}")
            else:
                logger.error(f"‚ùå‚ùå‚ùå ERROR CONTEXT: No session found for user_id={user_id}")
            # Try to delete loading message if exists
            if loading_msg:
                try:
                    await loading_msg.delete()
                except:
                    pass
            
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>\n\n"
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                parse_mode='HTML'
            )
            return INPUTTING_PARAMS
        
        # Determine image parameter name (normalize 'image' to actual param name)
        waiting_for = session.get('waiting_for', 'image_input')
        if waiting_for == 'image':
            properties_check = session.get('properties', {})
            if 'image_input' in properties_check:
                image_param_name = 'image_input'
            elif 'image_urls' in properties_check:
                image_param_name = 'image_urls'
            else:
                image_param_name = 'image_input'  # Default fallback
        else:
            image_param_name = waiting_for
        
        image_count = len(session.get(image_param_name, []))
        
        # Check if model requires only 1 image (max_items = 1)
        properties = session.get('properties', {})
        param_info = properties.get(image_param_name, {})
        max_items = param_info.get('max_items', 8)  # Default to 8 if not specified
        
        model_id = session.get('model_id', 'Unknown')
        
        # CRITICAL: For models that only require image (no prompt), force max_items=1
        # This ensures they always show the button immediately after image upload
        if image_only_model:
            max_items = 1  # Force to 1 for these models
            logger.info(f"üîç Model {model_id} is image-only, forcing max_items=1")
        
        logger.info(f"üîç Image processing: model={model_id}, image_param_name={image_param_name}, max_items={max_items}, image_count={image_count}, session_keys={list(session.keys())}")
        
        # If max_items is 1, immediately move to next parameter (or show button for image-only models)
        if max_items == 1:
            user_lang = get_user_language(user_id)
            if user_lang == 'en':
                success_msg = "‚úÖ Image uploaded!\n\nContinuing..."
            else:
                success_msg = "‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ!\n\n–ü—Ä–æ–¥–æ–ª–∂–∞—é..."
            await update.message.reply_text(success_msg)
            
            if 'params' not in session:
                session['params'] = {}
            
            # Store image_input as array (API expects array)
            # CRITICAL: Ensure image_input is properly stored in params
            if image_param_name not in session:
                logger.error(f"ERROR: {image_param_name} not in session after upload!")
                session[image_param_name] = []
            
            # CRITICAL: Store image_input as array (API expects array)
            # Ensure we have the image data before storing
            if image_param_name not in session or not session[image_param_name]:
                logger.error(f"CRITICAL ERROR: {image_param_name} not in session or empty after upload!")
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            # Store in params
            if isinstance(session[image_param_name], list):
                session['params'][image_param_name] = session[image_param_name].copy()  # Use copy to avoid reference issues
            else:
                session['params'][image_param_name] = [session[image_param_name]]
            
            # CRITICAL: Double-check that params contains the image
            if image_param_name not in session.get('params', {}) or not session.get('params', {}).get(image_param_name):
                logger.error(f"ERROR: {image_param_name} not properly stored in params! Fixing...")
                if image_param_name in session and session[image_param_name]:
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                else:
                    logger.error(f"CRITICAL: Cannot fix - {image_param_name} not in session!")
                    await update.message.reply_text(
                        "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS
            
            # TRIPLE-CHECK: Verify the image is actually in params
            if not session.get('params', {}).get(image_param_name):
                logger.error(f"CRITICAL: {image_param_name} still not in params after all fixes!")
                await update.message.reply_text(
                    "‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                    parse_mode='HTML'
                )
                return INPUTTING_PARAMS
            
            logger.debug(f"üî•üî•üî• IMAGE VERIFIED IN PARAMS: param={image_param_name}, count={len(session['params'][image_param_name])}, user_id={user_id}, model_id={model_id}, urls={session['params'][image_param_name][:1]}")
            
            session['waiting_for'] = None
            session['current_param'] = None
            logger.debug(f"üî•üî•üî• SESSION UPDATED: waiting_for=None, current_param=None, user_id={user_id}, model_id={model_id}")

            next_param_result = await start_next_parameter(update, context, user_id)
            if next_param_result is None:
                return await send_confirmation_message(update, context, user_id, source="image_upload")
            return next_param_result
            
            # CRITICAL: If all_required_collected is still False but this is an image-only model with image uploaded,
            # FORCE show the button anyway - this is a safety net
            if not all_required_collected and image_only_model:
                params_safety = session.get('params', {})
                if image_param_name in params_safety and params_safety.get(image_param_name):
                    logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è SAFETY NET: all_required_collected=False but {model_id} has image, FORCING button show")
                    all_required_collected = True
                    # Jump directly to showing button (code below will handle it)
                elif image_param_name in session and session.get(image_param_name):
                    logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è SAFETY NET: Moving image from session to params for {model_id}")
                    if 'params' not in session:
                        session['params'] = {}
                    if isinstance(session[image_param_name], list):
                        session['params'][image_param_name] = session[image_param_name].copy()
                    else:
                        session['params'][image_param_name] = [session[image_param_name]]
                    all_required_collected = True
            
            # Move to next parameter if not all collected (only if button wasn't shown above)
            if not all_required_collected:
                try:
                    next_param_result = await start_next_parameter(update, context, user_id)
                    logger.info(f"start_next_parameter returned: {next_param_result} for model {model_id}")
                    if next_param_result:
                        return next_param_result
                    else:
                        # All parameters collected, show confirmation
                        model_name = session.get('model_info', {}).get('name', 'Unknown')
                        params = session.get('params', {})
                        logger.info(f"All parameters collected for {model_id}, params: {list(params.keys())}")
                        params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                        
                        user_lang = get_user_language(user_id)
                        keyboard = [
                            [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                            [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                            [
                                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                            ],
                            [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                        ]
                        
                        # Calculate price for confirmation
                        sku_id = session.get("sku_id", "")
                        is_free = await is_free_generation_available(user_id, sku_id)
                        price = calculate_price_rub(model_id, params, is_admin_user)
                        if price is None:
                            blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                            await update.message.reply_text(blocked_text, parse_mode="HTML")
                            return INPUTTING_PARAMS
                        if is_free:
                            price = 0.0
                        price_str = format_rub_amount(price)
                        
                        # Prepare price info
                        if is_free:
                            remaining = await get_user_free_generations_remaining(user_id)
                            price_info = f"üéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                        else:
                            price_info = f"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}"
                        
                        if user_lang == 'en':
                            price_info_en = f"üéÅ <b>FREE GENERATION!</b>\nRemaining free: {remaining}/{FREE_GENERATIONS_PER_DAY} per day" if is_free else f"üí∞ <b>Cost:</b> {price_str}"
                            confirm_text = (
                                f"üìã <b>Generation Confirmation</b>\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"ü§ñ <b>Model:</b> {model_name}\n\n"
                                f"‚öôÔ∏è <b>Parameters:</b>\n{params_text}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"{price_info_en}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"üí° <b>What's next:</b>\n"
                                f"‚Ä¢ Generation will start after confirmation\n"
                                f"‚Ä¢ Result will come automatically\n"
                                f"‚Ä¢ Usually takes from 10 seconds to 2 minutes\n\n"
                                f"üöÄ <b>Ready to start?</b>"
                            )
                        else:
                            confirm_text = (
                                f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                                f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n{params_text}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"{price_info}\n\n"
                                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                f"üí° <b>–ß—Ç–æ –±—É–¥–µ—Ç –¥–∞–ª—å—à–µ:</b>\n"
                                f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–Ω–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
                                f"‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
                                f"‚Ä¢ –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –æ—Ç 10 —Å–µ–∫—É–Ω–¥ –¥–æ 2 –º–∏–Ω—É—Ç\n\n"
                                f"üöÄ <b>–ì–æ—Ç–æ–≤—ã –Ω–∞—á–∞—Ç—å?</b>"
                            )
                        
                        # Check if we have update.message or need to use context.bot
                        try:
                            if update.message:
                                await update.message.reply_text(
                                    confirm_text,
                                    reply_markup=InlineKeyboardMarkup(keyboard),
                                    parse_mode='HTML'
                                )
                            elif update.callback_query:
                                try:
                                    await update.callback_query.edit_message_text(
                                        confirm_text,
                                        reply_markup=InlineKeyboardMarkup(keyboard),
                                        parse_mode='HTML'
                                    )
                                except Exception as edit_error:
                                    logger.warning(f"Could not edit message, sending new: {edit_error}")
                                    await update.callback_query.message.reply_text(
                                        confirm_text,
                                        reply_markup=InlineKeyboardMarkup(keyboard),
                                        parse_mode='HTML'
                                    )
                            else:
                                await context.bot.send_message(
                                    chat_id=user_id,
                                    text=confirm_text,
                                    reply_markup=InlineKeyboardMarkup(keyboard),
                                    parse_mode='HTML'
                                )
                            logger.info(f"‚úÖ‚úÖ‚úÖ Confirmation button shown for {model_id}, returning CONFIRMING_GENERATION")
                            return CONFIRMING_GENERATION
                        except Exception as send_error:
                            logger.error(f"‚ùå Error showing confirmation button: {send_error}", exc_info=True)
                            return INPUTTING_PARAMS
                except Exception as e:
                    logger.error(f"Error after image input: {e}", exc_info=True)
                    await update.message.reply_text(
                        f"‚ùå <b>–û—à–∏–±–∫–∞</b>\n\n"
                        f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É.\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cancel.",
                        parse_mode='HTML'
                    )
        elif image_count < min(max_items, 8):
            keyboard = [
                [InlineKeyboardButton("üì∑ –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data="add_image")],
                [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="image_done")]
            ]
            await update.message.reply_text(
                f"‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {image_count} –¥–æ–±–∞–≤–ª–µ–Ω–æ!\n\n"
                f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ: {image_count}/{max_items}\n\n"
                f"–î–æ–±–∞–≤–∏—Ç—å –µ—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                f"‚úÖ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {image_count} –¥–æ–±–∞–≤–ª–µ–Ω–æ!\n\n"
                f"–î–æ—Å—Ç–∏–≥–Ω—É—Ç –º–∞–∫—Å–∏–º—É–º ({max_items} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π). –ü—Ä–æ–¥–æ–ª–∂–∞—é..."
            )
            if 'params' not in session:
                session['params'] = {}
            session['params'][image_param_name] = session[image_param_name]
            session['waiting_for'] = None
            # Move to next parameter
            try:
                next_param_result = await start_next_parameter(update, context, user_id)
                if next_param_result:
                    return next_param_result
                # –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
                await guard.check_and_ensure_response(update, context)
            except Exception as e:
                logger.error(f"Error after image input: {e}")
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                await update.message.reply_text(
                    f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}",
                    parse_mode='HTML'
                )
                track_outgoing_action(update_id)
        
        return INPUTTING_PARAMS
    
    # Handle text input
    if not update.message.text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        track_outgoing_action(update_id)
        return INPUTTING_PARAMS

    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        track_outgoing_action(update_id)
        return INPUTTING_PARAMS
    
    # Handle /cancel command
    if text.lower() in ['/cancel', '–æ—Ç–º–µ–Ω–∞', 'cancel']:
        user_lang = get_user_language(user_id)
        if user_id in user_sessions:
            del user_sessions[user_id]
        keyboard = [[InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]]
        await update.message.reply_text(
            t('msg_operation_cancelled', lang=user_lang),
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
        return ConversationHandler.END
    
    # ==================== TASK 1: –ì–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –∫–∞–∂–¥—ã–π –≤–≤–æ–¥ ====================
    # –°—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –¥—É–º–∞–ª, —á—Ç–æ –±–æ—Ç –∑–∞–≤–∏—Å
    try:
        await update.message.reply_text("‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...", parse_mode='HTML')
        # NO-SILENCE GUARD: Track outgoing action
        track_outgoing_action(update_id)
    except Exception as e:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: {e}")
    
    # ==================== TASK 1: Try/except –≤–æ–∫—Ä—É–≥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ ====================
    try:
        # If waiting for text input (prompt or other text parameter)
        waiting_for = session.get('waiting_for')
        if waiting_for:
            model_info = session.get('model_info', {})
            model_id = session.get('model_id', '')
            input_params = model_info.get('input_params', {})
            user_lang = get_user_language(user_id)
            current_param = session.get('current_param', waiting_for)
            param_info = properties.get(current_param, {})
            max_length = param_info.get('max_length')
            if current_param == 'prompt' and not max_length:
                max_length = 1000
            
            # Validate max length
            if max_length and len(text) > max_length:
                await update.message.reply_text(
                    f"‚ùå –¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. {max_length} —Å–∏–º–≤–æ–ª–æ–≤). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                )
                track_outgoing_action(update_id)
                return INPUTTING_PARAMS
        
            # For language_code, convert common language names to codes
            if current_param == 'language_code':
                lang_lower = text.lower()
                lang_map = {
                    '—Ä—É—Å—Å–∫–∏–π': 'ru',
                    'russian': 'ru',
                    '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π': 'en',
                    'english': 'en',
                    'eng': 'en',
                    '–Ω–µ–º–µ—Ü–∫–∏–π': 'de',
                    'german': 'de',
                    '—Ñ—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π': 'fr',
                    'french': 'fr',
                    '–∏—Å–ø–∞–Ω—Å–∫–∏–π': 'es',
                    'spanish': 'es',
                    '–∏—Ç–∞–ª—å—è–Ω—Å–∫–∏–π': 'it',
                    'italian': 'it',
                    '–∫–∏—Ç–∞–π—Å–∫–∏–π': 'zh',
                    'chinese': 'zh',
                    '—è–ø–æ–Ω—Å–∫–∏–π': 'ja',
                    'japanese': 'ja',
                    '–∫–æ—Ä–µ–π—Å–∫–∏–π': 'ko',
                    'korean': 'ko'
                }
                if lang_lower in lang_map:
                    text = lang_map[lang_lower]
                # If it's already a code (2-3 letters), convert to lowercase
                elif len(text) <= 5 and text.replace('-', '').replace('_', '').isalpha():
                    text = text.lower()
            
            # For video_url in sora-watermark-remover, validate URL format
            if current_param == 'video_url' and model_id == 'sora-watermark-remover':
                # Validate URL format (should contain sora.chatgpt.com)
                if 'sora.chatgpt.com' not in text:
                    await update.message.reply_text(
                        f"‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL</b>\n\n"
                        f"URL –≤–∏–¥–µ–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç OpenAI Sora 2 (–¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å sora.chatgpt.com).\n\n"
                        f"–ü—Ä–∏–º–µ—Ä: https://sora.chatgpt.com/p/s_...\n\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS
                
                # Additional validation: check if URL starts with http:// or https://
                if not (text.startswith('http://') or text.startswith('https://')):
                    await update.message.reply_text(
                        f"‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL</b>\n\n"
                        f"URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://\n\n"
                        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                        parse_mode='HTML'
                    )
                    return INPUTTING_PARAMS
            
            # Set parameter value
            if 'params' not in session:
                session['params'] = {}
            session['params'][current_param] = text
            session['waiting_for'] = None
            session['current_param'] = None
            session['language_code_custom'] = False
            _record_param_history(session, current_param)
            logger.info(
                "üß© PARAM_SET: action_path=text_input model_id=%s waiting_for=%s current_param=%s outcome=stored",
                model_id,
                session.get('waiting_for'),
                current_param,
            )
            
            # Confirm parameter was set (–ö–†–ò–¢–ò–ß–ù–û: —ç—Ç–æ –≤—Ç–æ—Ä–æ–π –æ—Ç–≤–µ—Ç –ø–æ—Å–ª–µ "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...")
            display_value = text[:100] + '...' if len(text) > 100 else text
            await update.message.reply_text(
                f"‚úÖ <b>{current_param}</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\n\n"
                f"–ó–Ω–∞—á–µ–Ω–∏–µ: {display_value}",
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –≤—Ç–æ—Ä–æ–π –æ—Ç–≤–µ—Ç
            
            # If prompt was entered and model supports image/audio input, offer next steps
            if current_param == 'prompt':
                # IMPORTANT: z-image does NOT support image input (text-to-image only)
                if model_id == "z-image":
                    session['has_image_input'] = False
                    session['waiting_for'] = None

                    # Check for audio_url requirement (unlikely for z-image, but check anyway)
                    if 'audio_url' in input_params or 'audio_input' in input_params:
                        audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
                        audio_required = input_params.get(audio_param_name, {}).get('required', False)
                        
                        if audio_required:
                            keyboard = [
                                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                            ]
                            free_counter_line = await _resolve_free_counter_line(
                                user_id,
                                user_lang,
                                correlation_id,
                                action_path=f"param_prompt:{audio_param_name}",
                                sku_id=session.get("sku_id"),
                            )
                            audio_text = _append_free_counter_text(
                                "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏</b>\n\n"
                                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                                free_counter_line,
                            )
                            await update.message.reply_text(
                                audio_text,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode='HTML'
                            )
                            session['waiting_for'] = audio_param_name
                            session['current_param'] = audio_param_name
                            return INPUTTING_PARAMS
                    
                    try:
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                        await guard.check_and_ensure_response(update, context)
                    except Exception as e:
                        logger.error(f"Error in start_next_parameter for z-image: {e}", exc_info=True)
                        await update.message.reply_text(
                            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                            parse_mode='HTML'
                        )
                        track_outgoing_action(update_id)
                    return INPUTTING_PARAMS

                # Check for audio_url requirement (for non-z-image models)
                if 'audio_url' in input_params or 'audio_input' in input_params:
                    audio_param_name = 'audio_url' if 'audio_url' in input_params else 'audio_input'
                    audio_required = input_params.get(audio_param_name, {}).get('required', False)
                    
                    if audio_required:
                        keyboard = [
                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                        ]
                        free_counter_line = await _resolve_free_counter_line(
                            user_id,
                            user_lang,
                            correlation_id,
                            action_path=f"param_prompt:{audio_param_name}",
                            sku_id=session.get("sku_id"),
                        )
                        audio_text = _append_free_counter_text(
                            "üé§ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏</b>\n\n"
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª (MP3, WAV, OGG, M4A, FLAC, AAC, WMA, MPEG).\n"
                            "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 200 MB",
                            free_counter_line,
                        )
                        await update.message.reply_text(
                            audio_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        session['waiting_for'] = audio_param_name
                        session['current_param'] = audio_param_name
                        return INPUTTING_PARAMS
                    else:
                        keyboard = [
                            [InlineKeyboardButton("üé§ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", callback_data="add_audio")],
                            [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_audio")],
                            [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                        ]
                        free_counter_line = await _resolve_free_counter_line(
                            user_id,
                            user_lang,
                            correlation_id,
                            action_path=f"param_prompt:{audio_param_name}",
                            sku_id=session.get("sku_id"),
                        )
                        audio_prompt = _append_free_counter_text(
                            "üé§ <b>–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ-—Ñ–∞–π–ª (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</b>\n\n"
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ-—Ñ–∞–π–ª –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å', —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
                            free_counter_line,
                        )
                        await update.message.reply_text(
                            audio_prompt,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        session['waiting_for'] = None
                        return INPUTTING_PARAMS

                if session.get('has_image_input'):
                    image_required = False
                    if 'image_urls' in input_params:
                        image_required = input_params['image_urls'].get('required', False)
                    elif 'image_input' in input_params:
                        image_required = input_params['image_input'].get('required', False)
                    optional_media = session.get("optional_media_params", [])
                    if optional_media:
                        image_required = False
                    
                    if image_required:
                        keyboard = [
                            [InlineKeyboardButton("üì∑ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="add_image")],
                        ]
                        image_param_name = 'image_urls' if 'image_urls' in input_params else 'image_input'
                        free_counter_line = await _resolve_free_counter_line(
                            user_id,
                            user_lang,
                            correlation_id,
                            action_path=f"param_prompt:{image_param_name}",
                            sku_id=session.get("sku_id"),
                        )
                        image_text = _append_free_counter_text(
                            "üì∑ <b>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</b>\n\n"
                            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.",
                            free_counter_line,
                        )
                        await update.message.reply_text(
                            image_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        session['waiting_for'] = image_param_name
                        session['current_param'] = image_param_name
                        return INPUTTING_PARAMS
                    else:
                        if session.get("image_ref_prompt"):
                            keyboard = [
                                [
                                    InlineKeyboardButton("‚úÖ –î–∞", callback_data="add_image"),
                                    InlineKeyboardButton("‚ùå –ù–µ—Ç", callback_data="skip_image"),
                                ],
                            ]
                            free_counter_line = await _resolve_free_counter_line(
                                user_id,
                                user_lang,
                                correlation_id,
                                action_path="param_prompt:image_ref",
                                sku_id=session.get("sku_id"),
                            )
                            image_prompt = _append_free_counter_text(
                                "üì∑ <b>–î–æ–±–∞–≤–∏—Ç—å —Ä–µ—Ñ-–∫–∞—Ä—Ç–∏–Ω–∫—É?</b>\n\n"
                                "–†–µ—Ñ-–∫–∞—Ä—Ç–∏–Ω–∫–∞ –ø–æ–º–æ–∂–µ—Ç —É—Ç–æ—á–Ω–∏—Ç—å —Å—Ç–∏–ª—å –∏–ª–∏ –¥–µ—Ç–∞–ª–∏.\n"
                                "–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —ç—Ç–æ—Ç —à–∞–≥.",
                                free_counter_line,
                            )
                            await update.message.reply_text(
                                image_prompt,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode='HTML'
                            )
                        else:
                            keyboard = [
                                [InlineKeyboardButton("üì∑ –î–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="add_image")],
                                [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_image")],
                            ]
                            free_counter_line = await _resolve_free_counter_line(
                                user_id,
                                user_lang,
                                correlation_id,
                                action_path="param_prompt:image_optional",
                                sku_id=session.get("sku_id"),
                            )
                            image_prompt = _append_free_counter_text(
                                "üì∑ <b>–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ?</b>\n\n"
                                "–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–∞–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n"
                                "–ò–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
                                free_counter_line,
                            )
                            await update.message.reply_text(
                                image_prompt,
                                reply_markup=InlineKeyboardMarkup(keyboard),
                                parse_mode='HTML'
                            )
                        session['waiting_for'] = None
                        return INPUTTING_PARAMS
                
                # Check if there are more parameters
                required = session.get('required', [])
                params = session.get('params', {})
                properties = session.get('properties', {})
                model_info = session.get('model_info', {})
                from app.kie_catalog import get_model

                model_spec = session.get("model_spec") or (get_model(model_id) if model_id else None)
                session_gen_type = session.get("gen_type") or (model_spec.model_type if model_spec else None)
                input_params = properties or model_info.get('input_params', {})
                
                # CRITICAL: Apply default values BEFORE checking missing parameters
                # This ensures parameters with default values are automatically applied
                for param_name, param_info in input_params.items():
                    if param_name not in params:
                        default_value = _resolve_unified_default(
                            param_name,
                            param_info,
                            model_spec=model_spec,
                            session_gen_type=session_gen_type,
                        )
                        if default_value is not None:
                            params[param_name] = default_value
                            logger.info(f"‚úÖ Applied default value for {param_name}={default_value} for {model_id}")
                
                # Don't exclude image_input/image_urls/audio_url/audio_input from missing if they're required but not yet provided
                # Only exclude them if they're already in params (uploaded)
                excluded_params = ['prompt']  # Always exclude prompt as it's already processed
                # Only exclude image/audio params if they're already set in params
                if 'image_input' in params or (session.get('image_input') and len(session.get('image_input', [])) > 0):
                    excluded_params.append('image_input')
                if 'image_urls' in params or (session.get('image_urls') and len(session.get('image_urls', [])) > 0):
                    excluded_params.append('image_urls')
                if 'mask_input' in params or (session.get('mask_input') and len(session.get('mask_input', [])) > 0):
                    excluded_params.append('mask_input')
                if 'reference_image_input' in params or (session.get('reference_image_input') and len(session.get('reference_image_input', [])) > 0):
                    excluded_params.append('reference_image_input')
                if 'audio_url' in params or session.get('audio_url'):
                    excluded_params.append('audio_url')
                if 'audio_input' in params or session.get('audio_input'):
                    excluded_params.append('audio_input')
                missing = [p for p in required if p not in params and p not in excluded_params]
                
                # CRITICAL: Ensure image_input/image_urls/mask_input/reference_image_input are considered missing if required and not in params
                # Also check if they're in session but not in params (auto-fix)
                for image_param in ['image_input', 'image_urls', 'mask_input', 'reference_image_input']:
                    if image_param in input_params and input_params[image_param].get('required', False):
                        if image_param not in params:
                            # Check if it's in session but not in params (auto-fix)
                            if image_param in session and session.get(image_param):
                                logger.info(f"‚ö†Ô∏è {image_param} in session but not in params for {model_id}. Auto-fixing...")
                                if isinstance(session[image_param], list):
                                    session['params'][image_param] = session[image_param].copy()
                                else:
                                    session['params'][image_param] = [session[image_param]]
                                logger.info(f"‚úÖ Fixed: {image_param} added to params")
                            else:
                                # Truly missing
                                if image_param not in excluded_params:
                                    missing.append(image_param)
                                    logger.warning(f"‚ö†Ô∏è Required {image_param} missing for {model_id}")
                        else:
                            # Already in params, verify it's not empty
                            if not params.get(image_param):
                                logger.warning(f"‚ö†Ô∏è {image_param} in params but empty for {model_id}")
                                if image_param not in excluded_params:
                                    missing.append(image_param)
                
                # For elevenlabs/speech-to-text, also check optional parameters
                model_id = session.get('model_id', '')
                if model_id == "elevenlabs/speech-to-text":
                    # Check optional parameters that haven't been set yet
                    for opt_param in ['language_code', 'tag_audio_events', 'diarize']:
                        if opt_param in properties and opt_param not in params:
                            missing.append(opt_param)
                
                if missing:
                    # Move to next parameter
                    try:
                        # Small delay to show confirmation
                        await asyncio.sleep(0.5)
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                        # –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        # –ï—Å–ª–∏ –Ω–µ—Ç - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º fallback —á–µ—Ä–µ–∑ NO-SILENCE GUARD
                        await guard.check_and_ensure_response(update, context)
                    except Exception as e:
                        logger.error(f"Error starting next parameter: {e}", exc_info=True)
                        await update.message.reply_text(
                            f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}",
                            parse_mode='HTML'
                        )
                        track_outgoing_action(update_id)
                        return INPUTTING_PARAMS
                else:
                    # All parameters collected, show confirmation
                    model_name = session.get('model_info', {}).get('name', 'Unknown')
                    model_id = session.get('model_id', '')
                    params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                    
                    # –ö–†–ò–¢–ò–ß–ù–û: –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É –∏–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
                    is_admin_user = get_is_admin(user_id)
                    sku_id = session.get("sku_id", "")
                    is_free = await is_free_generation_available(user_id, sku_id)
                    free_info = ""
                    if is_free:
                        remaining = await get_user_free_generations_remaining(user_id)
                        free_info = f"\n\nüéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n"
                        free_info += f"–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                    else:
                        # –ö–†–ò–¢–ò–ß–ù–û: –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–µ–Ω—É
                        price = calculate_price_rub(model_id, params, is_admin_user)
                        if price is None:
                            blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                            await update.message.reply_text(blocked_text, parse_mode="HTML")
                            return INPUTTING_PARAMS
                        price_str = format_rub_amount(price)
                        if is_admin_user:
                            free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> –ë–µ–∑–ª–∏–º–∏—Ç (—Ü–µ–Ω–∞: {price_str})"
                        else:
                            free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}"
                    
                    user_lang = get_user_language(user_id)
                    correlation_id = ensure_correlation_id(update, context)
                    free_counter_line = ""
                    try:
                        free_counter_line = await get_free_counter_line(
                            user_id,
                            user_lang=user_lang,
                            correlation_id=correlation_id,
                            action_path="confirm_screen",
                            sku_id=sku_id,
                        )
                    except Exception as exc:
                        logger.warning("Failed to resolve free counter line: %s", exc)
                    keyboard = [
                        [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                        [
                            InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                            InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                        ],
                        [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                    ]
                    
                    await update.message.reply_text(
                        _append_free_counter_text(
                            (
                                f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                                f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                                f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}{free_info}\n\n"
                                f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?"
                            ),
                            free_counter_line,
                        ),
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='HTML'
                    )
                    return CONFIRMING_GENERATION
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞ –≤ input_parameters: {e}", exc_info=True)
        # –û—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–Ω—è—Ç–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
        try:
            user_lang = get_user_language(user_id)
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
            ]
            await update.message.reply_text(
                f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–≤–æ–¥–∞</b>\n\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
                f"‚Ä¢ –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
                f"‚Ä¢ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ —Å –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–∏\n"
                f"‚Ä¢ –û—Ç–º–µ–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
        except Exception as reply_error:
            logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ: {reply_error}", exc_info=True)
        track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç –æ–± –æ—à–∏–±–∫–µ
        return ConversationHandler.END
    
    # ==================== TASK 1: FALLBACK –¥–ª—è waiting_for == None ====================
    # –ï—Å–ª–∏ waiting_for –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –Ω–æ –ø—Ä–∏—à—ë–ª —Ç–µ–∫—Å—Ç - –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–Ω—è—Ç—å, —á—Ç–æ –¥–µ–ª–∞—Ç—å
    if not waiting_for:
        try:
            # –°—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –¥—É–º–∞–ª, —á—Ç–æ –±–æ—Ç –∑–∞–≤–∏—Å
            await update.message.reply_text(
                "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...",
                parse_mode='HTML'
            )
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –º–æ–¥–µ–ª–∏ prompt –≤ properties/input_params
            model_id = session.get('model_id')
            model_info = session.get('model_info', {})
            properties = session.get('properties', {})
            input_params = model_info.get('input_params', {})
            params = session.get('params', {})
            
            # –ï—Å–ª–∏ —É –º–æ–¥–µ–ª–∏ –µ—Å—Ç—å prompt –≤ input_params –∏ prompt –µ—â—ë –Ω–µ –≤ session['params']
            if 'prompt' in input_params and 'prompt' not in params:
                # –¢—Ä–∞–∫—Ç—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ prompt –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–∞–π–ø–ª–∞–π–Ω
                logger.info(f"üîß AUTO-FIX: Text received but waiting_for=None, treating as prompt for model {model_id}")
                
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º prompt
                if 'params' not in session:
                    session['params'] = {}
                session['params']['prompt'] = text
                session['waiting_for'] = None
                session['current_param'] = None
                _record_param_history(session, 'prompt')
                
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–∞–π–ø–ª–∞–π–Ω –∫–∞–∫ –æ–±—ã—á–Ω–æ
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –µ—â—ë –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
                required = session.get('required', [])
                missing = [p for p in required if p not in params and p != 'prompt']
                
                if missing:
                    # –ï—Å—Ç—å –µ—â—ë –ø–∞—Ä–∞–º–µ—Ç—Ä—ã - –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É
                    try:
                        next_param_result = await start_next_parameter(update, context, user_id)
                        if next_param_result:
                            return next_param_result
                        # –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ start_next_parameter –≤–µ—Ä–Ω—É–ª None, –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        await guard.check_and_ensure_response(update, context)
                    except Exception as e:
                        logger.error(f"Error starting next parameter after auto-fix prompt: {e}", exc_info=True)
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                        await update.message.reply_text(
                            f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É: {str(e)}",
                            parse_mode='HTML'
                        )
                        track_outgoing_action(update_id)
                        return INPUTTING_PARAMS
                else:
                    # –í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–±—Ä–∞–Ω—ã - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
                    try:
                        model_name = model_info.get('name', 'Unknown')
                        params_text = "\n".join([f"  ‚Ä¢ {k}: {str(v)[:50]}..." for k, v in params.items()])
                        
                        is_admin_user = get_is_admin(user_id)
                        sku_id = session.get("sku_id", "")
                        is_free = await is_free_generation_available(user_id, sku_id)
                        free_info = ""
                        if is_free:
                            remaining = await get_user_free_generations_remaining(user_id)
                            free_info = f"\n\nüéÅ <b>–ë–ï–°–ü–õ–ê–¢–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø!</b>\n"
                            free_info += f"–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö: {remaining}/{FREE_GENERATIONS_PER_DAY} –≤ –¥–µ–Ω—å"
                        else:
                            price = calculate_price_rub(model_id, params, is_admin_user)
                            if price is None:
                                logger.error("Missing price for refund on model %s", model_id)
                                price = 0.0
                            if price is None:
                                logger.error("Missing price for refund on model %s", model_id)
                                price = 0.0
                            if price is None:
                                blocked_text = format_pricing_blocked_message(model_id, user_lang=user_lang)
                                await update.message.reply_text(blocked_text, parse_mode="HTML")
                                return INPUTTING_PARAMS
                            price_str = format_rub_amount(price)
                            free_info = f"\n\nüí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {price_str}"
                        
                        user_lang = get_user_language(user_id)
                        keyboard = [
                            [InlineKeyboardButton(t('btn_confirm_generate', lang=user_lang), callback_data="confirm_generate")],
                            [InlineKeyboardButton(_get_settings_label(user_lang), callback_data="show_parameters")],
                            [
                                InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step"),
                                InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")
                            ],
                            [InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")]
                        ]
                        
                        await update.message.reply_text(
                            f"üìã <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:</b>\n\n"
                            f"–ú–æ–¥–µ–ª—å: <b>{model_name}</b>\n"
                            f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n{params_text}{free_info}\n\n"
                            f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é?",
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='HTML'
                        )
                        return CONFIRMING_GENERATION
                    except Exception as e:
                        logger.error(f"Error showing confirmation after auto-fix prompt: {e}", exc_info=True)
            
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å - –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–Ω—è—Ç–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
            user_lang = get_user_language(user_id)
            settings_label = _get_settings_label(user_lang)
            keyboard = []
            if session.get('properties'):
                keyboard.append([InlineKeyboardButton(settings_label, callback_data="show_parameters")])
            if session.get('param_history'):
                keyboard.append([InlineKeyboardButton(t('btn_back', lang=user_lang), callback_data="back_to_previous_step")])
            keyboard.append([InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")])
            keyboard.append([InlineKeyboardButton(t('btn_cancel', lang=user_lang), callback_data="cancel")])
            
            model_name = model_info.get('name', 'Unknown')
            await update.message.reply_text(
                (
                    "üí° <b>–°–µ–π—á–∞—Å —è –∂–¥—É –¥–µ–π—Å—Ç–≤–∏—è —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏</b>\n\n"
                    f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞:\n"
                    "‚Ä¢ –û—Ç–∫—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –≤—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ –∏–∑–º–µ–Ω–∏—Ç—å\n"
                    "‚Ä¢ –ò–ª–∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –º–µ–Ω—é\n"
                    "‚Ä¢ –ò–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é\n\n"
                    "üß™ –ü—Ä–∏–º–µ—Ä: –Ω–∞–∂–º–∏—Ç–µ ¬´‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã¬ª, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è."
                    if user_lang == 'ru'
                    else (
                        "üí° <b>Please use buttons to continue</b>\n\n"
                        f"ü§ñ <b>Model:</b> {model_name}\n\n"
                        "Please:\n"
                        "‚Ä¢ Open parameters and choose what to change\n"
                        "‚Ä¢ Or return to the main menu\n"
                        "‚Ä¢ Or cancel the operation\n\n"
                        "üß™ Example: tap ‚Äú‚öôÔ∏è Parameters‚Äù to edit values."
                    )
                ),
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º fallback –æ—Ç–≤–µ—Ç
            return ConversationHandler.END
            
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ fallback –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞: {e}", exc_info=True)
            try:
                correlation_id = ensure_correlation_id(update, context)
                trace_error(
                    correlation_id,
                    "INTERNAL_EXCEPTION",
                    ERROR_CATALOG.get("INTERNAL_EXCEPTION", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ stacktrace –∏ –ª–æ–≥–∏."),
                    e,
                    force_stacktrace=True,
                    user_id=user_id,
                    chat_id=update.effective_chat.id if update.effective_chat else None,
                    update_id=update.update_id if update else None,
                    action="INPUT_PARAMETERS_FALLBACK",
                    action_path="input_parameters:fallback",
                )
            except Exception:
                logger.debug("input_parameters trace_error failed", exc_info=True)
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            try:
                user_lang = get_user_language(user_id)
                keyboard = [
                    [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")]
                ]
                await update.message.reply_text(
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='HTML'
                )
                track_outgoing_action(update_id)  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç –æ–± –æ—à–∏–±–∫–µ
            except:
                pass
            return ConversationHandler.END
    
    # ==================== NO-SILENCE GUARD: –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê ====================
    # –ï—Å–ª–∏ –º—ã –¥–æ—à–ª–∏ —Å—é–¥–∞ –±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è - —ç—Ç–æ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ë–ê–ì
    # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º fallback
    try:
        outgoing_count = guard.outgoing_actions.get(update_id, 0)
        if outgoing_count > 0:
            logger.info(
                "‚úÖ NO-SILENCE: action_path=input_parameters_end model_id=%s waiting_for=%s current_param=%s outcome=already_replied",
                session.get('model_id'),
                session.get('waiting_for'),
                session.get('current_param'),
            )
            return INPUTTING_PARAMS
        logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è NO-SILENCE VIOLATION: input_parameters reached end without response for user {user_id}, waiting_for={waiting_for}")
        await guard.check_and_ensure_response(update, context)
    except Exception as e:
        logger.error(f"‚ùå CRITICAL: Failed to check NO-SILENCE in input_parameters: {e}", exc_info=True)
        # –ï—Å–ª–∏ –¥–∞–∂–µ check_and_ensure_response —É–ø–∞–ª - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é
        try:
            user_lang = get_user_language(user_id) if user_id else 'ru'
            keyboard = [
                [InlineKeyboardButton(t('btn_home', lang=user_lang), callback_data="back_to_menu")],
                [InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data="back_to_menu")]
            ]
            await update.message.reply_text(
                "‚ö†Ô∏è <b>–Ø –Ω–µ —Å–º–æ–≥ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∞—à –≤–≤–æ–¥.</b>\n\n"
                "–í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
            track_outgoing_action(update_id)
        except Exception as e2:
            logger.error(f"‚ùå CRITICAL: Failed to send NO-SILENCE fallback in input_parameters: {e2}", exc_info=True)
    # ==================== END NO-SILENCE GUARD ====================
    
    return INPUTTING_PARAMS


async def start_generation_directly(
    user_id: int,
    model_id: str,
    params: dict,
    model_info: dict,
    status_message,
    context: ContextTypes.DEFAULT_TYPE
):
    """Start generation directly without callback query. Used for auto-start after photo upload."""
    logger.info(f"üöÄ start_generation_directly called for user {user_id}, model {model_id}")
    
    is_admin_user = get_is_admin(user_id)
    correlation_id = get_correlation_id(None, user_id)
    chat_id = user_id
    
    # Check if user is blocked
    if not is_admin_user and is_user_blocked(user_id):
        await status_message.edit_text(
            "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
            parse_mode='HTML'
        )
        return ConversationHandler.END


async def active_session_router(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Route active sessions to input_parameters before generic handlers."""
    from telegram.ext import ApplicationHandlerStop
    from app.observability.no_silence_guard import get_no_silence_guard

    _create_background_task(
        _check_and_deliver_pending_results(update, context),
        action="pending_result_check",
    )
    if not update.message:
        return
    user_id = update.effective_user.id if update.effective_user else None
    if not user_id:
        return
    if update.message.text:
        command_text = update.message.text.split()[0]
        if command_text in {"/start", "/admin"}:
            return
    session_store = get_session_store(context)
    session = session_store.get(user_id)
    waiting_for = session.get("waiting_for") if isinstance(session, dict) else None
    current_param = session.get("current_param") if isinstance(session, dict) else None
    if not waiting_for and not current_param:
        return

    _log_route_decision_once(
        update,
        context,
        waiting_for=waiting_for or current_param,
        chosen_handler="active_session_router->input_parameters",
        reason="waiting_for_active",
    )
    guard = get_no_silence_guard()
    try:
        await input_parameters(update, context)
    except Exception as exc:
        logger.error("Active session router failed: %s", exc, exc_info=True)
        try:
            await handle_update_exception(
                update,
                context,
                exc,
                stage="router",
                handler="active_session_router",
            )
        except Exception:
            logger.debug("active_session_router exception boundary failed", exc_info=True)
        await guard.check_and_ensure_response(update, context)
    raise ApplicationHandlerStop


async def global_text_router(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Latency wrapper for global text routing."""
    start_ts = time.monotonic()
    try:
        await _global_text_router_impl(update, context)
    finally:
        _log_handler_latency("global_text_router", start_ts, update)


async def _global_text_router_impl(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Global router for TEXT messages - shows main menu when no active session."""
    from telegram.ext import ApplicationHandlerStop
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action

    guard = get_no_silence_guard()
    _create_background_task(
        _check_and_deliver_pending_results(update, context),
        action="pending_result_check",
    )
    update_id = update.update_id
    user_id = update.effective_user.id if update.effective_user else None
    if _should_dedupe_update(
        update,
        context,
        action="TEXT_ROUTER",
        action_path="global_text_router",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
    ):
        return

    session_store = get_session_store(context)
    session = session_store.get(user_id) if user_id else None
    waiting_for = session.get("waiting_for") if isinstance(session, dict) else None
    current_param = session.get("current_param") if isinstance(session, dict) else None
    if waiting_for or current_param:
        return

    if isinstance(session, dict) and session.get("model_id") and session.get("properties"):
        _log_route_decision_once(
            update,
            context,
            waiting_for=None,
            chosen_handler="global_text_router->input_parameters",
            reason="active_model_session_without_waiting_for",
        )
        logger.info(
            "üîÄ GLOBAL_TEXT_ROUTER: Active model session without waiting_for, routing to input_parameters"
        )
        await input_parameters(update, context)
        raise ApplicationHandlerStop

    _log_route_decision_once(
        update,
        context,
        waiting_for=None,
        chosen_handler="global_text_router->main_menu",
        reason="no_active_session",
    )
    logger.info("üîÄ GLOBAL_TEXT_ROUTER: No waiting_for, showing main menu")
    try:
        await ensure_main_menu(update, context, source="global_text_router", prefer_edit=True)
        track_outgoing_action(update_id)
    except Exception as exc:
        logger.error("Error in global_text_router fallback: %s", exc, exc_info=True)
        try:
            await handle_update_exception(
                update,
                context,
                exc,
                stage="router",
                handler="global_text_router",
            )
        except Exception:
            logger.debug("global_text_router exception boundary failed", exc_info=True)
        await guard.check_and_ensure_response(update, context)
    raise ApplicationHandlerStop


async def global_photo_router(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Latency wrapper for global photo routing."""
    start_ts = time.monotonic()
    try:
        await _global_photo_router_impl(update, context)
    finally:
        _log_handler_latency("global_photo_router", start_ts, update)


async def _global_photo_router_impl(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Global router for PHOTO messages - routes to input_parameters if waiting_for expects image."""
    from telegram.ext import ApplicationHandlerStop
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action

    guard = get_no_silence_guard()
    _create_background_task(
        _check_and_deliver_pending_results(update, context),
        action="pending_result_check",
    )
    update_id = update.update_id
    user_id = update.effective_user.id if update.effective_user else None
    if _should_dedupe_update(
        update,
        context,
        action="PHOTO_ROUTER",
        action_path="global_photo_router",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
    ):
        return

    session_store = get_session_store(context)
    session = session_store.get(user_id) if user_id else None
    if isinstance(session, dict):
        waiting_for = session.get('waiting_for')
        current_param = session.get('current_param', waiting_for)
        if waiting_for and current_param in ['image_input', 'image_urls', 'mask_input', 'reference_image_input']:
            try:
                await update.message.reply_text("‚è≥ –ü—Ä–∏–Ω—è—Ç–æ. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ‚Ä¶", parse_mode='HTML')
                track_outgoing_action(update_id)
            except Exception as exc:
                logger.warning("Could not send instant ACK: %s", exc)
            logger.info("üîÄ GLOBAL_PHOTO_ROUTER: Routing to input_parameters (waiting_for=%s)", waiting_for)
            _log_route_decision_once(
                update,
                context,
                waiting_for=waiting_for,
                chosen_handler="global_photo_router->input_parameters",
                reason="waiting_for_image",
            )
            await input_parameters(update, context)
            raise ApplicationHandlerStop

    _log_route_decision_once(
        update,
        context,
        waiting_for=None,
        chosen_handler="global_photo_router->main_menu",
        reason="no_active_session",
    )
    logger.info("üîÄ GLOBAL_PHOTO_ROUTER: Not expecting photo, showing guidance")
    try:
        await show_main_menu(update, context, source="global_photo_router")
        track_outgoing_action(update_id)
    except Exception as exc:
        logger.error("Error in global_photo_router fallback: %s", exc, exc_info=True)
        try:
            await handle_update_exception(
                update,
                context,
                exc,
                stage="router",
                handler="global_photo_router",
            )
        except Exception:
            logger.debug("global_photo_router exception boundary failed", exc_info=True)
        await guard.check_and_ensure_response(update, context)
    raise ApplicationHandlerStop


async def global_audio_router(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Global router for AUDIO/VOICE messages - routes to input_parameters if waiting_for expects audio."""
    from telegram.ext import ApplicationHandlerStop
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action

    guard = get_no_silence_guard()
    update_id = update.update_id
    user_id = update.effective_user.id if update.effective_user else None
    if _should_dedupe_update(
        update,
        context,
        action="AUDIO_ROUTER",
        action_path="global_audio_router",
        user_id=user_id,
        chat_id=update.effective_chat.id if update.effective_chat else None,
    ):
        return

    session_store = get_session_store(context)
    session = session_store.get(user_id) if user_id else None
    if isinstance(session, dict):
        waiting_for = session.get('waiting_for')
        current_param = session.get('current_param', waiting_for)
        if waiting_for and current_param in ['audio_url', 'audio_input']:
            try:
                await update.message.reply_text("‚è≥ –ü—Ä–∏–Ω—è—Ç–æ. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞—É–¥–∏–æ‚Ä¶", parse_mode='HTML')
                track_outgoing_action(update_id)
            except Exception as exc:
                logger.warning("Could not send instant ACK: %s", exc)
            logger.info("üîÄ GLOBAL_AUDIO_ROUTER: Routing to input_parameters (waiting_for=%s)", waiting_for)
            _log_route_decision_once(
                update,
                context,
                waiting_for=waiting_for,
                chosen_handler="global_audio_router->input_parameters",
                reason="waiting_for_audio",
            )
            await input_parameters(update, context)
            raise ApplicationHandlerStop

    _log_route_decision_once(
        update,
        context,
        waiting_for=None,
        chosen_handler="global_audio_router->main_menu",
        reason="no_active_session",
    )
    logger.info("üîÄ GLOBAL_AUDIO_ROUTER: Not expecting audio, showing guidance")
    try:
        await ensure_main_menu(update, context, source="global_audio_router", prefer_edit=True)
        track_outgoing_action(update_id)
    except Exception as exc:
        logger.error("Error in global_audio_router fallback: %s", exc, exc_info=True)
        try:
            await handle_update_exception(
                update,
                context,
                exc,
                stage="router",
                handler="global_audio_router",
            )
        except Exception:
            logger.debug("global_audio_router exception boundary failed", exc_info=True)
        await guard.check_and_ensure_response(update, context)
    raise ApplicationHandlerStop


async def unhandled_update_fallback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Final fallback for any text/photo/audio/document update to prevent silence."""
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action

    user_id = update.effective_user.id if update.effective_user else None
    chat_id = update.effective_chat.id if update.effective_chat else None
    correlation_id = ensure_correlation_id(update, context)
    session_store = get_session_store(context)
    session_snapshot = session_store.snapshot(user_id)
    session = session_store.get(user_id) if user_id else None
    waiting_for = session.get("waiting_for") if isinstance(session, dict) else None
    current_param = session.get("current_param") if isinstance(session, dict) else None
    update_type = _resolve_update_type(update)

    if waiting_for or current_param:
        if update.message and (update.message.text or update.message.caption):
            _log_route_decision_once(
                update,
                context,
                waiting_for=waiting_for or current_param,
                chosen_handler="unhandled_update_fallback->input_parameters",
                reason="waiting_for_in_fallback",
            )
            guard = get_no_silence_guard()
            try:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="UNHANDLED_UPDATE_FALLBACK_SAFE",
                    action_path="fallback",
                    stage="UI_ROUTER",
                    outcome="routed_to_input_parameters",
                    param={
                        "update_type": update_type,
                        "waiting_for": waiting_for,
                        "current_param": current_param,
                    },
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="UX_UNHANDLED_UPDATE_RECOVERED",
                    action_path="fallback",
                    stage="UI_ROUTER",
                    outcome="routed_to_input_parameters",
                    param={
                        "update_type": update_type,
                        "waiting_for": waiting_for,
                        "current_param": current_param,
                    },
                )
                await input_parameters(update, context)
                return
            except Exception as exc:
                logger.error("Fallback routing failed: %s", exc, exc_info=True)
                await guard.check_and_ensure_response(update, context)
                return
        user_lang = get_user_language(user_id) if user_id else "ru"
        param_label = waiting_for or current_param or "–ø–∞—Ä–∞–º–µ—Ç—Ä"
        message_text = (
            f"–Ø –∂–¥—É –≤–≤–æ–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <b>{param_label}</b>."
            if user_lang == "ru"
            else f"I'm waiting for parameter <b>{param_label}</b>."
        )
        menu_label = "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é" if user_lang == "ru" else "üè† Main Menu"
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton(menu_label, callback_data="back_to_menu")]]
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="UNHANDLED_UPDATE_FALLBACK_SAFE",
            action_path="fallback",
            stage="UI_ROUTER",
            outcome="waiting_for_param",
            param={
                "update_type": update_type,
                "waiting_for": waiting_for,
                "current_param": current_param,
            },
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="UX_UNHANDLED_UPDATE_RECOVERED",
            action_path="fallback",
            stage="UI_ROUTER",
            outcome="waiting_for_param",
            param={
                "update_type": update_type,
                "waiting_for": waiting_for,
                "current_param": current_param,
            },
        )
        if chat_id:
            await context.bot.send_message(
                chat_id=chat_id,
                text=message_text,
                parse_mode="HTML",
                reply_markup=keyboard,
            )
            track_outgoing_action(update.update_id, action_type="fallback")
        return

    logger.warning(
        "UNHANDLED_UPDATE correlation_id=%s user_id=%s update_type=%s session=%s",
        correlation_id,
        user_id,
        update_type,
        session_snapshot,
    )
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="UNHANDLED_UPDATE",
        action_path="fallback",
        stage="UI_ROUTER",
        outcome="fallback",
        fix_hint="Ensure ConversationHandler and active-session router precede fallback handlers",
        param={
            "update_type": update_type,
            "session": session_snapshot,
            "waiting_for": waiting_for,
            "current_param": current_param,
        },
    )

    _log_route_decision_once(
        update,
        context,
        waiting_for=None,
        chosen_handler="unhandled_update_fallback->main_menu",
        reason="no_active_session",
    )
    logger.warning(
        "FIX_HINT fallback_triggered check handler order and session waiting_for state"
    )
    guard = get_no_silence_guard()
    try:
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="UNHANDLED_UPDATE_FALLBACK_SAFE",
            action_path="fallback",
            stage="UI_ROUTER",
            outcome="menu_shown",
            param={
                "update_type": update_type,
                "waiting_for": waiting_for,
                "current_param": current_param,
            },
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="UX_UNHANDLED_UPDATE_RECOVERED",
            action_path="fallback",
            stage="UI_ROUTER",
            outcome="menu_shown",
            param={
                "update_type": update_type,
                "waiting_for": waiting_for,
                "current_param": current_param,
            },
        )
        await ensure_main_menu(update, context, source="unhandled_update_fallback", prefer_edit=True)
        track_outgoing_action(update.update_id, action_type="fallback")
    except Exception as exc:
        logger.error("Error in unhandled_update_fallback: %s", exc, exc_info=True)
        await guard.check_and_ensure_response(update, context)
    return


async def confirm_generation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Handle generation confirmation.
    
    ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ê–í–ò–õ–ê KIE AI - –ó–ê–§–ò–ö–°–ò–†–û–í–ê–ù–û –ù–ê–í–°–ï–ì–î–ê:
    
    üî¥ –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï –ü–†–ê–í–ò–õ–û #0 (–ì–õ–ê–í–ù–û–ï):
    –í–°–ï –º–æ–¥–µ–ª–∏ –î–û–õ–ñ–ù–´ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å API Endpoints —Å—Ç—Ä–æ–≥–æ –ø–æ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏:
    https://docs.kie.ai/market - Market Documentation (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û!)
    https://docs.kie.ai/ - Comprehensive API Documentation
    https://kie.ai/ru - –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞
    –ù–ò–ö–ê–ö–ò–• –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π –æ—Ç –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API Endpoints!
    
    1. –í–°–ï –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –î–û–õ–ñ–ù–´ —Å—Ç—Ä–æ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º KIE AI API
    2. –ù–ò–ß–ï–ì–û –æ—Ç —Å–µ–±—è –Ω–µ –ø—Ä–∏–¥—É–º—ã–≤–∞—Ç—å - —Ç–æ–ª—å–∫–æ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ KIE AI
    3. –í–°–ï –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –î–û–õ–ñ–ù–´ –±—ã—Ç—å –∑–∞–ø—Ä–æ—à–µ–Ω—ã —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    4. –í–°–ï –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –î–û–õ–ñ–ù–´ –±—ã—Ç—å –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–Ω—ã –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
    5. –§–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å—Ç—Ä–æ–≥–æ –ø–æ –≤–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω—ã–º —Ñ–∞–π–ª–∞–º (validate_*.py)
    6. –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ç–æ–ª—å–∫–æ —Å–æ–≥–ª–∞—Å–Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º KIE API
    7. –ß–∏—Å–ª–∞ –æ–∫—Ä—É–≥–ª—è—é—Ç—Å—è —Å–æ–≥–ª–∞—Å–Ω–æ step (0.01 –¥–ª—è strength, 0.1 –¥–ª—è guidance_scale)
    8. output_format –≤ lowercase –¥–ª—è qwen –º–æ–¥–µ–ª–µ–π (png, jpeg)
    9. –ù–∏–∫–∞–∫–∏—Ö –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    10. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≤ KIE API
    
    üìö –ò–°–¢–û–ß–ù–ò–ö–ò –ü–†–ê–í–ò–õ:
    - https://docs.kie.ai/market - Market Documentation (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û! Image/Video/Audio Models)
    - https://docs.kie.ai/ - Comprehensive API Documentation
    - https://kie.ai/ru - –†—É—Å—Å–∫–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞
    - llms.txt: https://docs.kie.ai/llms.txt - –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
    
    –°–º. KIE_AI_STRICT_RULES.md –∏ KIE_AI_API_ENDPOINTS_RULE.md –¥–ª—è –ø–æ–ª–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π.
    """
    import time
    start_time = time.time()
    query = update.callback_query
    user_id = update.effective_user.id
    user_lang = get_user_language(user_id) if user_id else "ru"
    from app.storage import get_storage
    storage_instance = get_storage()
    await _answer_callback_early(
        query,
        user_lang=user_lang,
        callback_data=query.data if query else None,
    )
    logger.debug(f"üî•üî•üî• CONFIRM_GENERATION ENTRY: user_id={user_id}, query_id={query.id if query else 'None'}, data={query.data if query else 'None'}")
    from app.observability.no_silence_guard import get_no_silence_guard, track_outgoing_action
    guard = get_no_silence_guard()
    correlation_id = ensure_correlation_id(update, context)
    chat_id = query.message.chat_id if query and query.message else None
    guard.set_trace_context(
        update,
        context,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        message_id=query.message.message_id if query and query.message else None,
        update_type="callback",
        correlation_id=correlation_id,
        action="CONFIRM_GENERATE",
        action_path="confirm_generate",
        stage="UI_ROUTER",
        outcome="received",
    )
    trace_event(
        "info",
        correlation_id,
        event="TRACE_IN",
        stage="UI_ROUTER",
        update_type="callback",
        action="CONFIRM_GENERATE",
        action_path="confirm_generate",
        user_id=user_id,
        chat_id=chat_id,
        message_id=query.message.message_id if query and query.message else None,
    )
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="CONFIRM_GENERATE",
        action_path="confirm_generate",
        outcome="received",
    )

    job_id: Optional[str] = None
    
    # Answer callback immediately if present
    if query:
        try:
            await query.answer()
        except Exception as e:
            logger.warning(f"Could not answer callback query: {e}")
    
    is_admin_user = get_is_admin(user_id)
    
    # Helper function to send/edit messages safely
    async def send_or_edit_message(text, parse_mode='HTML', reply_markup=None):
        result_message = None
        try:
            action_type = "send_message"
            if query:
                query_has_bot = getattr(query, "_bot", None) is not None
                if not query_has_bot and query.message and context.bot:
                    result_message = await context.bot.edit_message_text(
                        chat_id=query.message.chat_id,
                        message_id=query.message.message_id,
                        text=text,
                        parse_mode=parse_mode,
                        reply_markup=reply_markup,
                    )
                    action_type = "edit_message_text"
                else:
                    try:
                        result_message = await query.edit_message_text(
                            text,
                            parse_mode=parse_mode,
                            reply_markup=reply_markup,
                        )
                        action_type = "edit_message_text"
                    except Exception as edit_error:
                        logger.warning(f"Could not edit message: {edit_error}, sending new")
                        try:
                            if query.message and context.bot:
                                result_message = await context.bot.edit_message_text(
                                    chat_id=query.message.chat_id,
                                    message_id=query.message.message_id,
                                    text=text,
                                    parse_mode=parse_mode,
                                    reply_markup=reply_markup,
                                )
                                action_type = "edit_message_text"
                            else:
                                raise RuntimeError("callback_message_missing")
                        except Exception:
                            try:
                                result_message = await context.bot.send_message(
                                    chat_id=user_id,
                                    text=text,
                                    parse_mode=parse_mode,
                                    reply_markup=reply_markup,
                                )
                                action_type = "send_message"
                            except Exception as send_error:
                                logger.error(f"Could not send new message: {send_error}")
            else:
                result_message = await context.bot.send_message(
                    chat_id=user_id,
                    text=text,
                    parse_mode=parse_mode,
                    reply_markup=reply_markup,
                )
                action_type = "send_message"
            track_outgoing_action(update.update_id, action_type=action_type)
        except Exception as e:
            logger.error(f"Error in send_or_edit_message: {e}", exc_info=True)
            try:
                result_message = await context.bot.send_message(chat_id=user_id, text=text, parse_mode=parse_mode)
                track_outgoing_action(update.update_id, action_type="send_message")
            except Exception:
                pass
        return result_message

    def _build_generation_status_keyboard(user_lang: str, job_id: Optional[str]) -> InlineKeyboardMarkup:
        status_label = "üìä –°—Ç–∞—Ç—É—Å" if user_lang == "ru" else "üìä Status"
        cancel_label = t("btn_cancel", lang=user_lang)
        cancel_callback = _build_cancel_callback(job_id) if job_id else "cancel"
        return InlineKeyboardMarkup(
            [
                [InlineKeyboardButton(status_label, callback_data="my_generations")],
                [
                    InlineKeyboardButton(cancel_label, callback_data=cancel_callback),
                    InlineKeyboardButton(t("btn_home", lang=user_lang), callback_data="back_to_menu"),
                ],
            ]
        )

    # Check if user is blocked
    if not is_admin_user and is_user_blocked(user_id):
        await send_or_edit_message(
            "‚ùå <b>–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏."
        )
        return ConversationHandler.END
    
    if user_id not in user_sessions:
        logger.error(f"‚ùå‚ùå‚ùå CRITICAL: Session not found in confirm_generation! user_id={user_id}, available_sessions={list(user_sessions.keys())[:10]}")
        
        # CRITICAL: Try to restore from backup in context.user_data
        if hasattr(context, 'user_data') and context.user_data.get('session_backup_user_id') == user_id:
            session_backup = context.user_data.get('session_backup')
            if session_backup:
                logger.warning(f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Restoring session from context.user_data backup for user_id={user_id}")
                user_sessions[user_id] = session_backup.copy()
                logger.info(f"‚úÖ‚úÖ‚úÖ Session restored from context.user_data: user_id={user_id}, model_id={session_backup.get('model_id')}")
            else:
                await send_or_edit_message("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
                return ConversationHandler.END
        else:
            await send_or_edit_message("‚ùå –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
            return ConversationHandler.END
    
    session = user_sessions[user_id]
    logger.info(f"‚úÖ‚úÖ‚úÖ Session found in confirm_generation: user_id={user_id}, model_id={session.get('model_id')}, params_keys={list(session.get('params', {}).keys())}")

    job_id = session.get("job_id")
    
    # CRITICAL: If task_id already exists in session, show actionable screen instead of silence
    task_id_existing = session.get("task_id")
    if task_id_existing:
        existing_job_id = job_id
        job_status = None
        job_record = await storage_instance.get_job(existing_job_id) if existing_job_id else None
        if not job_record:
            job_record = await _find_job_by_task_id(storage_instance, task_id_existing)
            if job_record and not existing_job_id:
                existing_job_id = job_record.get("job_id") or task_id_existing
                session["job_id"] = existing_job_id
        if job_record:
            job_status = job_record.get("status")
        if _is_terminal_job_status(job_status):
            session["task_terminal_state"] = job_status
            _clear_user_task_context(
                user_id,
                reason=f"terminal_{job_status}_precheck",
                task_id=task_id_existing,
                allow_mismatch=True,
            )
        else:
            logger.warning(
                "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Task %s already exists in session for user %s, showing already-started screen",
                task_id_existing,
                user_id,
            )
            await _show_task_already_started(
                update,
                context,
                user_lang=user_lang,
                task_id=task_id_existing,
                job_id=existing_job_id,
                reason="task_exists_session",
                correlation_id=correlation_id,
            )
            return ConversationHandler.END
    model_id = (
        session.get("model_id")
        or session.get("active_model_id")
        or session.get("model_info", {}).get("id")
    )
    if not model_id and session.get("sku_id"):
        model_id = str(session.get("sku_id")).split("::", 1)[0]
    if model_id:
        session["model_id"] = model_id
        session["active_model_id"] = model_id
    else:
        await send_or_edit_message("‚ùå –°–µ—Å—Å–∏—è –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start")
        return ConversationHandler.END
    params = session.get('params', {})
    model_info = session.get('model_info', {})

    missing_media = _collect_missing_required_media(session)
    if missing_media:
        user_lang = get_user_language(user_id) if user_id else "ru"
        missing_param = missing_media[0]
        param_label = _humanize_param_name(missing_param, user_lang)
        media_kind = _get_media_kind(missing_param) or "media"
        media_label_ru = {
            "image": "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
            "video": "–≤–∏–¥–µ–æ",
            "audio": "–∞—É–¥–∏–æ",
            "document": "—Ñ–∞–π–ª",
            "media": "–º–µ–¥–∏–∞",
        }.get(media_kind, "–º–µ–¥–∏–∞")
        media_label_en = {
            "image": "image",
            "video": "video",
            "audio": "audio",
            "document": "file",
            "media": "media",
        }.get(media_kind, "media")
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="GEN_BLOCKED_MISSING_REQUIRED_INPUTS",
            action_path="confirm_generate",
            model_id=model_id,
            gen_type=session.get("gen_type"),
            stage="UI_VALIDATE",
            outcome="blocked",
            error_code="GEN_BLOCKED_MISSING_REQUIRED_INPUTS",
            fix_hint="–ó–∞–ø—Ä–æ—Å–∏—Ç–µ –∑–∞–≥—Ä—É–∑–∫—É –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –º–µ–¥–∏–∞-–≤—Ö–æ–¥–∞.",
            missing_fields=missing_media,
        )
        await send_or_edit_message(
            (
                f"üìé <b>–ù—É–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å {media_label_ru}</b>\n\n"
                f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ: <b>{param_label}</b>.\n"
                "–ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–º–æ–∂–µ—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é."
                if user_lang == "ru"
                else (
                    f"üìé <b>Please upload the required {media_label_en}</b>\n\n"
                    f"Please upload: <b>{param_label}</b>.\n"
                    "After upload you can confirm generation."
                )
            ),
            parse_mode="HTML",
        )
        await prompt_for_specific_param(update, context, user_id, missing_param, source="missing_media")
        return INPUTTING_PARAMS

    kie_ready, kie_state = _kie_readiness_state()
    if not kie_ready:
        user_lang = get_user_language(user_id) if user_id else "ru"
        fix_hint = "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (KIE_API_KEY) –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–∏—Å."
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="KIE_NOT_READY",
            action_path="confirm_generate",
            model_id=model_id,
            gen_type=session.get("gen_type"),
            stage="KIE_SUBMIT",
            outcome="blocked",
            error_code="KIE_NOT_READY",
            fix_hint=fix_hint,
            param={"state": kie_state},
        )
        if user_lang == "ru":
            user_message = (
                "‚ö†Ô∏è <b>KIE API –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω</b>\n\n"
                "–ù–µ –∑–∞–¥–∞–Ω KIE_API_KEY, –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.\n"
                "–ß—Ç–æ —Å–¥–µ–ª–∞—Ç—å: –ø—Ä–æ–≤–µ—Ä—å—Ç–µ ENV –Ω–∞ Render –∏–ª–∏ —Å–æ–æ–±—â–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
            )
        else:
            user_message = (
                "‚ö†Ô∏è <b>KIE API not configured</b>\n\n"
                "KIE_API_KEY is missing. Generations are temporarily unavailable.\n"
                "Please check ENV or contact the admin."
            )
        await send_or_edit_message(user_message, parse_mode="HTML")
        return ConversationHandler.END

    # CRITICAL: Check if task already exists in active_generations to prevent duplicate
    duplicate_task_id = None
    duplicate_job_id = None
    async with active_generations_lock:
        user_active_generations = [(uid, tid) for (uid, tid) in active_generations.keys() if uid == user_id]
        if user_active_generations:
            # Check if there's a recent generation for this model (within last 10 seconds)
            import time
            current_time = time.time()
            for (uid, tid) in user_active_generations:
                gen_session = active_generations.get((uid, tid))
                if gen_session and gen_session.get('model_id') == model_id:
                    created_time = gen_session.get('created_at', current_time)
                    if current_time - created_time < 10:  # Within 10 seconds
                        duplicate_task_id = tid
                        duplicate_job_id = gen_session.get("job_id") if gen_session else None
                        logger.warning(
                            "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Duplicate generation detected! Task %s was created recently for user %s, model %s",
                            tid,
                            user_id,
                            model_id,
                        )
                        break
    if duplicate_task_id:
        await _show_task_already_started(
            update,
            context,
            user_lang=user_lang,
            task_id=duplicate_task_id,
            job_id=duplicate_job_id,
            reason="task_exists_active",
            correlation_id=correlation_id,
        )
        return ConversationHandler.END
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–¥–∞–ø—Ç–µ—Ä –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    from kie_input_adapter import normalize_for_generation
    
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: –ø—Ä–∏–º–µ–Ω—è–µ–º –¥–µ—Ñ–æ–ª—Ç—ã, –≤–∞–ª–∏–¥–∏—Ä—É–µ–º, –∞–¥–∞–ø—Ç–∏—Ä—É–µ–º –∫ API
    api_params, validation_errors = normalize_for_generation(model_id, params)
    
    if validation_errors:
        # –û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        user_lang = get_user_language(user_id) if user_id else 'ru'
        error_text = (
            f"‚ùå <b>–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</b>\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"{chr(10).join('‚Ä¢ ' + err for err in validation_errors[:5])}\n\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        ) if user_lang == 'ru' else (
            f"‚ùå <b>Parameter validation error</b>\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"{chr(10).join('‚Ä¢ ' + err for err in validation_errors[:5])}\n\n"
            f"Please check parameters and try again."
        )

        await send_or_edit_message(
            error_text,
            reply_markup=build_back_to_menu_keyboard(user_lang),
        )
        return ConversationHandler.END
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º api_params –≤–º–µ—Å—Ç–æ params
    params = api_params

    prompt_value = params.get("prompt") or params.get("text") or params.get("caption")
    prompt_hash = prompt_summary(prompt_value).get("prompt_hash")
    if not prompt_hash:
        prompt_hash = _build_request_fingerprint(model_id, params)
        logger.info(
            "prompt_hash_fallback_used: model_id=%s prompt_hash=%s request_id=%s",
            model_id,
            prompt_hash,
            session.get("request_id"),
        )
    request_id = session.get("request_id") or correlation_id or str(uuid.uuid4())
    session["request_id"] = request_id
    session["prompt_hash"] = prompt_hash
    partner_id = (os.getenv("PARTNER_ID") or os.getenv("BOT_INSTANCE_ID") or "default").strip() or "default"
    submit_lock_key = _build_generation_submit_lock_key(
        partner_id=partner_id,
        user_id=user_id,
        chat_id=chat_id or user_id,
        fingerprint=prompt_hash,
    )
    if not await _acquire_generation_submit_lock(submit_lock_key):
        user_lang = get_user_language(user_id) if user_id else "ru"
        remaining_seconds = max(1, int(math.ceil(_generation_submit_lock_remaining(submit_lock_key))))
        throttle_text = (
            "‚è≥ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–∂–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è</b>\n\n"
            f"–ü–æ–¥–æ–∂–¥–∏—Ç–µ {remaining_seconds} —Å–µ–∫ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            if user_lang == "ru"
            else (
                "‚è≥ <b>Generation already starting</b>\n\n"
                f"Please wait {remaining_seconds}s and try again."
            )
        )

        await send_or_edit_message(
            throttle_text,
            reply_markup=build_back_to_menu_keyboard(user_lang),
        )
        return ConversationHandler.END
    from app.observability.correlation_store import register_correlation_ids

    await register_correlation_ids(
        correlation_id=correlation_id,
        request_id=request_id,
        task_id=session.get("task_id"),
        job_id=session.get("job_id"),
        user_id=user_id,
        model_id=model_id,
        storage=storage_instance,
        source="confirm_generate.start",
    )
    log_request_event(
        request_id=request_id,
        user_id=user_id,
        model=model_id,
        prompt_hash=prompt_hash,
        task_id=None,
        job_id=job_id,
        status="ui_received",
        latency_ms=0,
        attempt=0,
        error_code=None,
        error_msg=None,
        correlation_id=correlation_id,
    )
    
    logger.info(
        "‚úÖ Input normalized from SSOT: model_id=%s keys=%s",
        model_id,
        list(params.keys()),
    )
    
    # Check if this is a free generation (do not consume upfront)
    sku_id = session.get("sku_id", "")
    free_result = await check_free_generation_available(
        user_id,
        sku_id,
        correlation_id=correlation_id,
    )
    if free_result.get("status") == "deny":
        user_lang = get_user_language(user_id)
        deny_text = (
            f"‚ùå <b>–õ–∏–º–∏—Ç –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω</b>\n\n"
            "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ª–∏–º–∏—Ç –ø–æ–ø–æ–ª–Ω–∏—Ç—Å—è –∑–∞–≤—Ç—Ä–∞.\n"
            "üí≥ –ú–æ–∂–µ—Ç–µ –ø–æ–ø–æ–ª–Ω–∏—Ç—å —Å—á–µ—Ç, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏."
            if user_lang == "ru"
            else (
                f"‚ùå <b>Free generation limit reached</b>\n\n"
                "Free limit resets tomorrow.\n"
                "üí≥ Top up to keep using the tools."
            )
        )
        await send_or_edit_message(
            deny_text,
            reply_markup=build_back_to_menu_keyboard(user_lang),
        )
        return ConversationHandler.END
    is_free = free_result.get("status") == "ok"
    
    # Calculate price (admins pay admin price, users pay user price)
    mode_index = _resolve_mode_index(model_id, params, user_id)
    price_quote = _update_price_quote(
        session,
        model_id=model_id,
        mode_index=mode_index,
        gen_type=session.get("gen_type"),
        params=params,
        correlation_id=correlation_id,
        update_id=update.update_id,
        action_path="confirm_generate",
        user_id=user_id,
        chat_id=chat_id,
        is_admin=is_admin_user,
    )
    if not price_quote and is_test_mode():
        price_quote = {
            "price_rub": "0.00",
            "currency": "RUB",
            "breakdown": {
                "model_id": model_id,
                "mode_index": mode_index,
                "gen_type": session.get("gen_type"),
                "params": dict(params or {}),
                "sku_id": session.get("sku_id") or "test_mode",
                "test_mode_fallback": True,
            },
        }
        session["price_quote"] = price_quote
        session.setdefault("sku_id", "test_mode")
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            action="PRICE_CALC",
            action_path="confirm_generate",
            model_id=model_id,
            gen_type=session.get("gen_type"),
            stage="PRICE_CALC",
            outcome="test_mode_fallback",
            param={
                "price_rub": price_quote.get("price_rub"),
                "mode_index": mode_index,
                "test_mode": True,
            },
        )
    if not price_quote:
        user_lang = get_user_language(user_id)
        free_remaining = free_result.get("base_remaining") if isinstance(free_result, dict) else None
        if free_remaining is None and isinstance(free_result, dict):
            free_remaining = free_result.get("remaining")
        await respond_price_undefined(
            update,
            context,
            session=session,
            user_lang=user_lang,
            model_id=model_id,
            gen_type=session.get("gen_type"),
            sku_id=session.get("sku_id"),
            price_quote=price_quote,
            free_remaining=free_remaining,
            correlation_id=correlation_id,
            action_path="confirm_generate",
        )
        return ConversationHandler.END
    price = float(price_quote.get("price_rub", 0))
    log_structured_event(
        correlation_id=correlation_id,
        user_id=user_id,
        chat_id=chat_id,
        update_id=update.update_id,
        action="PRICE_CALC",
        action_path="confirm_generate",
        model_id=model_id,
        gen_type=session.get("gen_type"),
        stage="PRICE_CALC",
        outcome="success",
        param={
            "price_rub": price_quote.get("price_rub"),
            "mode_index": mode_index,
            "breakdown": price_quote.get("breakdown", {}),
            "is_admin": is_admin_user,
        },
    )
    trace_event(
        "info",
        correlation_id,
        event="PRICE_CALC",
        stage="PRICE_CALC",
        update_type="callback",
        action="CONFIRM_GENERATE",
        action_path="confirm_generate",
        user_id=user_id,
        chat_id=chat_id,
        model_id=model_id,
        price_rub=price_quote.get("price_rub"),
        is_admin=is_admin_user,
        pricing_source="catalog",
        always_fields=[
            "model_id",
            "price_rub",
            "is_admin",
            "pricing_source",
        ],
    )
    
    # For free generations, price is 0
    if is_free:
        price = 0.0
    
    user_balance: Optional[float] = None
    # Check balance/limit before generation
    if not is_admin_user:
        # Regular user - check balance (unless free generation)
        if not is_free:
            user_balance = await get_user_balance_async(user_id)
            if user_balance < price:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update.update_id,
                    action="BALANCE_GATE",
                    action_path="confirm_generate",
                    model_id=model_id,
                    gen_type=session.get("gen_type"),
                    stage="BALANCE_GATE",
                    outcome="failed",
                    error_code="ERR_BALANCE_LOW",
                    fix_hint="–ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.",
                    param={"price_rub": price, "balance_rub": user_balance},
                )
                user_lang = get_user_language(user_id)
                await send_or_edit_message(
                    _build_insufficient_funds_text(user_lang, price, user_balance),
                    reply_markup=_build_insufficient_funds_keyboard(user_lang),
                )
                return ConversationHandler.END
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="BALANCE_GATE",
                action_path="confirm_generate",
                model_id=model_id,
                gen_type=session.get("gen_type"),
                stage="BALANCE_GATE",
                outcome="passed",
                param={"price_rub": price, "balance_rub": user_balance},
            )
    elif user_id != ADMIN_ID:
        # Limited admin - check limit
        remaining = get_admin_remaining(user_id)
        if remaining < price:
            price_str = format_rub_amount(price)
            remaining_str = format_rub_amount(remaining)
            limit = get_admin_limit(user_id)
            spent = get_admin_spent(user_id)
            await send_or_edit_message(
                f"‚ùå <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç</b>\n\n"
                f"üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è:</b> {price_str}\n"
                f"üí≥ <b>–õ–∏–º–∏—Ç:</b> {format_rub_amount(limit)}\n"
                f"üí∏ <b>–ü–æ—Ç—Ä–∞—á–µ–Ω–æ:</b> {format_rub_amount(spent)}\n"
                f"‚úÖ <b>–û—Å—Ç–∞–ª–æ—Å—å:</b> {remaining_str}\n\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞."
            )
            return ConversationHandler.END
    
    if not is_admin_user and not is_free:
        user_lang = get_user_language(user_id)
        if user_balance is None:
            user_balance = await get_user_balance_async(user_id)
        await send_or_edit_message(
            _build_price_preview_text(user_lang, price, user_balance),
        )

    model_name = model_info.get('name', model_id) if model_info else model_id
    user_lang = get_user_language(user_id) if user_id else 'ru'
    free_counter_line = ""
    try:
        free_counter_line = await get_free_counter_line(
            user_id,
            user_lang=user_lang,
            correlation_id=correlation_id,
            action_path="confirm_generate",
            sku_id=sku_id,
        )
    except Exception as exc:
        logger.warning("Failed to resolve free counter line: %s", exc)
    loading_msg = (
        "üîÑ <b>–°–æ–∑–¥–∞—é –∑–∞–¥–∞—á—É –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...</b>\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        "‚è≥ <b>–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –∑–∞–ø—Ä–æ—Å</b>\n\n"
        "ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {model_name}\n\n"
        "üí° –û–±—ã—á–Ω–æ —ç—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥..."
    ).format(model_name=model_name) if user_lang == 'ru' else (
        "üîÑ <b>Creating generation task...</b>\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        "‚è≥ <b>Please wait, processing your request</b>\n\n"
        "ü§ñ <b>Model:</b> {model_name}\n\n"
        "üí° Usually takes a few seconds..."
    ).format(model_name=model_name)
    loading_msg = _append_free_counter_text(loading_msg, free_counter_line)
    request_key = None
    task_created_event: Optional[asyncio.Event] = None
    jobs_filename = os.path.basename(str(getattr(storage_instance, "jobs_file", "generation_jobs.json")))
    chat_id_value = chat_id or user_id

    def _build_accept_text(task_id_value: str, *, dedup_join: bool = False) -> str:
        if user_lang == "ru":
            join_line = "üîÅ –≠—Ç–æ –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å ‚Äî –ø–æ–¥–ø–∏—Å—ã–≤–∞—é –Ω–∞ —É–∂–µ —Å–æ–∑–¥–∞–Ω–Ω—É—é –∑–∞–¥–∞—á—É.\n\n" if dedup_join else ""
            return (
                "‚úÖ <b>–ó–∞–¥–∞—á–∞ –ø—Ä–∏–Ω—è—Ç–∞</b>\n\n"
                f"{join_line}"
                f"Task ID: <code>{task_id_value}</code>\n"
                "–ü—Ä–∏—à–ª—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—é–¥–∞, –∫–∞–∫ —Ç–æ–ª—å–∫–æ –æ–Ω –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤."
            )
        join_line = "üîÅ This is a duplicate request ‚Äî joining the existing task.\n\n" if dedup_join else ""
        return (
            "‚úÖ <b>Task accepted</b>\n\n"
            f"{join_line}"
            f"Task ID: <code>{task_id_value}</code>\n"
            "I'll send the result here as soon as it's ready."
        )

    async def _upsert_generation_job_meta(
        *,
        job_id_value: Optional[str],
        task_id_value: Optional[str],
        status_value: str,
        message_id_value: Optional[int],
    ) -> None:
        if not job_id_value or not hasattr(storage_instance, "update_json_file"):
            return
        now_iso = datetime.now().isoformat()

        def updater(data: Dict[str, Any]) -> Dict[str, Any]:
            next_data = dict(data or {})
            existing = next_data.get(job_id_value, {})
            record = dict(existing) if isinstance(existing, dict) else {}
            if not record:
                record = {
                    "job_id": job_id_value,
                    "user_id": user_id,
                    "model_id": model_id,
                    "model_name": model_name,
                    "prompt": prompt_value,
                    "prompt_hash": prompt_hash,
                    "correlation_id": correlation_id,
                    "params": params,
                    "price": price,
                    "sku_id": sku_id,
                    "is_free": bool(is_free),
                    "is_admin_user": bool(is_admin_user),
                    "task_id": task_id_value,
                    "external_task_id": task_id_value,
                    "status": status_value,
                    "created_at": now_iso,
                    "updated_at": now_iso,
                    "result_urls": [],
                }
            existing_status = str(record.get("status") or "").lower()
            if existing_status in {"delivered", "completed"} and status_value in {
                "queued",
                "waiting",
                "success",
                "result_validated",
                "tg_deliver",
                "timeout",
                "delivery_pending",
                "running",
            }:
                next_status = existing_status
            else:
                next_status = status_value
            record.update(
                {
                    "task_id": task_id_value or record.get("task_id"),
                    "external_task_id": task_id_value or record.get("external_task_id"),
                    "status": next_status,
                    "request_id": request_id,
                    "correlation_id": correlation_id,
                    "prompt": prompt_value,
                    "prompt_hash": prompt_hash,
                    "chat_id": chat_id_value,
                    "message_id": message_id_value or record.get("message_id"),
                    "sku_id": sku_id or record.get("sku_id"),
                    "price": price,
                    "is_free": bool(is_free),
                    "is_admin_user": bool(is_admin_user),
                    "updated_at": now_iso,
                }
            )
            record.setdefault("created_at", now_iso)
            next_data[job_id_value] = record
            return next_data

        await storage_instance.update_json_file(jobs_filename, updater)

    async def _upsert_delivery_record(
        *,
        task_id_value: Optional[str],
        job_id_value: Optional[str],
        status_value: str,
        message_id_value: Optional[int],
    ) -> tuple[bool, bool]:
        if not task_id_value or not hasattr(storage_instance, "update_json_file"):
            return False, False
        now_iso = datetime.now().isoformat()
        delivery_key = f"{user_id}:{task_id_value}"
        already_delivered = False
        already_pending = False

        def updater(data: Dict[str, Any]) -> Dict[str, Any]:
            nonlocal already_delivered, already_pending
            next_data = dict(data or {})
            existing = next_data.get(delivery_key, {})
            record = dict(existing) if isinstance(existing, dict) else {}
            existing_status = str(record.get("status") or "").lower()
            pending_transition = status_value in {
                "queued",
                "waiting",
                "success",
                "result_validated",
                "tg_deliver",
                "timeout",
                "delivery_pending",
                "running",
            }
            if existing_status == "delivered":
                already_delivered = True
                next_status = "delivered"
            elif pending_transition:
                next_status = "pending"
                if existing_status in {"pending", "delivering"}:
                    already_pending = True
            else:
                next_status = status_value
            record.update(
                {
                    "user_id": user_id,
                    "task_id": task_id_value,
                    "job_id": job_id_value,
                    "model_id": model_id,
                    "request_id": request_id,
                    "correlation_id": correlation_id,
                    "prompt_hash": prompt_hash,
                    "chat_id": chat_id_value,
                    "message_id": message_id_value or record.get("message_id"),
                    "sku_id": sku_id or record.get("sku_id"),
                    "price": price,
                    "is_free": bool(is_free),
                    "is_admin_user": bool(is_admin_user),
                    "status": next_status,
                    "created_at": record.get("created_at", now_iso),
                    "updated_at": now_iso,
                }
            )
            next_data[delivery_key] = record
            return next_data

        await storage_instance.update_json_file("delivery_records.json", updater)
        return already_delivered, already_pending

    async def _persist_delivery_tracking(
        *,
        task_id_value: Optional[str],
        job_id_value: Optional[str],
        status_value: str,
        message_id_value: Optional[int],
        dedup_join: bool = False,
    ) -> None:
        if not task_id_value:
            return
        await _upsert_generation_job_meta(
            job_id_value=job_id_value,
            task_id_value=task_id_value,
            status_value=status_value,
            message_id_value=message_id_value,
        )
        already_delivered, already_pending = await _upsert_delivery_record(
            task_id_value=task_id_value,
            job_id_value=job_id_value,
            status_value=status_value,
            message_id_value=message_id_value,
        )
        await register_correlation_ids(
            correlation_id=correlation_id,
            request_id=request_id,
            task_id=task_id_value,
            job_id=job_id_value,
            user_id=user_id,
            model_id=model_id,
            storage=storage_instance,
            source="confirm_generate.delivery_tracking",
        )
        if already_delivered:
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id_value,
                action="DELIVERY_PENDING_SKIPPED",
                action_path="confirm_generate",
                model_id=model_id,
                task_id=task_id_value,
                job_id=job_id_value,
                stage="DELIVERY_PENDING",
                outcome="skipped",
                param={"reason": "delivery_already_delivered"},
            )
            return
        if already_pending:
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id_value,
                action="DELIVERY_PENDING_SKIPPED",
                action_path="confirm_generate",
                model_id=model_id,
                task_id=task_id_value,
                job_id=job_id_value,
                stage="DELIVERY_PENDING",
                outcome="skipped",
                param={"reason": "delivery_already_pending"},
            )
            return
        log_structured_event(
            correlation_id=correlation_id,
            request_id=request_id,
            user_id=user_id,
            chat_id=chat_id_value,
            action="DELIVERY_PENDING",
            action_path="confirm_generate",
            model_id=model_id,
            task_id=task_id_value,
            job_id=job_id_value,
            stage="DELIVERY_PENDING",
            outcome="dedup_join" if dedup_join else "pending",
            param={"message_id": message_id_value},
        )

    async def _ensure_job_created() -> bool:
        nonlocal job_id
        if job_id:
            return False
        job_id = f"job-{uuid.uuid4().hex[:12]}"
        session["job_id"] = job_id
        session["job_state"] = "queued"
        session["job_start_ts_ms"] = _now_ms()
        _create_job_record(
            job_id=job_id,
            user_id=user_id,
            chat_id=chat_id,
            message_id=query.message.message_id if query and query.message else None,
            model_id=session.get("model_id"),
            correlation_id=correlation_id,
            state="queued",
            start_ts_ms=session["job_start_ts_ms"],
            request_id=request_id,
            prompt=prompt_value,
            prompt_hash=prompt_hash,
        )
        _log_job_state_update(
            correlation_id=correlation_id,
            update_id=update.update_id,
            user_id=user_id,
            chat_id=chat_id,
            message_id=query.message.message_id if query and query.message else None,
            callback_query_id=query.id if query else None,
            callback_data=query.data if query else None,
            job_id=job_id,
            state_before=None,
            state_after="queued",
        )
        if request_key:
            _request_tracker.set(request_key, job_id)
        from app.generations.request_dedupe_store import set_job_task_mapping

        await set_job_task_mapping(job_id, None)
        await register_correlation_ids(
            correlation_id=correlation_id,
            request_id=request_id,
            task_id=None,
            job_id=job_id,
            user_id=user_id,
            model_id=model_id,
            storage=storage_instance,
            source="confirm_generate.job_created",
        )
        log_structured_event(
            correlation_id=correlation_id,
            request_id=request_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CONFIRM_GENERATE",
            action_path="confirm_generate",
            model_id=model_id,
            job_id=job_id,
            outcome="started",
        )
        return True

    async def _on_task_created(task_id: str) -> None:
        nonlocal task_created_event
        session["task_id"] = task_id
        try:
            from app.generations.request_dedupe_store import set_job_task_mapping, update_dedupe_entry

            if job_id:
                _update_job_record(job_id, task_id=task_id, updated_ts_ms=_now_ms())
                await set_job_task_mapping(job_id, task_id)
            if request_key:
                _request_tracker.update_task_id(request_key, task_id)
            if prompt_hash and job_id:
                await update_dedupe_entry(
                    user_id,
                    model_id,
                    prompt_hash,
                    job_id=job_id,
                    task_id=task_id,
                    status="task_created",
                    request_id=request_id,
                    last_recovery_ts=time.time(),
                )
        except Exception as exc:
            logger.warning("dedupe_on_task_created_failed task_id=%s error=%s", task_id, exc)
        await register_correlation_ids(
            correlation_id=correlation_id,
            request_id=request_id,
            task_id=task_id,
            job_id=job_id,
            user_id=user_id,
            model_id=model_id,
            storage=storage_instance,
            source="confirm_generate.task_created",
        )
        if task_created_event:
            task_created_event.set()
    if prompt_hash:
        from app.generations.request_dedupe_store import (
            DedupeEntry,
            delete_dedupe_entry,
            delete_job_task_mapping,
            get_dedupe_entry,
            get_dedupe_entry_by_request_id,
            get_task_id_for_job,
            set_dedupe_entry,
            set_job_task_mapping,
            update_dedupe_entry,
        )
        from app.utils.distributed_lock import distributed_lock

        request_key = build_request_key(user_id, model_id, prompt_hash)
        failed_dedupe_states = {"failed", "cancelled", "canceled"}

        async def _bind_existing_task(
            *,
            task_id_value: str,
            job_id_value: Optional[str],
            status_value: str = "queued",
        ) -> Optional[str]:
            nonlocal job_id
            effective_job_id = job_id_value
            if not effective_job_id:
                await _ensure_job_created()
                effective_job_id = job_id
            else:
                job_id = effective_job_id
                session["job_id"] = effective_job_id
                if not _get_job_record(effective_job_id):
                    _create_job_record(
                        job_id=effective_job_id,
                        user_id=user_id,
                        chat_id=chat_id_value,
                        message_id=query.message.message_id if query and query.message else None,
                        model_id=session.get("model_id"),
                        correlation_id=correlation_id,
                        state=status_value,
                        start_ts_ms=_now_ms(),
                        request_id=request_id,
                        prompt=prompt_value,
                        prompt_hash=prompt_hash,
                    )
            session["task_id"] = task_id_value
            session["job_state"] = status_value
            if effective_job_id:
                _update_job_record(
                    effective_job_id,
                    task_id=task_id_value,
                    external_task_id=task_id_value,
                    state=status_value,
                    updated_ts_ms=_now_ms(),
                )
                await set_job_task_mapping(effective_job_id, task_id_value)
            if request_key:
                tracker_entry = _request_tracker.get(request_key)
                if effective_job_id and (
                    not tracker_entry or tracker_entry.job_id != effective_job_id
                ):
                    _request_tracker.set(request_key, effective_job_id, task_id=task_id_value)
                else:
                    _request_tracker.update_task_id(request_key, task_id_value)
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                job_id=effective_job_id,
                task_id=task_id_value,
                status=status_value,
                request_id=request_id,
                last_recovery_ts=time.time(),
            )
            return effective_job_id

        async def _mark_dedupe_broken(entry: Optional[DedupeEntry], reason: str) -> None:
            job_id_value = entry.job_id if entry else None
            log_request_event(
                request_id=request_id,
                user_id=user_id,
                model=model_id,
                prompt_hash=prompt_hash,
                task_id=entry.task_id if entry else None,
                job_id=job_id_value,
                status="dedupe_broken",
                latency_ms=0,
                attempt=0,
                error_code="DEDUPE_BROKEN",
                error_msg=reason,
                correlation_id=correlation_id,
            )
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="CONFIRM_GENERATE",
                action_path="confirm_generate",
                model_id=model_id,
                job_id=job_id_value,
                outcome="dedupe_broken",
                dedup_hit=True,
                existing_task_id=None,
                error_code="DEDUPE_BROKEN",
                fix_hint=reason,
            )
            if job_id_value:
                await delete_job_task_mapping(job_id_value)
            await delete_dedupe_entry(user_id, model_id, prompt_hash)
            _request_tracker.delete(request_key)

        async def _resolve_task_id_for_entry(entry: DedupeEntry) -> tuple[Optional[str], Optional[DedupeEntry]]:
            current = entry
            for attempt in range(max(1, DEDUPE_TASK_RESOLUTION_ATTEMPTS)):
                status_value = (current.status or "").lower()
                if status_value in failed_dedupe_states:
                    return None, current
                candidate = current.task_id
                tracker_entry = _request_tracker.get(request_key)
                job_id_value = current.job_id or (tracker_entry.job_id if tracker_entry else None)
                if not candidate and tracker_entry and tracker_entry.task_id:
                    candidate = tracker_entry.task_id
                if not candidate and job_id_value:
                    mapped_task_id = await get_task_id_for_job(job_id_value)
                    candidate = mapped_task_id or await _resolve_task_id_from_job(job_id_value)
                if candidate and job_id_value:
                    await set_job_task_mapping(job_id_value, candidate)
                    updated = await update_dedupe_entry(
                        user_id,
                        model_id,
                        prompt_hash,
                        job_id=job_id_value,
                        task_id=candidate,
                        status="waiting",
                        request_id=request_id,
                        last_recovery_ts=time.time(),
                    )
                    _request_tracker.update_task_id(request_key, candidate)
                    return candidate, updated
                if attempt < DEDUPE_TASK_RESOLUTION_ATTEMPTS - 1:
                    await asyncio.sleep(DEDUPE_TASK_RESOLUTION_DELAY_SECONDS)
                    refreshed = await get_dedupe_entry(user_id, model_id, prompt_hash)
                    if refreshed:
                        current = refreshed
            return current.task_id, current
        dedupe_entry = await get_dedupe_entry_by_request_id(request_id)
        if dedupe_entry and (
            dedupe_entry.prompt_hash != prompt_hash or dedupe_entry.model_id != model_id
        ):
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id,
                action="DEDUPE_REQUEST_ID",
                action_path="confirm_generate",
                model_id=model_id,
                outcome="mismatch",
                param={
                    "mapped_model_id": dedupe_entry.model_id,
                    "mapped_prompt_hash": dedupe_entry.prompt_hash,
                    "current_prompt_hash": prompt_hash,
                },
            )
            dedupe_entry = None
        if not dedupe_entry:
            dedupe_entry = await get_dedupe_entry(user_id, model_id, prompt_hash)
        elif dedupe_entry.task_id or dedupe_entry.job_id:
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id,
                action="DEDUPE_REQUEST_ID",
                action_path="confirm_generate",
                model_id=model_id,
                job_id=dedupe_entry.job_id,
                existing_task_id=dedupe_entry.task_id,
                outcome="hit",
            )
        if dedupe_entry:
            existing_task_id, dedupe_entry = await _resolve_task_id_for_entry(dedupe_entry)
            if not existing_task_id:
                await _mark_dedupe_broken(dedupe_entry, "dedupe_store_missing_task_id")
            else:
                log_request_event(
                    request_id=request_id,
                    user_id=user_id,
                    model=model_id,
                    prompt_hash=prompt_hash,
                    task_id=existing_task_id,
                    job_id=dedupe_entry.job_id,
                    status="deduped",
                    latency_ms=0,
                    attempt=0,
                    error_code="DUPLICATE_REQUEST",
                    error_msg="dedupe_store_hit",
                    correlation_id=correlation_id,
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    action="CONFIRM_GENERATE",
                    action_path="confirm_generate",
                    model_id=model_id,
                    outcome="dedup_joined",
                    dedup_hit=True,
                    existing_task_id=existing_task_id,
                    job_id=dedupe_entry.job_id,
                )
                effective_job_id = await _bind_existing_task(
                    task_id_value=existing_task_id,
                    job_id_value=dedupe_entry.job_id,
                    status_value="waiting",
                )
                if effective_job_id:
                    dedupe_entry.job_id = effective_job_id
                await _persist_delivery_tracking(
                    task_id_value=existing_task_id,
                    job_id_value=dedupe_entry.job_id,
                    status_value="waiting",
                    message_id_value=None,
                    dedup_join=True,
                )
                status_keyboard = _build_generation_status_keyboard(user_lang, dedupe_entry.job_id)
                if dedupe_entry.status in {"success", "result_validated", "completed", "finished", "delivered"} and (
                    dedupe_entry.result_urls or dedupe_entry.result_text
                ):
                    try:
                        from app.generations.telegram_sender import send_result_file

                        delivered = False
                        if dedupe_entry.media_type and dedupe_entry.result_urls:
                            delivered = bool(
                                await send_result_file(
                                    context.bot,
                                    chat_id_value,
                                    dedupe_entry.media_type,
                                    dedupe_entry.result_urls,
                                    dedupe_entry.result_text,
                                    model_id=model_id,
                                    gen_type=session.get("gen_type"),
                                    correlation_id=correlation_id,
                                    request_id=request_id,
                                    prompt_hash=prompt_hash,
                                    params=params,
                                    model_label=model_name,
                                    task_id=existing_task_id,
                                    job_id=dedupe_entry.job_id,
                                )
                            )
                        if not delivered:
                            result_text = dedupe_entry.result_text or ""
                            urls_text = "\n".join(dedupe_entry.result_urls or [])
                            task_line = f"Task ID: <code>{existing_task_id}</code>\n\n"
                            await send_or_edit_message(
                                (
                                    "‚úÖ <b>–ì–æ—Ç–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç</b>\n\n"
                                    f"{task_line}{result_text}\n{urls_text}"
                                    if user_lang == "ru"
                                    else f"‚úÖ <b>Result</b>\n\n{task_line}{result_text}\n{urls_text}"
                                ),
                                parse_mode="HTML",
                                reply_markup=status_keyboard,
                            )
                    except Exception as exc:
                        logger.warning("Failed to re-send deduped result: %s", exc)
                        await send_or_edit_message(
                            (
                                "‚úÖ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤</b>\n\n"
                                "–ù–∞–∂–º–∏—Ç–µ ¬´–°—Ç–∞—Ç—É—Å¬ª, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Å–ø–∏—Å–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π."
                                if user_lang == "ru"
                                else "‚úÖ <b>Result ready</b>\n\nTap Status to view your generations."
                            ),
                            parse_mode="HTML",
                            reply_markup=status_keyboard,
                        )
                else:
                    accept_message = await send_or_edit_message(
                        _build_accept_text(existing_task_id, dedup_join=True),
                        parse_mode="HTML",
                        reply_markup=status_keyboard,
                    )
                    await _persist_delivery_tracking(
                        task_id_value=existing_task_id,
                        job_id_value=dedupe_entry.job_id,
                        status_value="waiting",
                        message_id_value=accept_message.message_id if accept_message else None,
                        dedup_join=True,
                    )
                return ConversationHandler.END
        existing = _request_tracker.get(request_key)
        if existing:
            existing_task_id = existing.task_id or await _resolve_task_id_from_job(existing.job_id)
            if not existing_task_id:
                broken_entry = DedupeEntry(
                    user_id=user_id,
                    model_id=model_id,
                    prompt_hash=prompt_hash,
                    job_id=existing.job_id,
                    task_id=existing.task_id,
                    status="waiting",
                    request_id=request_id,
                )
                await _mark_dedupe_broken(broken_entry, "request_tracker_missing_task_id")
            else:
                effective_job_id = await _bind_existing_task(
                    task_id_value=existing_task_id,
                    job_id_value=existing.job_id,
                    status_value="waiting",
                )
                job_id_value = effective_job_id or existing.job_id
                await _persist_delivery_tracking(
                    task_id_value=existing_task_id,
                    job_id_value=job_id_value,
                    status_value="waiting",
                    message_id_value=None,
                    dedup_join=True,
                )
                log_request_event(
                    request_id=request_id,
                    user_id=user_id,
                    model=model_id,
                    prompt_hash=prompt_hash,
                    task_id=existing_task_id,
                    job_id=job_id_value,
                    status="deduped",
                    latency_ms=0,
                    attempt=0,
                    error_code="DUPLICATE_REQUEST",
                    error_msg="duplicate_within_window",
                    correlation_id=correlation_id,
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    action="CONFIRM_GENERATE",
                    action_path="confirm_generate",
                    model_id=model_id,
                    outcome="dedup_joined",
                    dedup_hit=True,
                    existing_task_id=existing_task_id,
                    job_id=job_id_value,
                )
                status_keyboard = _build_generation_status_keyboard(user_lang, job_id_value)
                accept_message = await send_or_edit_message(
                    _build_accept_text(existing_task_id, dedup_join=True),
                    parse_mode="HTML",
                    reply_markup=status_keyboard,
                )
                await _persist_delivery_tracking(
                    task_id_value=existing_task_id,
                    job_id_value=job_id_value,
                    status_value="waiting",
                    message_id_value=accept_message.message_id if accept_message else None,
                    dedup_join=True,
                )
                return ConversationHandler.END
        lock_key = f"gen:{user_id}:{model_id}:{prompt_hash}"
        async with distributed_lock(
            lock_key,
            ttl_seconds=180,
            wait_seconds=DEDUPE_LOCK_WAIT_SECONDS,
            max_attempts=4,
            backoff_base=0.5,
            backoff_cap=2.0,
            jitter=0.25,
        ) as lock_result:
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id,
                action="CONFIRM_GENERATE",
                action_path="confirm_generate",
                model_id=model_id,
                job_id=job_id,
                lock_key=lock_key,
                lock_wait_ms_total=lock_result.wait_ms_total,
                lock_attempts=lock_result.attempts,
                lock_ttl_s=lock_result.ttl_seconds,
                lock_acquired=bool(lock_result),
                dedup_hit=False,
                existing_task_id=None,
                outcome="locked_wait" if lock_result.wait_ms_total > 0 else "started",
            )
            if not lock_result:
                dedupe_entry = await get_dedupe_entry(user_id, model_id, prompt_hash)
                if dedupe_entry:
                    existing_task_id, dedupe_entry = await _resolve_task_id_for_entry(dedupe_entry)
                    if existing_task_id:
                        effective_job_id = await _bind_existing_task(
                            task_id_value=existing_task_id,
                            job_id_value=dedupe_entry.job_id,
                            status_value="waiting",
                        )
                        job_id_value = effective_job_id or dedupe_entry.job_id
                        if effective_job_id:
                            dedupe_entry.job_id = effective_job_id
                        await _persist_delivery_tracking(
                            task_id_value=existing_task_id,
                            job_id_value=job_id_value,
                            status_value="waiting",
                            message_id_value=None,
                            dedup_join=True,
                        )
                        status_keyboard = _build_generation_status_keyboard(user_lang, job_id_value)
                        accept_message = await send_or_edit_message(
                            _build_accept_text(existing_task_id, dedup_join=True),
                            parse_mode="HTML",
                            reply_markup=status_keyboard,
                        )
                        await _persist_delivery_tracking(
                            task_id_value=existing_task_id,
                            job_id_value=job_id_value,
                            status_value="waiting",
                            message_id_value=accept_message.message_id if accept_message else None,
                            dedup_join=True,
                        )
                        log_structured_event(
                            correlation_id=correlation_id,
                            user_id=user_id,
                            chat_id=chat_id,
                            action="CONFIRM_GENERATE",
                            action_path="confirm_generate",
                            model_id=model_id,
                            outcome="dedup_joined",
                            dedup_hit=True,
                            existing_task_id=existing_task_id,
                            job_id=job_id_value,
                        )
                        return ConversationHandler.END
                    await _mark_dedupe_broken(dedupe_entry, "lock_timeout_missing_task_id")
                await send_or_edit_message(
                    (
                        "‚è≥ <b>–ò–¥—ë—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n"
                        "–ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–°—Ç–∞—Ç—É—Å¬ª."
                        if user_lang == "ru"
                        else "‚è≥ <b>Parallel generation in progress</b>\n\nPlease wait or tap Status."
                    ),
                    parse_mode="HTML",
                    reply_markup=_build_generation_status_keyboard(user_lang, None),
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    request_id=request_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    action="CONFIRM_GENERATE",
                    action_path="confirm_generate",
                    model_id=model_id,
                    job_id=job_id,
                    outcome="locked_timeout",
                    lock_key=lock_key,
                    lock_wait_ms_total=lock_result.wait_ms_total,
                    lock_attempts=lock_result.attempts,
                    lock_ttl_s=lock_result.ttl_seconds,
                    lock_acquired=False,
                    fix_hint="–ò–¥—ë—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è, –¥–æ–∂–¥–∏—Å—å –∏–ª–∏ –Ω–∞–∂–º–∏ –°—Ç–∞—Ç—É—Å.",
                )
                return ConversationHandler.END
            await _ensure_job_created()
            if job_id:
                await set_job_task_mapping(job_id, None)
                await set_dedupe_entry(
                    DedupeEntry(
                        user_id=user_id,
                        model_id=model_id,
                        prompt_hash=prompt_hash,
                        job_id=job_id,
                        task_id=None,
                        status="create_start",
                        request_id=request_id,
                    )
                )
    await _ensure_job_created()
    status_keyboard = _build_generation_status_keyboard(user_lang, job_id)
    status_message = await send_or_edit_message(loading_msg, reply_markup=status_keyboard)
    status_message_id = status_message.message_id if status_message else None
    await _upsert_generation_job_meta(
        job_id_value=job_id,
        task_id_value=session.get("task_id"),
        status_value="queued",
        message_id_value=status_message_id,
    )

    from app.generations.user_messages import (
        build_delivery_message,
        build_error_message,
        build_queued_message,
        build_start_message,
        build_waiting_message,
    )

    # Progress tracking state
    last_progress_ts = 0.0
    last_stage = None

    async def progress_callback(event: Dict[str, Any]) -> None:
        nonlocal last_progress_ts, last_stage, status_message
        if not status_message:
            return
        
        stage = event.get("stage")
        if not stage:
            return

        # Limit updates to avoid flood limits
        now = time.monotonic()
        min_interval = float(event.get("min_interval") or 3)
        if stage == last_stage and now - last_progress_ts < min_interval:
            return
        
        last_progress_ts = now
        last_stage = stage
        
        # Build progress message based on stage
        if stage == "KIE_CREATE":
            progress_msg = build_start_message(model_name, correlation_id, lang=user_lang)
        elif stage == "KIE_POLL":
            state_raw = event.get("state") or ""
            progress_msg = build_waiting_message(
                model_name,
                correlation_id,
                lang=user_lang,
                state_hint=state_raw or None,
            )
        elif stage == "KIE_COMPLETE":
            progress_msg = build_delivery_message(model_name, correlation_id, lang=user_lang)
        else:
            return
        
        progress_msg = _append_free_counter_text(progress_msg, free_counter_line)
        
        try:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="PROGRESS_UPDATE",
                action_path="confirm_generate.progress",
                model_id=model_id,
                stage="PROGRESS_INDICATOR",
                outcome="attempt",
                param={"stage": stage, "tg_method": "edit_message_text"},
            )
            await status_message.edit_text(progress_msg, parse_mode="HTML", reply_markup=status_keyboard)
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="PROGRESS_UPDATE",
                action_path="confirm_generate.progress",
                model_id=model_id,
                stage="PROGRESS_INDICATOR",
                outcome="success",
                param={"stage": stage},
            )
        except Exception as send_exc:
            logger.warning("Progress update failed: %s", send_exc)

    try:
        from app.generations.telegram_sender import send_result_file
        from app.generations.universal_engine import (
            run_generation,
            KIEJobFailed,
            KIEResultError,
            KIERequestFailed,
        )
        from app.kie_catalog import get_model

        model_spec = get_model(model_id)
        if not model_spec:
            await send_or_edit_message("‚ùå <b>–ú–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–∞—Ç–∞–ª–æ–≥–µ</b>")
            return ConversationHandler.END

        timeout_seconds = get_generation_timeout_seconds(model_spec)
        poll_interval = int(os.getenv("KIE_POLL_INTERVAL", "3"))

        dry_run = is_dry_run() or not allow_real_generation()
        if dry_run:
            is_video = any(kw in model_id.lower() for kw in ['video', 'sora', 'kling', 'wan', 'hailuo'])
            ext = '.mp4' if is_video else '.png'
            task_id = f"dry_run_{uuid.uuid4().hex[:12]}"
            mock_url = f"https://example.com/mock/{model_id.replace('/', '_')}/{task_id}{ext}"
            message_text = (
                f"‚úÖ <b>DRY-RUN: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–∞</b>\n\nüîó {mock_url}"
                if user_lang == "ru"
                else f"‚úÖ <b>DRY-RUN: generation simulated</b>\n\nüîó {mock_url}"
            )
            await status_message.edit_text(message_text, parse_mode="HTML")
            if prompt_hash:
                await update_dedupe_entry(
                    user_id,
                    model_id,
                    prompt_hash,
                    task_id=task_id,
                    status="delivered",
                    request_id=request_id,
                    media_type="video" if is_video else "image",
                    result_urls=[mock_url],
                )
            return ConversationHandler.END

        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GENERATION_STARTED",
            action_path="confirm_generate",
            model_id=model_id,
            gen_type=session.get("gen_type"),
            stage="GEN_START",
            outcome="start",
        )
        log_task_lifecycle(
            state="create_start",
            user_id=user_id,
            task_id=session.get("task_id"),
            job_id=job_id,
            model_id=model_id,
            correlation_id=correlation_id,
            source="confirm_generate",
        )
        if job_id:
            state_before = session.get("job_state")
            session["job_state"] = "create_start"
            _update_job_record(job_id, state="create_start", updated_ts_ms=_now_ms())
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="create_start",
            )
        job_result = await run_generation_with_tracking(
            user_id,
            run_generation(
                user_id,
                model_id,
                params,
                correlation_id=correlation_id,
                progress_callback=progress_callback,
                timeout=timeout_seconds,
                poll_interval=poll_interval,
                wait_for_result=False,
                request_id=request_id,
                prompt_hash=prompt_hash,
                prompt=prompt_value,
                job_id=job_id,
                chat_id=chat_id_value,
                message_id=status_message_id,
                sku_id=sku_id,
                price=price,
                is_free=is_free,
                is_admin_user=is_admin_user,
                on_task_created=_on_task_created,
            ),
        )
        task_id = job_result.task_id
        session["task_id"] = task_id
        if not is_free and not is_admin_user and price > 0:
            charge_result = await _charge_balance_once(
                user_id=user_id,
                task_id=task_id,
                sku_id=sku_id,
                model_id=model_id,
                price=price,
                correlation_id=correlation_id,
                chat_id=chat_id_value,
            )
            if charge_result.get("status") in {"charged", "duplicate"}:
                session["balance_charged"] = True
                _ensure_session_task_registry(session, "charged_task_ids").add(task_id)
        if job_id:
            from app.generations.request_dedupe_store import set_job_task_mapping

            await set_job_task_mapping(job_id, task_id)
            _update_job_record(job_id, task_id=task_id, updated_ts_ms=_now_ms())
        if request_key:
            _request_tracker.update_task_id(request_key, task_id)
            if prompt_hash:
                await update_dedupe_entry(
                    user_id,
                    model_id,
                    prompt_hash,
                    job_id=job_id,
                    task_id=task_id,
                    status="queued",
                    request_id=request_id,
                )

        if user_id not in saved_generations:
            saved_generations[user_id] = {}
        saved_generations[user_id] = {
            "model_id": model_id,
            "model_info": model_info,
            "params": params.copy(),
            "properties": session.get("properties", {}).copy(),
            "required": session.get("required", []).copy(),
            "request_id": request_id,
            "prompt_hash": prompt_hash,
        }

        await _persist_delivery_tracking(
            task_id_value=task_id,
            job_id_value=job_id,
            status_value="queued",
            message_id_value=status_message_id,
        )
        queued_text = build_queued_message(model_name, correlation_id, lang=user_lang)
        if is_free:
            try:
                free_counter_line = await get_free_counter_line(
                    user_id,
                    user_lang=user_lang,
                    correlation_id=correlation_id,
                    action_path="confirm_generate_post_consume",
                    sku_id=sku_id,
                )
            except Exception as exc:
                logger.warning("Failed to refresh free counter line after consume: %s", exc)
            queued_text = _append_free_counter_text(queued_text, free_counter_line)
        accept_message = await send_or_edit_message(
            queued_text,
            parse_mode="HTML",
            reply_markup=status_keyboard,
        )
        accept_message_id = accept_message.message_id if accept_message else status_message_id
        await _persist_delivery_tracking(
            task_id_value=task_id,
            job_id_value=job_id,
            status_value="queued",
            message_id_value=accept_message_id,
        )
        if job_id:
            state_before = session.get("job_state")
            session["job_state"] = "queued"
            _update_job_record(
                job_id,
                state="queued",
                task_id=task_id,
                external_task_id=task_id,
                message_id=accept_message_id,
                updated_ts_ms=_now_ms(),
            )
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id_value,
                message_id=accept_message_id or status_message_id,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="queued",
            )
        log_request_event(
            request_id=request_id,
            user_id=user_id,
            model=model_id,
            prompt_hash=prompt_hash,
            task_id=task_id,
            job_id=job_id,
            status="queued",
            latency_ms=int((time.time() - start_time) * 1000),
            attempt=0,
            error_code=None,
            error_msg=None,
            correlation_id=correlation_id,
        )
        log_task_lifecycle(
            state="queued",
            user_id=user_id,
            task_id=task_id,
            job_id=job_id,
            model_id=model_id,
            correlation_id=correlation_id,
            source="confirm_generate",
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id_value,
            action="GENERATION_QUEUED",
            action_path="confirm_generate",
            model_id=model_id,
            task_id=task_id,
            job_id=job_id,
            stage="GEN_START",
            outcome="queued",
        )
        from app.generations.state_machine import normalize_provider_state, CANONICAL_SUCCESS_STATES

        state_resolution = normalize_provider_state(job_result.state)
        immediate_result = state_resolution.canonical_state in CANONICAL_SUCCESS_STATES
        if not immediate_result:
            return ConversationHandler.END

        delivered = False
        if job_result.urls or job_result.text:
            model_name_display = model_info.get("name", model_id) if model_info else model_id
            pending_payload = {
                "chat_id": user_id,
                "media_type": job_result.media_type,
                "urls": job_result.urls,
                "text": job_result.text,
                "model_id": model_id,
                "gen_type": session.get("gen_type"),
                "correlation_id": correlation_id,
                "request_id": request_id,
                "prompt_hash": prompt_hash,
                "params": params,
                "model_label": model_name_display,
                "task_id": job_result.task_id,
                "job_id": job_id,
                "sku_id": sku_id,
                "price": price,
                "is_free": is_free,
                "is_admin_user": is_admin_user,
                "session": session,
            }
            async with pending_deliveries_lock:
                pending_deliveries[(user_id, job_result.task_id)] = pending_payload
            try:
                await storage_instance.update_json_file(
                    "delivery_records.json",
                    lambda data: {
                        **data,
                        f"{user_id}:{job_result.task_id}": {
                            **data.get(f"{user_id}:{job_result.task_id}", {}),
                            "user_id": user_id,
                            "task_id": job_result.task_id,
                            "job_id": job_id,
                            "model_id": model_id,
                            "request_id": request_id,
                            "status": "pending",
                            "updated_at": datetime.now().isoformat(),
                            "created_at": data.get(f"{user_id}:{job_result.task_id}", {}).get(
                                "created_at",
                                datetime.now().isoformat(),
                            ),
                        },
                    },
                )
            except Exception as exc:
                logger.warning("Failed to persist delivery record: %s", exc)
            try:
                delivered = bool(
                    await send_result_file(
                        context.bot,
                        user_id,
                        job_result.media_type,
                        job_result.urls,
                        job_result.text,
                        model_id=model_id,
                        gen_type=session.get("gen_type"),
                        correlation_id=correlation_id,
                        request_id=request_id,
                        prompt_hash=prompt_hash,
                        params=params,
                        model_label=model_name_display,
                        task_id=job_result.task_id,
                        job_id=job_id,
                    )
                )
            except Exception as exc:
                delivered = False
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    action="DELIVERY_FAIL",
                    action_path="confirm_generate",
                    model_id=model_id,
                    stage="TG_DELIVER",
                    outcome="failed",
                    error_code="TG_DELIVER_EXCEPTION",
                    fix_hint=str(exc),
                    param={"task_id": job_result.task_id},
                )

            if delivered:
                async with pending_deliveries_lock:
                    pending_deliveries.pop((user_id, job_result.task_id), None)
                try:
                    await storage_instance.update_job_status(
                        job_id,
                        "delivered",
                        result_urls=job_result.urls,
                    )
                except Exception as storage_exc:
                    logger.warning("Failed to update storage job completion: %s", storage_exc)
                if prompt_hash:
                    await update_dedupe_entry(
                        user_id,
                        model_id,
                        prompt_hash,
                        task_id=job_result.task_id,
                        status="delivered",
                        request_id=request_id,
                        media_type=job_result.media_type,
                        result_urls=job_result.urls,
                        result_text=job_result.text,
                    )
                try:
                    await storage_instance.update_json_file(
                        "delivery_records.json",
                        lambda data: {
                            **data,
                            f"{user_id}:{job_result.task_id}": {
                                **data.get(f"{user_id}:{job_result.task_id}", {}),
                                "status": "delivered",
                                "updated_at": datetime.now().isoformat(),
                                "delivered_at": datetime.now().isoformat(),
                                "result_urls": job_result.urls,
                            },
                        },
                    )
                except Exception as exc:
                    logger.warning("Failed to persist delivery record: %s", exc)
                log_task_lifecycle(
                    state="delivered",
                    user_id=user_id,
                    task_id=job_result.task_id,
                    job_id=job_id,
                    model_id=model_id,
                    correlation_id=correlation_id,
                    source="confirm_generate",
                )
                if not dry_run:
                    await _commit_post_delivery_charge(
                        session=session,
                        user_id=user_id,
                        chat_id=chat_id,
                        task_id=job_result.task_id,
                        sku_id=sku_id,
                        price=price,
                        is_free=is_free,
                        is_admin_user=is_admin_user,
                        correlation_id=correlation_id,
                        model_id=model_id,
                    )
                else:
                    logger.info(
                        "üîß DRY-RUN: Skipping charge/free decrement for task %s user %s",
                        job_result.task_id,
                        user_id,
                    )
                if is_free:
                    try:
                        free_counter_line = await get_free_counter_line(
                            user_id,
                            user_lang=user_lang,
                            correlation_id=correlation_id,
                            action_path="confirm_generate.post_consume",
                            sku_id=sku_id,
                        )
                    except Exception as exc:
                        logger.warning("Failed to refresh free counter after consume: %s", exc)
                try:
                    snapshot = await get_free_counter_snapshot(user_id)
                    log_structured_event(
                        correlation_id=correlation_id,
                        user_id=user_id,
                        chat_id=chat_id,
                        action="FREE_QUOTA_REFRESH",
                        action_path="confirm_generate",
                        model_id=model_id,
                        stage="FREE_QUOTA",
                        outcome="snapshot",
                        param={
                            "remaining": snapshot.get("remaining"),
                            "used_today": snapshot.get("used_today"),
                            "limit_per_day": snapshot.get("limit_per_day"),
                        },
                    )
                except Exception as exc:
                    logger.warning("Failed to refresh free counter snapshot: %s", exc)
            else:
                log_structured_event(
                    correlation_id=correlation_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    action="DELIVERY_FAIL",
                    action_path="confirm_generate",
                    model_id=model_id,
                    stage="TG_DELIVER",
                    outcome="failed",
                    error_code="TG_DELIVER_NOT_CONFIRMED",
                    fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç–∞–≤–∫—É –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∫—É.",
                    param={"task_id": job_result.task_id},
                )
                try:
                    await storage_instance.update_json_file(
                        "delivery_records.json",
                        lambda data: {
                            **data,
                            f"{user_id}:{job_result.task_id}": {
                                **data.get(f"{user_id}:{job_result.task_id}", {}),
                                "status": "failed",
                                "updated_at": datetime.now().isoformat(),
                            },
                        },
                    )
                except Exception as exc:
                    logger.warning("Failed to persist delivery record: %s", exc)
                retry_keyboard = InlineKeyboardMarkup(
                    [
                        [InlineKeyboardButton("üîÅ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É", callback_data=f"retry_delivery:{job_result.task_id}")],
                        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")],
                    ]
                )
                await send_or_edit_message(
                    "‚ö†Ô∏è <b>–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ—Å—Ç–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</b>\n\n"
                    "–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤, –Ω–æ Telegram –Ω–µ –ø—Ä–∏–Ω—è–ª –æ—Ç–ø—Ä–∞–≤–∫—É.\n"
                    "–ù–∞–∂–º–∏—Ç–µ ¬´–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É¬ª, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ä–∞–∑.",
                    parse_mode="HTML",
                    reply_markup=retry_keyboard,
                )
                return ConversationHandler.END
        else:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="DELIVERY_FAIL",
                action_path="confirm_generate",
                model_id=model_id,
                stage="TG_DELIVER",
                outcome="failed",
                error_code="EMPTY_RESULT",
                fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ—Ç–≤–µ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ (urls/text).",
                param={"task_id": job_result.task_id},
            )
            await send_or_edit_message(
                "‚ö†Ô∏è <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—É—Å—Ç–æ–π</b>\n\n"
                "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å.",
                parse_mode="HTML",
            )
            return ConversationHandler.END

        if job_result.urls or job_result.text:
            history_params = params.copy()
            if job_result.text and not job_result.urls:
                history_params["result_text"] = job_result.text
            save_generation_to_history(
                user_id=user_id,
                model_id=model_id,
                model_name=model_info.get("name", model_id) if model_info else model_id,
                params=history_params,
                result_urls=job_result.urls.copy(),
                task_id=task_id,
                price=price,
                is_free=is_free,
                correlation_id=correlation_id,
            )

        keyboard = InlineKeyboardMarkup(
            [
                [InlineKeyboardButton("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –µ—â–µ", callback_data="generate_again")],
                [InlineKeyboardButton("üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="my_generations")],
                [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="back_to_menu")],
            ]
        )
        summary_text = (
            "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤."
            if user_lang == "ru"
            else "‚úÖ <b>Generation completed!</b>\n\nResult is ready."
        )
        balance_line = ""
        if not is_free and not is_admin_user and session.get("balance_charged"):
            updated_balance = await get_user_balance_async(user_id)
            balance_line = (
                f"\n\nüí≥ –ë–∞–ª–∞–Ω—Å: {format_rub_amount(updated_balance)}"
                if user_lang == "ru"
                else f"\n\nüí≥ Balance: {format_rub_amount(updated_balance)}"
            )
        await send_or_edit_message(
            _append_free_counter_text(f"{summary_text}{balance_line}", free_counter_line),
            parse_mode="HTML",
            reply_markup=keyboard,
        )
        if job_id:
            state_before = session.get("job_state")
            session["job_state"] = "finished"
            _update_job_record(job_id, state="finished", finished_ts_ms=_now_ms())
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="finished",
            )
        user_sessions.pop(user_id, None)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GEN_COMPLETE",
            action_path="confirm_generate",
            model_id=model_id,
            stage="GEN_COMPLETE",
            outcome="sent",
            duration_ms=int((time.time() - start_time) * 1000),
        )
        return ConversationHandler.END
    except KIERequestFailed as exc:
        if prompt_hash:
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                task_id=session.get("task_id"),
                job_id=job_id,
                status="failed",
                request_id=request_id,
            )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CONFIRM_GENERATE",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code=exc.error_code or "KIE_REQUEST_FAILED",
        )
        if job_id:
            state_before = session.get("job_state") if "session" in locals() else None
            _update_job_record(job_id, state="failed", failed_ts_ms=_now_ms())
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="failed",
            )
            try:
                from app.storage import get_storage

                await get_storage().update_job_status(
                    job_id,
                    "failed",
                    error_message=exc.user_message or str(exc),
                    error_code=exc.error_code or "KIE_REQUEST_FAILED",
                )
            except Exception as storage_exc:
                logger.warning("Failed to update storage job failure: %s", storage_exc)
        log_request_event(
            request_id=session.get("request_id", request_id),
            user_id=user_id,
            model=model_id,
            prompt_hash=session.get("prompt_hash"),
            task_id=session.get("task_id"),
            job_id=job_id,
            status="request_failed",
            latency_ms=int((time.time() - start_time) * 1000),
            attempt=None,
            error_code=exc.error_code or "KIE_REQUEST_FAILED",
            error_msg=exc.user_message or str(exc),
            correlation_id=correlation_id,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="KIE_SUBMIT_FAILED",
            action_path="confirm_generate",
            model_id=model_id,
            gen_type=session.get("gen_type"),
            stage="KIE_SUBMIT",
            outcome="failed",
            error_code=exc.error_code or "KIE_SUBMIT_FAILED",
            fix_hint=exc.user_message or ERROR_CATALOG.get("KIE_FAIL_STATE"),
            param={"status": exc.status},
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GENERATION_FAILED",
            action_path="confirm_generate",
            model_id=model_id,
            stage="KIE_CREATE",
            outcome="failed",
            error_code=exc.error_code or "KIE_REQUEST_FAILED",
            fix_hint=exc.user_message or ERROR_CATALOG.get("KIE_FAIL_STATE"),
        )
        if _is_kie_model_not_supported(exc.user_message or str(exc)):
            correlation_suffix = _short_correlation_suffix(correlation_id)
            current_sku_id = None
            try:
                current_sku_id = session.get("sku_id")
            except Exception:
                current_sku_id = None
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                action="KIE_MODEL_NOT_SUPPORTED",
                action_path="confirm_generate",
                model_id=model_id,
                sku_id=current_sku_id,
                stage="KIE_CREATE",
                outcome="failed",
                error_code="KIE_MODEL_NOT_SUPPORTED",
                fix_hint="Model name rejected by KIE.",
            )
            if user_lang == "ru":
                message_text = (
                    "‚ö†Ô∏è <b>–ú–æ–¥–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</b>\n\n"
                    "KIE –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —É–∫–∞–∑–∞–Ω–Ω—É—é –º–æ–¥–µ–ª—å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é.\n"
                    f"ID: <code>{correlation_suffix}</code>"
                )
                back_label = "üîÅ –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å"
            else:
                message_text = (
                    "‚ö†Ô∏è <b>Model temporarily unavailable</b>\n\n"
                    "KIE rejected the selected model. Please choose another one.\n"
                    f"ID: <code>{correlation_suffix}</code>"
                )
                back_label = "üîÅ Choose another model"
            retry_keyboard = InlineKeyboardMarkup(
                [
                    [InlineKeyboardButton(back_label, callback_data="show_all_models_list")],
                    [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")],
                ]
            )
            await send_or_edit_message(
                message_text,
                parse_mode="HTML",
                reply_markup=retry_keyboard,
            )
            return ConversationHandler.END
        if exc.status == 422 and user_id in user_sessions:
            properties = session.get("properties", {})
            missing_param = _extract_missing_param(exc.user_message or str(exc), properties)
            if missing_param:
                session["waiting_for"] = missing_param
                session["current_param"] = missing_param
                user_lang = get_user_language(user_id) if user_id else "ru"
                param_label = _humanize_param_name(missing_param, user_lang)
                correlation_suffix = _short_correlation_suffix(correlation_id)
                fix_hint = (
                    f"–£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä ¬´{param_label}¬ª –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                    if user_lang == "ru"
                    else f"Please provide ‚Äú{param_label}‚Äù and try again."
                )
                await send_or_edit_message(
                    (
                        "‚ö†Ô∏è <b>–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞</b>\n\n"
                        f"{fix_hint}\n"
                        f"ID: <code>{correlation_suffix}</code>"
                        if user_lang == "ru"
                        else (
                            "‚ö†Ô∏è <b>Missing required parameter</b>\n\n"
                            f"{fix_hint}\n"
                            f"ID: <code>{correlation_suffix}</code>"
                        )
                    ),
                    parse_mode="HTML",
                )
                await prompt_for_specific_param(update, context, user_id, missing_param, source="kie_validation")
                return INPUTTING_PARAMS
        await send_or_edit_message(
            _build_kie_request_failed_message(exc.status, user_lang, exc.user_message),
            reply_markup=build_back_to_menu_keyboard(user_lang),
        )
        return ConversationHandler.END
    except TimeoutError as exc:
        logger.error("‚ùå Generation timeout: %s", exc, exc_info=True)
        if prompt_hash:
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                task_id=session.get("task_id"),
                job_id=job_id,
                status="timed_out",
                request_id=request_id,
            )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CONFIRM_GENERATE",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code="ERR_KIE_TIMEOUT",
        )
        if job_id:
            state_before = session.get("job_state") if "session" in locals() else None
            _update_job_record(job_id, state="timed_out", timed_out_ts_ms=_now_ms())
            increment_cancel_metric("job_timeout_total")
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="timed_out",
            )
            try:
                from app.storage import get_storage

                await get_storage().update_job_status(
                    job_id,
                    "timeout",
                    error_message="timeout",
                    error_code="ERR_KIE_TIMEOUT",
                )
            except Exception as storage_exc:
                logger.warning("Failed to update storage job timeout: %s", storage_exc)
        log_request_event(
            request_id=session.get("request_id", request_id),
            user_id=user_id,
            model=model_id,
            prompt_hash=session.get("prompt_hash"),
            task_id=session.get("task_id"),
            job_id=job_id,
            status="timeout",
            latency_ms=int((time.time() - start_time) * 1000),
            attempt=None,
            error_code="ERR_KIE_TIMEOUT",
            error_msg=str(exc),
            correlation_id=correlation_id,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GENERATION_FAILED",
            action_path="confirm_generate",
            model_id=model_id,
            stage="KIE_POLL",
            outcome="timeout",
            error_code="ERR_KIE_TIMEOUT",
            fix_hint=ERROR_CATALOG.get("KIE_TIMEOUT"),
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="KIE_POLL",
            action_path="confirm_generate",
            model_id=model_id,
            stage="KIE_POLL",
            outcome="timeout",
            error_code="ERR_KIE_TIMEOUT",
            fix_hint=ERROR_CATALOG.get("KIE_TIMEOUT"),
        )
        trace_error(
            correlation_id or "corr-na-na",
            "ERR_KIE_TIMEOUT",
            ERROR_CATALOG.get("KIE_TIMEOUT", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ timeout/backoff –∏ —Å—Ç–∞—Ç—É—Å KIE."),
            exc,
            action_path="confirm_generate",
            model_id=model_id,
            stage="KIE_POLL",
        )
        timeout_text = (
            "‚è≥ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–Ω—è–ª–∞ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏</b>\n\n"
            "–ú—ã –≤—Å—ë –µ—â—ë —Å—á–∏—Ç–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –ú–æ–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–ø—ã—Ç–∫—É.\n"
            "–ö–æ–¥: <code>ERR_KIE_TIMEOUT</code>"
        )
        timeout_keyboard = InlineKeyboardMarkup(
            [
                [InlineKeyboardButton("üîÅ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data="retry_generate:")],
                [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")],
            ]
        )
        await send_or_edit_message(
            _append_free_counter_text(timeout_text, free_counter_line),
            parse_mode="HTML",
            reply_markup=timeout_keyboard,
        )
        return ConversationHandler.END
    except KIEJobFailed as exc:
        from app.observability.redaction import redact_payload

        logger.error(f"‚ùå Generation failed: {exc}", exc_info=True)
        if prompt_hash:
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                task_id=session.get("task_id"),
                job_id=job_id,
                status="failed",
                request_id=request_id,
            )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CONFIRM_GENERATE",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code=exc.fail_code or "KIE_FAIL_STATE",
        )
        if job_id:
            state_before = session.get("job_state") if "session" in locals() else None
            _update_job_record(job_id, state="failed", failed_ts_ms=_now_ms())
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="failed",
            )
            try:
                from app.storage import get_storage

                await get_storage().update_job_status(
                    job_id,
                    "failed",
                    error_message=exc.fail_msg or str(exc),
                    error_code=exc.fail_code or "KIE_FAIL_STATE",
                )
            except Exception as storage_exc:
                logger.warning("Failed to update storage job failure: %s", storage_exc)
        log_request_event(
            request_id=session.get("request_id", request_id),
            user_id=user_id,
            model=model_id,
            prompt_hash=session.get("prompt_hash"),
            task_id=session.get("task_id"),
            job_id=job_id,
            status="failed",
            latency_ms=int((time.time() - start_time) * 1000),
            attempt=None,
            error_code=exc.fail_code or "KIE_FAIL_STATE",
            error_msg=exc.fail_msg or str(exc),
            correlation_id=correlation_id,
        )
        redacted_record = redact_payload(exc.record_info or {})
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GENERATION_FAILED",
            action_path="confirm_generate",
            model_id=model_id,
            stage="KIE_POLL",
            outcome="failed",
            error_code=exc.fail_code or "KIE_FAIL_STATE",
            fix_hint=ERROR_CATALOG.get("KIE_FAIL_STATE"),
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GEN_ERROR",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code=exc.fail_code or "KIE_FAIL_STATE",
            fix_hint=ERROR_CATALOG.get("KIE_FAIL_STATE"),
            param={
                "fail_code": exc.fail_code,
                "fail_msg": exc.fail_msg,
                "record_info": redacted_record,
            },
        )
        from app.generations.failure_ui import build_kie_fail_ui

        fail_text, retry_keyboard = build_kie_fail_ui(correlation_id or "corr-na-na", model_id)
        await send_or_edit_message(
            _append_free_counter_text(fail_text, free_counter_line),
            parse_mode='HTML',
            reply_markup=retry_keyboard,
        )
        return ConversationHandler.END
    except (KIEResultError, ValueError) as exc:
        error_text = str(exc)
        if prompt_hash:
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                task_id=session.get("task_id"),
                job_id=job_id,
                status="failed",
                request_id=request_id,
            )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CONFIRM_GENERATE",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code=getattr(exc, "error_code", "KIE_RESULT_ERROR"),
        )
        if job_id:
            state_before = session.get("job_state") if "session" in locals() else None
            _update_job_record(job_id, state="failed", failed_ts_ms=_now_ms())
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="failed",
            )
            try:
                from app.storage import get_storage

                await get_storage().update_job_status(
                    job_id,
                    "failed",
                    error_message=error_text,
                    error_code=getattr(exc, "error_code", "KIE_RESULT_ERROR"),
                )
            except Exception as storage_exc:
                logger.warning("Failed to update storage job parse failure: %s", storage_exc)
        log_request_event(
            request_id=session.get("request_id", request_id),
            user_id=user_id,
            model=model_id,
            prompt_hash=session.get("prompt_hash"),
            task_id=session.get("task_id"),
            job_id=job_id,
            status="result_error",
            latency_ms=int((time.time() - start_time) * 1000),
            attempt=None,
            error_code=getattr(exc, "error_code", "KIE_RESULT_ERROR"),
            error_msg=error_text,
            correlation_id=correlation_id,
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GENERATION_FAILED",
            action_path="confirm_generate",
            model_id=model_id,
            stage="KIE_PARSE",
            outcome="failed",
            error_code=getattr(exc, "error_code", "KIE_RESULT_ERROR"),
            fix_hint=getattr(exc, "fix_hint", ERROR_CATALOG.get("KIE_FAIL_STATE")),
        )
        if _is_missing_media_error(error_text) and user_id in user_sessions:
            properties = session.get("properties", {})
            image_param_name = None
            if "image_urls" in properties:
                image_param_name = "image_urls"
            elif "image_input" in properties:
                image_param_name = "image_input"
            if image_param_name:
                session["waiting_for"] = image_param_name
                session["current_param"] = image_param_name
                if image_param_name not in session:
                    session[image_param_name] = []
                await send_or_edit_message(
                    (
                        "üì∑ <b>–ù—É–∂–Ω–∞ —Ä–µ—Ñ-–∫–∞—Ä—Ç–∏–Ω–∫–∞</b>\n\n"
                        "KIE —Å–æ–æ–±—â–∏–ª, —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n"
                        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è."
                        if user_lang == "ru"
                        else (
                            "üì∑ <b>Image required</b>\n\n"
                            "KIE reported a missing image input.\n"
                            "Please upload an image to continue."
                        )
                    )
                )
                return INPUTTING_PARAMS
        await send_or_edit_message(
            (
                "‚ùå <b>–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞</b>\n\n"
                "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                if user_lang == "ru"
                else "‚ùå <b>Request validation failed</b>\n\nPlease check parameters and try again."
            ),
            reply_markup=build_back_to_menu_keyboard(user_lang),
        )
        return ConversationHandler.END
    except asyncio.CancelledError:
        logger.info("Generation cancelled by user_id=%s", user_id)
        if prompt_hash:
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                task_id=session.get("task_id"),
                job_id=job_id,
                status="cancelled",
                request_id=request_id,
            )
        now_ms = _now_ms()
        job_record = _get_job_record(job_id)
        state_before = job_record.get("state") if job_record else None
        if job_id and state_before in ACTIVE_JOB_STATES_ACTIVE:
            _update_job_record(job_id, state="cancelled", cancelled_ts_ms=now_ms)
            session = user_sessions.get(user_id)
            if isinstance(session, dict):
                session["job_state"] = "cancelled"
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="cancelled",
            )
        if (
            job_record
            and job_record.get("cancel_source") == "user"
            and _is_recent_cancel_click(user_id, now_ms)
        ):
            try:
                await send_or_edit_message(
                    "‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É. –í—ã –º–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—É—é.",
                    parse_mode="HTML",
                )
            except Exception:
                # If editing/sending fails, silently continue to exit the flow
                pass
        user_sessions.pop(user_id, None)
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"‚ùå Generation failed: {e}", exc_info=True)
        if prompt_hash:
            await update_dedupe_entry(
                user_id,
                model_id,
                prompt_hash,
                task_id=session.get("task_id"),
                job_id=job_id,
                status="failed",
                request_id=request_id,
            )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="CONFIRM_GENERATE",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code="ERR_GEN_UNKNOWN",
        )
        if job_id:
            state_before = session.get("job_state") if "session" in locals() else None
            _update_job_record(job_id, state="failed", failed_ts_ms=_now_ms())
            _log_job_state_update(
                correlation_id=correlation_id,
                update_id=update.update_id,
                user_id=user_id,
                chat_id=chat_id,
                message_id=query.message.message_id if query and query.message else None,
                callback_query_id=query.id if query else None,
                callback_data=query.data if query else None,
                job_id=job_id,
                state_before=state_before,
                state_after="failed",
            )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GENERATION_FAILED",
            action_path="confirm_generate",
            model_id=model_id,
            stage="GEN_ERROR",
            outcome="failed",
            error_code="ERR_GEN_UNKNOWN",
            fix_hint=ERROR_CATALOG.get("KIE_FAIL_STATE"),
        )
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=chat_id,
            action="GEN_ERROR",
            action_path="confirm_generate",
            model_id=model_id,
            outcome="failed",
            error_code="ERR_GEN_UNKNOWN",
            fix_hint=ERROR_CATALOG.get("KIE_FAIL_STATE"),
        )
        await send_or_edit_message(
            _append_free_counter_text(
                (
                    "‚ùå <b>–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</b>\n\n"
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\n"
                    f"ID: {correlation_id}\n"
                    "–ö–æ–¥: <code>ERR_GEN_UNKNOWN</code>"
                ),
                free_counter_line,
            ),
            parse_mode='HTML'
        )
        return ConversationHandler.END



async def poll_task_status(update: Update, context: ContextTypes.DEFAULT_TYPE, task_id: str, user_id: int):
    """Poll task status until completion."""
    max_attempts = 60  # 5 minutes max
    attempt = 0
    start_time = asyncio.get_event_loop().time()
    last_status_message = None
    last_state = None
    last_progress_update = 0.0
    status_message = update.message if update and hasattr(update, "message") else None

    async def _send_with_log(tg_method: str, **kwargs):
        correlation_id = ensure_correlation_id(update, context)
        log_structured_event(
            correlation_id=correlation_id,
            user_id=user_id,
            chat_id=kwargs.get("chat_id"),
            action="TG_SEND_ATTEMPT",
            action_path="poll_task_status",
            model_id=kwargs.get("model_id"),
            stage="TG_SEND",
            outcome="attempt",
            error_code="TG_SEND_ATTEMPT",
            fix_hint="–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.",
            param={"tg_method": tg_method},
        )
        try:
            result = await getattr(context.bot, tg_method)(**kwargs)
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=kwargs.get("chat_id"),
                action="TG_SEND_OK",
                action_path="poll_task_status",
                model_id=kwargs.get("model_id"),
                stage="TG_SEND",
                outcome="success",
                error_code="TG_SEND_OK",
                fix_hint="–°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ.",
                param={"tg_method": tg_method},
            )
            return result
        except Exception as exc:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=kwargs.get("chat_id"),
                action="TG_SEND_FAIL",
                action_path="poll_task_status",
                model_id=kwargs.get("model_id"),
                stage="TG_SEND",
                outcome="failed",
                error_code="TG_SEND_FAIL",
                fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç–ø—Ä–∞–≤–∫–∏ Telegram.",
                param={"tg_method": tg_method, "error": str(exc)},
            )
            raise
    
    # CRITICAL: Get chat_id from update or use user_id (for private chats, chat_id == user_id)
    chat_id = user_id
    if update and hasattr(update, 'effective_chat') and update.effective_chat:
        chat_id = update.effective_chat.id
    elif update and hasattr(update, 'message') and update.message:
        chat_id = update.message.chat_id
    elif update and hasattr(update, 'callback_query') and update.callback_query and update.callback_query.message:
        chat_id = update.callback_query.message.chat_id
    
    while attempt < max_attempts:
        await asyncio.sleep(5)  # Wait 5 seconds between polls
        attempt += 1
        elapsed = asyncio.get_event_loop().time() - start_time
        if status_message and elapsed > 30 and (elapsed - last_progress_update) >= 20:
            last_progress_update = elapsed
            try:
                await status_message.edit_text(
                    f"‚è≥ –ì–µ–Ω–µ—Ä–∏—Ä—É—é‚Ä¶ {int(elapsed)} —Å–µ–∫",
                    parse_mode='HTML'
                )
            except Exception:
                pass
        
        try:
            gateway = get_kie_gateway()
            status_result = await gateway.get_task_status(task_id)
            
            if not status_result.get('ok'):
                error = status_result.get('error', 'Unknown error')
                user_lang = get_user_language(user_id)
                free_counter_line = ""
                try:
                    free_counter_line = await get_free_counter_line(
                        user_id,
                        user_lang=user_lang,
                        correlation_id=ensure_correlation_id(update, context),
                        action_path="gen_error",
                    )
                except Exception:
                    free_counter_line = ""
                await _send_with_log(
                    "send_message",
                    chat_id=chat_id,
                    text=_append_free_counter_text(
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞:</b>\n\n{error}",
                        free_counter_line,
                    ),
                    parse_mode='HTML',
                    model_id=None,
                )
                # Clean up active generation on error
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        del active_generations[generation_key]
                _clear_user_task_context(user_id, reason="status_error", task_id=task_id, allow_mismatch=True)
                break
            
            state = status_result.get('state')
            if state and state != last_state:
                log_structured_event(
                    correlation_id=ensure_correlation_id(update, context),
                    user_id=user_id,
                    chat_id=chat_id,
                    action="KIE_STATUS",
                    action_path="poll_task_status",
                    model_id=model_id if 'model_id' in locals() else None,
                    param={"from": last_state, "to": state, "task_id": task_id},
                    outcome="transition",
                )
                last_state = state
            
            if state == 'success':
                log_structured_event(
                    correlation_id=ensure_correlation_id(update, context),
                    user_id=user_id,
                    chat_id=chat_id,
                    action="KIE_TASK_DONE",
                    action_path="poll_task_status",
                    model_id=model_id if 'model_id' in locals() else None,
                    outcome="success",
                    error_code="KIE_TASK_DONE_OK",
                    fix_hint="–ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ.",
                    param={"task_id": task_id},
                )
                # Send notification immediately when generation completes
                free_counter_line = ""
                try:
                    free_counter_line = await get_free_counter_line(
                        user_id,
                        user_lang=user_lang,
                        correlation_id=ensure_correlation_id(update, context),
                        action_path="gen_done",
                    )
                except Exception:
                    free_counter_line = ""
                try:
                    await _send_with_log(
                        "send_message",
                        chat_id=chat_id,
                        text=_append_free_counter_text(
                            (
                                "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
                                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                "üéâ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤!</b>\n\n"
                                "‚è≥ <b>–ó–∞–≥—Ä—É–∂–∞—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç...</b>\n\n"
                                "üí° <b>–ß—Ç–æ –¥–∞–ª—å—à–µ:</b>\n"
                                "‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω –Ω–∏–∂–µ\n"
                                "‚Ä¢ –í—ã —Å–º–æ–∂–µ—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–ª–∏ –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –∏–º\n"
                                "‚Ä¢ –ú–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é\n\n"
                                "‚ú® –°–∫–æ—Ä–æ –≤—ã —É–≤–∏–¥–∏—Ç–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç!"
                                if user_lang == 'ru'
                                else (
                                    "‚úÖ <b>Generation Completed!</b>\n\n"
                                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                                    "üéâ <b>Result is ready!</b>\n\n"
                                    "‚è≥ <b>Loading result...</b>\n\n"
                                    "üí° <b>What's next:</b>\n"
                                    "‚Ä¢ Result will be shown below\n"
                                    "‚Ä¢ You can save or share it\n"
                                    "‚Ä¢ You can create a new generation\n\n"
                                    "‚ú® You'll see the created content shortly!"
                                )
                            ),
                            free_counter_line,
                        ),
                        parse_mode='HTML',
                        model_id=model_id,
                    )
                except Exception as e:
                    logger.warning(f"Could not send completion notification: {e}")
                
                # Task completed successfully - prepare pricing (charge after delivery only)
                generation_key = (user_id, task_id)
                saved_session_data = None
                model_id = ''
                params = {}
                sku_id = ''
                session = None

                async with active_generations_lock:
                    if generation_key in active_generations:
                        session = active_generations[generation_key]
                        saved_session_data = {
                            'model_id': session.get('model_id'),
                            'model_info': session.get('model_info'),
                            'params': session.get('params', {}).copy(),
                            'properties': session.get('properties', {}).copy(),
                            'required': session.get('required', []).copy()
                        }
                        model_id = session.get('model_id', '')
                        params = session.get('params', {})
                        sku_id = session.get('sku_id', '')
                        is_admin_user = get_is_admin(user_id)
                        is_free = session.get('is_free_generation', False)
                    else:
                        logger.warning(f"Generation session not found for {generation_key}")
                        is_admin_user = get_is_admin(user_id)
                        is_free = False

                if session is None:
                    session_store = get_session_store(context)
                    session = ensure_session_cached(context, session_store, user_id, update.update_id) or {}

                if is_free:
                    price = 0.0
                else:
                    price = calculate_price_rub(model_id, params, is_admin_user)
                if price is None:
                    logger.error("Missing price for model %s; skipping charge.", model_id)
                    price = 0.0

                dry_run = is_dry_run() or not allow_real_generation()
                
                # Task completed successfully
                result_json = status_result.get('resultJson', '{}')
                last_message = None
                try:
                    result_data = json.loads(result_json)
                    
                    # Determine if this is a video model
                    is_video_model = model_id in ['sora-2-text-to-video', 'sora-watermark-remover', 'kling-2.6/image-to-video', 'kling-2.6/text-to-video', 'kling/v2-5-turbo-text-to-video-pro', 'kling/v2-5-turbo-image-to-video-pro', 'wan/2-5-image-to-video', 'wan/2-5-text-to-video', 'wan/2-2-animate-move', 'wan/2-2-animate-replace', 'hailuo/02-text-to-video-pro', 'hailuo/02-image-to-video-pro', 'hailuo/02-text-to-video-standard', 'hailuo/02-image-to-video-standard', 'topaz/video-upscale', 'kling/v1-avatar-standard', 'kling/ai-avatar-v1-pro', 'infinitalk/from-audio', 'wan/2-2-a14b-speech-to-video-turbo', 'bytedance/v1-pro-fast-image-to-video', 'kling/v2-1-master-image-to-video', 'kling/v2-1-standard', 'kling/v2-1-pro', 'kling/v2-1-master-text-to-video', 'wan/2-2-a14b-text-to-video-turbo', 'wan/2-2-a14b-image-to-video-turbo']
                    
                    # For sora-2-text-to-video, check remove_watermark parameter
                    if model_id == 'sora-2-text-to-video':
                        remove_watermark = params.get('remove_watermark', True)
                        # If remove_watermark is True, use resultUrls (without watermark)
                        # If False, use resultWaterMarkUrls (with watermark)
                        if remove_watermark:
                            result_urls = result_data.get('resultUrls', [])
                        else:
                            result_urls = result_data.get('resultWaterMarkUrls', [])
                            # Fallback to resultUrls if resultWaterMarkUrls is empty
                            if not result_urls:
                                result_urls = result_data.get('resultUrls', [])
                    else:
                        # For other models, use resultUrls
                        result_urls = result_data.get('resultUrls', [])
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∫–µ—à
                    if result_urls and model_id:
                        try:
                            from optimization_results_cache import get_cache_key_for_generation, set_cached_result
                            cache_key = get_cache_key_for_generation(model_id, params)
                            set_cached_result(cache_key, {
                                'ok': True,
                                'result_urls': result_urls.copy(),
                                'model_id': model_id,
                                'params': params.copy()
                            })
                        except ImportError:
                            pass  # –ö–µ—à –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω
                    
                    # Save to history
                    if result_urls and model_id:
                        model_info = saved_session_data.get('model_info', {}) if saved_session_data else {}
                        model_name = model_info.get('name', model_id)
                        save_generation_to_history(
                            user_id=user_id,
                            model_id=model_id,
                            model_name=model_name,
                            params=params.copy(),
                            result_urls=result_urls.copy(),
                            task_id=task_id,
                            price=price,
                            is_free=is_free,
                            correlation_id=ensure_correlation_id(update, context),
                        )
                    
                    # Prepare buttons for last message
                    # Save generation data for "generate_again" button
                    if saved_session_data:
                        if user_id not in saved_generations:
                            saved_generations[user_id] = {}
                        saved_generations[user_id] = saved_session_data.copy()
                    
                    keyboard = [
                        [InlineKeyboardButton("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –µ—â–µ", callback_data="generate_again")],
                        [InlineKeyboardButton("üìö –ú–æ–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="my_generations")],
                        [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é", callback_data="back_to_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    if result_urls:
                        from app.generations.telegram_sender import send_result_file
                        model_info = saved_session_data.get('model_info', {}) if saved_session_data else {}
                        model_name_display = model_name if model_name else model_id
                        request_id = (saved_session_data or {}).get("request_id")
                        prompt_hash = (saved_session_data or {}).get("prompt_hash")
                        pending_payload = {
                            "chat_id": chat_id,
                            "media_type": (model_info.get("output_media_type") if model_info else None) or "document",
                            "urls": result_urls[:5],
                            "text": None,
                            "model_id": model_id,
                            "gen_type": model_info.get('model_mode') if model_info else None,
                            "correlation_id": ensure_correlation_id(update, context),
                            "request_id": request_id,
                            "prompt_hash": prompt_hash,
                            "params": params,
                            "model_label": model_name_display,
                            "task_id": task_id,
                            "job_id": job_id,
                            "sku_id": sku_id,
                            "price": price,
                            "is_free": is_free,
                            "is_admin_user": is_admin_user,
                            "session": session,
                        }
                        async with pending_deliveries_lock:
                            pending_deliveries[(user_id, task_id)] = pending_payload
                        delivered = False
                        try:
                            delivered = bool(
                                await send_result_file(
                                    context.bot,
                                    chat_id,
                                    (model_info.get("output_media_type") if model_info else None) or "document",
                                    result_urls[:5],
                                    None,
                                    model_id=model_id,
                                    gen_type=model_info.get('model_mode') if model_info else None,
                                    correlation_id=ensure_correlation_id(update, context),
                                    request_id=request_id,
                                    prompt_hash=prompt_hash,
                                    params=params,
                                    model_label=model_name_display,
                                    task_id=task_id,
                                    job_id=job_id,
                                )
                            )
                        except Exception as exc:
                            log_structured_event(
                                correlation_id=ensure_correlation_id(update, context),
                                user_id=user_id,
                                chat_id=chat_id,
                                action="DELIVERY_FAIL",
                                action_path="poll_task_status",
                                model_id=model_id,
                                stage="TG_DELIVER",
                                outcome="failed",
                                error_code="TG_DELIVER_EXCEPTION",
                                fix_hint=str(exc),
                                param={"task_id": task_id},
                            )

                        if delivered:
                            async with pending_deliveries_lock:
                                pending_deliveries.pop((user_id, task_id), None)
                            if not dry_run:
                                await _commit_post_delivery_charge(
                                    session=session,
                                    user_id=user_id,
                                    chat_id=chat_id,
                                    task_id=task_id,
                                    sku_id=sku_id,
                                    price=price,
                                    is_free=is_free,
                                    is_admin_user=is_admin_user,
                                    correlation_id=ensure_correlation_id(update, context),
                                    model_id=model_id,
                                )
                            free_counter_line = ""
                            try:
                                free_counter_line = await get_free_counter_line(
                                    user_id,
                                    user_lang=user_lang,
                                    correlation_id=ensure_correlation_id(update, context),
                                    action_path="gen_done",
                                )
                            except Exception:
                                free_counter_line = ""
                            summary_text = (
                                "‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤."
                                if user_lang == 'ru'
                                else "‚úÖ <b>Generation Completed!</b>\n\nResult is ready."
                            )
                            log_request_event(
                                request_id=request_id or "unknown",
                                user_id=user_id,
                                model=model_id,
                                prompt_hash=prompt_hash,
                                task_id=task_id,
                                job_id=(saved_session_data or {}).get("job_id"),
                                status="delivered",
                                latency_ms=None,
                                attempt=None,
                                error_code=None,
                                error_msg=None,
                                correlation_id=correlation_id,
                            )
                            last_message = await _send_with_log(
                                "send_message",
                                chat_id=chat_id,
                                text=_append_free_counter_text(summary_text, free_counter_line),
                                reply_markup=reply_markup,
                                parse_mode='HTML'
                            )
                        else:
                            log_structured_event(
                                correlation_id=ensure_correlation_id(update, context),
                                user_id=user_id,
                                chat_id=chat_id,
                                action="DELIVERY_FAIL",
                                action_path="poll_task_status",
                                model_id=model_id,
                                stage="TG_DELIVER",
                                outcome="failed",
                                error_code="TG_DELIVER_NOT_CONFIRMED",
                                fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç–∞–≤–∫—É –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∫—É.",
                                param={"task_id": task_id},
                            )
                            retry_keyboard = InlineKeyboardMarkup(
                                [
                                    [InlineKeyboardButton("üîÅ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É", callback_data=f"retry_delivery:{task_id}")],
                                    [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_menu")],
                                ]
                            )
                            await _send_with_log(
                                "send_message",
                                chat_id=chat_id,
                                text=(
                                    "‚ö†Ô∏è <b>–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ—Å—Ç–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</b>\n\n"
                                    "–†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤, –Ω–æ Telegram –Ω–µ –ø—Ä–∏–Ω—è–ª –æ—Ç–ø—Ä–∞–≤–∫—É.\n"
                                    "–ù–∞–∂–º–∏—Ç–µ ¬´–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–æ—Å—Ç–∞–≤–∫—É¬ª, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ä–∞–∑."
                                ),
                                parse_mode="HTML",
                                reply_markup=retry_keyboard,
                            )
                            break
                    else:
                        log_structured_event(
                            correlation_id=ensure_correlation_id(update, context),
                            user_id=user_id,
                            chat_id=chat_id,
                            action="DELIVERY_FAIL",
                            action_path="poll_task_status",
                            model_id=model_id,
                            stage="TG_DELIVER",
                            outcome="failed",
                            error_code="EMPTY_RESULT",
                            fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ—Ç–≤–µ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ (resultUrls).",
                            param={"task_id": task_id},
                        )
                        await _send_with_log(
                            "send_message",
                            chat_id=chat_id,
                            text=(
                                "‚ö†Ô∏è <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—É—Å—Ç–æ–π</b>\n\n"
                                "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å."
                            ),
                            parse_mode='HTML'
                        )
                        break
                except json.JSONDecodeError:
                    last_message = await _send_with_log(
                        "send_message",
                        chat_id=chat_id,
                        text=_append_free_counter_text(
                            f"‚úÖ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n–†–µ–∑—É–ª—å—Ç–∞—Ç: {result_json[:500]}",
                            free_counter_line,
                        ),
                        reply_markup=reply_markup,
                        parse_mode='HTML'
                    )
                
                # Clean up active generation
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        del active_generations[generation_key]
                _clear_user_task_context(user_id, reason="terminal_success", task_id=task_id, allow_mismatch=True)
                break
            
            elif state == 'fail':
                # Task failed - auto-refund if charge was made
                fail_msg = status_result.get('failMsg', 'Unknown error')
                fail_code = status_result.get('failCode', '')
                log_structured_event(
                    correlation_id=ensure_correlation_id(update, context),
                    user_id=user_id,
                    chat_id=chat_id,
                    action="KIE_TASK_DONE",
                    action_path="poll_task_status",
                    model_id=model_id if 'model_id' in locals() else None,
                    outcome="failed",
                    error_code=fail_code or "KIE_TASK_FAIL",
                    fix_hint="–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é.",
                    param={"task_id": task_id, "fail_msg": fail_msg},
                )
                
                # CRITICAL: Log full error details for debugging
                logger.error(f"‚ùå Task {task_id} failed: code={fail_code}, msg={fail_msg}")
                logger.error(f"‚ùå Full status_result: {json.dumps(status_result, ensure_ascii=False, indent=2)}")
                
                # AUTO-REFUND: If balance was charged, refund it
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        session = active_generations[generation_key]
                        model_id = session.get('model_id', '')
                        params = session.get('params', {})
                        is_admin_user = get_is_admin(user_id)
                        is_free = session.get('is_free_generation', False)
                        
                        # Check if charge was made (shouldn't be, but check anyway)
                        if not is_free and user_id != ADMIN_ID:
                            price = calculate_price_rub(model_id, params, is_admin_user)
                            # Refund if charge was made (idempotent - safe to call multiple times)
                            try:
                                await add_user_balance_async(user_id, price)
                                logger.info(f"üí∞ AUTO-REFUND: Refunded {price} to user {user_id} for failed task {task_id}")
                            except Exception as refund_error:
                                logger.error(f"‚ùå Failed to refund user {user_id} for failed task {task_id}: {refund_error}")
                        
                        session['status'] = 'failed'
                        session['error'] = fail_msg
                        session['fail_code'] = fail_code
                
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–Ω—è—Ç–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
                try:
                    from error_handler_providers import get_error_handler
                    handler = get_error_handler()
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∏–∑ model_id
                    provider_name = model_id.split('/')[0] if '/' in model_id else "Unknown"
                    
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
                    user_message, error_details = handler.handle_provider_error(
                        provider_name=provider_name,
                        error_message=fail_msg,
                        status_code=None,
                        request_details={
                            "task_id": task_id,
                            "model_id": model_id,
                            "fail_code": fail_code
                        }
                    )
                except ImportError:
                    # Fallback –µ—Å–ª–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                    user_message = (
                        f"‚ùå <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–æ–π</b>\n\n"
                        f"–û—à–∏–±–∫–∞: {fail_msg}\n\n"
                        "–≠—Ç–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Å–µ—Ä–≤–µ—Ä–∞, –º—ã —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ–º –Ω–∞–¥ –µ—ë —Ä–µ—à–µ–Ω–∏–µ–º.\n\n"
                        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                    )
                
                free_counter_line = ""
                try:
                    free_counter_line = await get_free_counter_line(
                        user_id,
                        user_lang=get_user_language(user_id),
                        correlation_id=ensure_correlation_id(update, context),
                        action_path="gen_error",
                    )
                except Exception:
                    free_counter_line = ""
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                await _send_with_log(
                    "send_message",
                    chat_id=chat_id,
                    text=_append_free_counter_text(user_message, free_counter_line),
                    parse_mode='HTML'
                )
                _clear_user_task_context(user_id, reason="terminal_fail", task_id=task_id, allow_mismatch=True)
                break
            
            elif state in ['waiting', 'queuing', 'generating']:
                # Still processing, continue polling
                # Don't send status updates - user can work with other models
                # Result will be sent automatically when ready
                continue
            else:
                # Unknown state
                await _send_with_log(
                    "send_message",
                    chat_id=chat_id,
                    text=f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {state}\n–ü—Ä–æ–¥–æ–ª–∂–∞—é –æ–∂–∏–¥–∞–Ω–∏–µ...",
                    parse_mode='HTML'
                )
                continue
        
        except Exception as e:
            logger.error(f"Error polling task status: {e}", exc_info=True)
            if attempt >= max_attempts:
                # Timeout - auto-refund if charge was made
                generation_key = (user_id, task_id)
                async with active_generations_lock:
                    if generation_key in active_generations:
                        session = active_generations[generation_key]
                        model_id = session.get('model_id', '')
                        params = session.get('params', {})
                        is_admin_user = get_is_admin(user_id)
                        is_free = session.get('is_free_generation', False)
                        
                        # AUTO-REFUND on timeout
                        if not is_free and user_id != ADMIN_ID:
                            price = calculate_price_rub(model_id, params, is_admin_user)
                            try:
                                await add_user_balance_async(user_id, price)
                                logger.info(f"üí∞ AUTO-REFUND: Refunded {price} to user {user_id} for timeout task {task_id}")
                            except Exception as refund_error:
                                logger.error(f"‚ùå Failed to refund user {user_id} for timeout task {task_id}: {refund_error}")
                        
                        del active_generations[generation_key]
                _clear_user_task_context(user_id, reason="terminal_timeout_exception", task_id=task_id, allow_mismatch=True)
                await _send_with_log(
                    "send_message",
                    chat_id=chat_id,
                    text=f"‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.",
                    parse_mode='HTML'
                )
                break
            # For non-fatal errors, continue polling (don't break the loop)
            continue
    
    if attempt >= max_attempts:
        # Timeout - auto-refund if charge was made
        generation_key = (user_id, task_id)
        async with active_generations_lock:
            if generation_key in active_generations:
                session = active_generations[generation_key]
                model_id = session.get('model_id', '')
                params = session.get('params', {})
                is_admin_user = get_is_admin(user_id)
                is_free = session.get('is_free_generation', False)
                
                # AUTO-REFUND on timeout
                if not is_free and user_id != ADMIN_ID:
                    price = calculate_price_rub(model_id, params, is_admin_user)
                    if price is None:
                        logger.error("Missing price for refund on model %s", model_id)
                        price = 0.0
                    try:
                        await add_user_balance_async(user_id, price)
                        logger.info(f"üí∞ AUTO-REFUND: Refunded {price} to user {user_id} for timeout task {task_id}")
                    except Exception as refund_error:
                        logger.error(f"‚ùå Failed to refund user {user_id} for timeout task {task_id}: {refund_error}")
                
                del active_generations[generation_key]
        _clear_user_task_context(user_id, reason="terminal_timeout_final", task_id=task_id, allow_mismatch=True)
        await _send_with_log(
            "send_message",
            chat_id=chat_id,
            text=f"‚è∞ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.",
            parse_mode='HTML'
        )


async def check_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check user balance in rubles. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç helpers –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è."""
    user_id = update.effective_user.id
    user_lang = get_user_language(user_id)

    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º helpers –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–∞–ª–∞–Ω—Å–µ
        balance_info = await get_balance_info(user_id, user_lang)
        balance_text = await format_balance_message(balance_info, user_lang)
        keyboard = get_balance_keyboard(balance_info, user_lang)
        await update.message.reply_text(
            balance_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='HTML'
        )
    except Exception as exc:
        correlation_id = ensure_correlation_id(update, context)
        logger.error(
            "BALANCE_HANDLER_DEGRADED user_id=%s correlation_id=%s error=%s",
            user_id,
            correlation_id,
            exc,
            exc_info=True,
        )
        degraded_text = (
            f"‚ö†Ô∏è –ë–∞–ª–∞–Ω—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –õ–æ–≥: {correlation_id}."
            if user_lang == "ru"
            else f"‚ö†Ô∏è Balance temporarily unavailable. Log: {correlation_id}."
        )
        await update.message.reply_text(
            degraded_text,
            reply_markup=_build_minimal_menu_keyboard(user_lang),
        )


async def _find_job_by_task_id(storage, task_id: str) -> Optional[Dict[str, Any]]:
    job = await storage.get_job(task_id)
    if job:
        return job
    jobs = await storage.list_jobs(limit=500)
    for entry in jobs:
        if task_id in {entry.get("task_id"), entry.get("external_task_id")}:
            return entry
    return None


async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Return generation status by task_id."""
    if not context.args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /status <task_id>")
        return
    task_id = context.args[0].strip()
    from app.storage import get_storage
    from app.integrations.kie_stub import get_kie_client_or_stub
    from app.delivery.reconciler import deliver_job_result, SUCCESS_STATES, FAILED_STATES

    storage = get_storage()
    job = await _find_job_by_task_id(storage, task_id)
    if not job:
        await update.message.reply_text("–ù–µ –Ω–∞—à—ë–ª –∑–∞–¥–∞—á—É —Å —Ç–∞–∫–∏–º task_id.")
        return
    user_id = job.get("user_id")
    if update.effective_user.id != user_id and not is_admin(update.effective_user.id):
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞–¥–∞—á–µ.")
        return

    provider_state = "unknown"
    status_record = {}
    try:
        status_record = await get_kie_client_or_stub().get_task_status(task_id)
        provider_state = (status_record.get("state") or "unknown").lower()
    except Exception:
        provider_state = "unknown"

    delivery_records = await storage.read_json_file("delivery_records.json", default={})
    delivered = False
    delivery_key = f"{user_id}:{task_id}"
    if delivery_key in delivery_records:
        delivered = delivery_records[delivery_key].get("status") == "delivered"

    storage_state = job.get("status") or "unknown"
    response_lines = [
        "üì¶ <b>–°—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏</b>",
        f"Task ID: <code>{task_id}</code>",
        f"Storage: <b>{storage_state}</b>",
        f"Provider: <b>{provider_state}</b>",
        f"Delivery: <b>{'delivered' if delivered else 'pending'}</b>",
    ]

    if provider_state in SUCCESS_STATES and not delivered:
        status_record["taskId"] = task_id
        await deliver_job_result(
            context.bot,
            storage,
            job=job,
            status_record=status_record,
            notify_user=True,
            source="status_command",
        )
        response_lines.append("‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç –≥–æ—Ç–æ–≤, –∑–∞–ø—É—Å–∫–∞—é –ø–æ–≤—Ç–æ—Ä–Ω—É—é –¥–æ—Å—Ç–∞–≤–∫—É.")
    elif provider_state in FAILED_STATES:
        await storage.update_job_status(
            job.get("job_id") or task_id,
            "failed",
            error_message=status_record.get("failMsg"),
            error_code=status_record.get("failCode") or "KIE_FAIL_STATE",
        )
        response_lines.append("‚ùå –ü—Ä–æ–≤–∞–π–¥–µ—Ä —Å–æ–æ–±—â–∏–ª –æ–± –æ—à–∏–±–∫–µ.")

    await update.message.reply_text("\n".join(response_lines), parse_mode="HTML")


async def _request_job_cancel(
    *,
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    job_id: Optional[str],
    user_id: int,
    user_lang: str,
    callback_data: Optional[str],
    query: Optional[CallbackQuery],
    correlation_id: Optional[str],
    state_source: str,
) -> bool:
    now_ms = _now_ms()
    increment_cancel_metric("cancel_received_total")
    job_record = _get_job_record(job_id)
    chat_id = query.message.chat_id if query and query.message else None
    message_id = query.message.message_id if query and query.message else None
    callback_query_id = query.id if query else None

    if not job_id:
        increment_cancel_metric("cancel_without_job_total")
        _log_cancel_update(
            correlation_id=correlation_id,
            update_id=update.update_id,
            user_id=user_id,
            chat_id=chat_id,
            message_id=message_id,
            callback_query_id=callback_query_id,
            callback_data=callback_data,
            job_id=job_id,
            state_before=None,
            state_after="ignored",
            action="CANCEL_NO_JOB",
        )
        return False

    if not job_record or job_record.get("user_id") != user_id:
        increment_cancel_metric("cancel_without_job_total")
        _log_cancel_update(
            correlation_id=correlation_id,
            update_id=update.update_id,
            user_id=user_id,
            chat_id=chat_id,
            message_id=message_id,
            callback_query_id=callback_query_id,
            callback_data=callback_data,
            job_id=job_id,
            state_before=job_record.get("state") if job_record else None,
            state_after="ignored",
            action="CANCEL_JOB_MISMATCH",
        )
        return False

    state_before = job_record.get("state")
    if state_before in ACTIVE_JOB_STATES_TERMINAL or state_before == "cancel_requested":
        increment_cancel_metric("cancel_ignored_total")
        _log_cancel_update(
            correlation_id=correlation_id,
            update_id=update.update_id,
            user_id=user_id,
            chat_id=chat_id,
            message_id=message_id,
            callback_query_id=callback_query_id,
            callback_data=callback_data,
            job_id=job_id,
            state_before=state_before,
            state_after=state_before,
            action="CANCEL_ALREADY_TERMINAL",
        )
        return False

    if not _is_recent_cancel_click(user_id, now_ms):
        increment_cancel_metric("cancel_ignored_total")
        _log_cancel_update(
            correlation_id=correlation_id,
            update_id=update.update_id,
            user_id=user_id,
            chat_id=chat_id,
            message_id=message_id,
            callback_query_id=callback_query_id,
            callback_data=callback_data,
            job_id=job_id,
            state_before=state_before,
            state_after="ignored",
            action="CANCEL_DEBOUNCE_REJECT",
        )
        return False

    increment_cancel_metric("cancel_accepted_total")
    _update_job_record(
        job_id,
        state="cancel_requested",
        cancel_requested_ts_ms=now_ms,
        cancel_source="user",
        cancel_source_channel=state_source,
    )
    session = user_sessions.get(user_id)
    if isinstance(session, dict):
        session["job_state"] = "cancel_requested"
    _log_cancel_update(
        correlation_id=correlation_id,
        update_id=update.update_id,
        user_id=user_id,
        chat_id=chat_id,
        message_id=message_id,
        callback_query_id=callback_query_id,
        callback_data=callback_data,
        job_id=job_id,
        state_before=state_before,
        state_after="cancel_requested",
        action="CANCEL_ACCEPTED",
    )
    await cancel_active_generation(user_id)
    try:
        if query:
            await query.answer(
                "–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é‚Ä¶" if user_lang == "ru" else "Stopping generation‚Ä¶"
            )
    except Exception:
        pass
    return True


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel the current operation."""
    user_id = update.effective_user.id
    user_lang = get_user_language(user_id) if user_id else "ru"
    await _answer_callback_early(
        update.callback_query,
        user_lang=user_lang,
        callback_data=update.callback_query.data if update.callback_query else None,
    )

    session = user_sessions.get(user_id, {})
    job_id = session.get("job_id")
    if job_id:
        now_ms = _now_ms()
        _set_user_ui_action(user_id, "cancel_click", now_ms)
        if isinstance(session, dict):
            session["last_ui_action"] = "cancel_click"
            session["last_ui_ts_ms"] = now_ms
        accepted = await _request_job_cancel(
            update=update,
            context=context,
            job_id=job_id,
            user_id=user_id,
            user_lang=user_lang,
            callback_data="cancel_command",
            query=update.callback_query,
            correlation_id=ensure_correlation_id(update, context),
            state_source="command",
        )
        if accepted:
            _clear_user_task_context(user_id, reason="cancel_accepted", task_id=session.get("task_id"), allow_mismatch=True)
            await ensure_main_menu(update, context, source="cancel_generation", prefer_edit=False)
            return ConversationHandler.END
    
    # Handle callback query (button press)
    if update.callback_query:
        query = update.callback_query
        await query.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")

        try:
            await query.edit_message_text(
                "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."
            )
        except Exception as e:
            logger.error(f"Error editing message on cancel: {e}", exc_info=True)
            try:
                await query.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
            except:
                pass
        _clear_user_task_context(user_id, reason="cancel_callback", task_id=session.get("task_id"), allow_mismatch=True)
        await ensure_main_menu(update, context, source="cancel", prefer_edit=False)
        return ConversationHandler.END
    
    # Handle command
    if update.message:
        await update.message.reply_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        _clear_user_task_context(user_id, reason="cancel_command", task_id=session.get("task_id"), allow_mismatch=True)
        await ensure_main_menu(update, context, source="cancel", prefer_edit=False)
        return ConversationHandler.END


# Keep existing handlers
async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle search queries."""
    query = ' '.join(context.args) if context.args else ''
    
    if not query:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–∞–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /search [–∑–∞–ø—Ä–æ—Å]')
        return
    
    results = storage.search_entries(query)
    
    if results:
        response = f'–ù–∞–π–¥–µ–Ω–æ {len(results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç(–æ–≤) –¥–ª—è "{query}":\n\n'
        for i, result in enumerate(results[:5], 1):
            response += f'{i}. {result["content"][:100]}...\n'
    else:
        response = f'–ü–æ –∑–∞–ø—Ä–æ—Å—É "{query}" –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
    
    await update.message.reply_text(response)


async def ask(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle questions."""
    question = ' '.join(context.args) if context.args else ''
    
    if not question:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /ask [–≤–æ–ø—Ä–æ—Å]')
        return
    
    results = storage.search_entries(question)
    
    if results:
        response = f'–ü–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É "{question}":\n\n'
        for i, result in enumerate(results[:3], 1):
            response += f'{i}. {result["content"]}\n\n'
    else:
        kie_model = os.getenv('KIE_DEFAULT_MODEL') or os.getenv('KIE_MODEL')
        if kie_model:
            try:
                await update.message.reply_text('ü§î –ò—â—É –æ—Ç–≤–µ—Ç...')
                kie_resp = await kie.invoke_model(kie_model, {'text': question})
                if kie_resp.get('ok'):
                    result = kie_resp.get('result')
                    if isinstance(result, dict) and 'output' in result:
                        output = result['output']
                    else:
                        output = result
                    response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—Ç–≤–µ—Ç:\n{output}'
                else:
                    response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—à–∏–±–∫–∞ API: {kie_resp.get("error")}'
            except Exception as e:
                response = f'–í–æ–ø—Ä–æ—Å: {question}\n\n–û—à–∏–±–∫–∞: {e}'
        else:
            response = f'–ü–æ –≤–∞—à–µ–º—É –≤–æ–ø—Ä–æ—Å—É "{question}" –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.'
    
    await update.message.reply_text(response)


async def add_knowledge(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add new knowledge."""
    knowledge = ' '.join(context.args) if context.args else ''
    
    if not knowledge:
        await update.message.reply_text('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–Ω–∞–Ω–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add [–∑–Ω–∞–Ω–∏–µ]')
        return
    
    success = storage.add_entry(knowledge, update.effective_user.id)
    
    if success:
        await update.message.reply_text(f'‚úÖ –ó–Ω–∞–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ: "{knowledge[:50]}..."')
    else:
        await update.message.reply_text('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞–Ω–∏–µ.')


async def pre_checkout_query_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle pre-checkout query for Telegram Stars payments."""
    query = update.pre_checkout_query
    user_id = query.from_user.id
    
    # Verify the payment amount matches what we expect
    # The payload format is: topup_{user_id}_{timestamp}
    payload_parts = query.invoice_payload.split('_')
    
    if len(payload_parts) >= 2 and payload_parts[0] == 'topup':
        # Extract user_id from payload to verify
        payload_user_id = int(payload_parts[1])
        
        if payload_user_id == user_id:
            # Check if user has a pending payment in session
            if user_id in user_sessions and 'topup_amount' in user_sessions[user_id]:
                # Approve the pre-checkout query
                await query.answer(ok=True)
                logger.info(f"Pre-checkout approved for user {user_id}, amount: {query.total_amount} XTR")
            else:
                # Reject if no pending payment
                await query.answer(ok=False, error_message="Payment session expired. Please try again.")
                logger.warning(f"Pre-checkout rejected for user {user_id}: no pending payment")
        else:
            await query.answer(ok=False, error_message="Invalid payment request.")
            logger.warning(f"Pre-checkout rejected for user {user_id}: invalid user_id in payload")
    else:
        await query.answer(ok=False, error_message="Invalid payment payload.")
        logger.warning(f"Pre-checkout rejected for user {user_id}: invalid payload format")


async def successful_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle successful Telegram Stars payment."""
    user_id = update.effective_user.id
    payment = update.message.successful_payment
    
    user_lang = get_user_language(user_id)
    
    # Extract payment info
    payload_parts = payment.invoice_payload.split('_')
    amount_stars = payment.total_amount  # Amount in XTR (Stars)
    
    # Convert stars to rubles using exchange rate 1.6
    # 1 ruble = 1.6 stars, so 1 star = 1/1.6 rubles
    # But we use the amount from session if available (more accurate)
    if user_id in user_sessions and 'topup_amount' in user_sessions[user_id]:
        # Use the amount from session (more accurate - this is the original ruble amount)
        amount_rubles = user_sessions[user_id]['topup_amount']
    else:
        # Fallback: convert stars back to rubles (1 star = 1/1.6 rubles)
        amount_rubles = float(amount_stars) / 1.6
    
    # Add balance to user
    await add_user_balance_async(user_id, amount_rubles)
    
    # Clear payment session
    if user_id in user_sessions:
        del user_sessions[user_id]
    
    # Save payment record
    payment_id = f"stars_{user_id}_{int(time.time())}"
    payment_record = {
        'id': payment_id,
        'user_id': user_id,
        'amount': amount_rubles,
        'currency': 'RUB',
        'payment_method': 'telegram_stars',
        'stars_amount': amount_stars,
        'timestamp': time.time(),
        'status': 'completed',
        'balance_charged': True,
    }

    def updater(payload: dict) -> dict:
        updated = dict(payload or {})
        updated[payment_id] = payment_record
        return updated

    from app.storage.factory import get_storage

    storage_instance = get_storage()
    await storage_instance.update_json_file(os.path.basename(PAYMENTS_FILE), updater)
    logger.info(
        "‚úÖ Saved Stars payment: user_id=%s amount=%.2f payment_id=%s",
        user_id,
        amount_rubles,
        payment_id,
    )
    
    # Send confirmation message
    balance_str = f"{await get_user_balance_async(user_id):.2f}"
    
    if user_lang == 'ru':
        success_text = (
            f'{t("msg_payment_success", lang=user_lang)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_added", lang=user_lang, amount=amount_rubles)}\n'
            f'{t("msg_payment_method", lang=user_lang, stars=amount_stars)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_balance", lang=user_lang, balance=balance_str)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_use_funds", lang=user_lang)}'
        )
    else:
        success_text = (
            f'{t("msg_payment_success", lang=user_lang)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_added", lang=user_lang, amount=amount_rubles)}\n'
            f'{t("msg_payment_method", lang=user_lang, stars=amount_stars)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_balance", lang=user_lang, balance=balance_str)}\n\n'
            f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
            f'{t("msg_payment_use_funds", lang=user_lang)}'
        )
    
    keyboard = [
        [InlineKeyboardButton(t('btn_check_balance', lang=user_lang), callback_data="check_balance")],
        [InlineKeyboardButton(t('btn_start_generation', lang=user_lang), callback_data="show_models")],
        [InlineKeyboardButton(t('btn_back_to_menu', lang=user_lang), callback_data="back_to_menu")]
    ]
    
    await update.message.reply_text(
        success_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML'
    )
    
    logger.info(f"Successful Stars payment for user {user_id}: {amount_rubles} RUB ({amount_stars} stars)")


def initialize_data_files(storage_mode: str) -> None:
    """Initialize all data files if they don't exist (legacy JSON storage only)."""
    if storage_mode == "db":
        logger.info("üóÉÔ∏è DB storage active - skipping local JSON data files init")
        return

    data_files = [
        BALANCES_FILE,
        USER_LANGUAGES_FILE,
        GIFT_CLAIMED_FILE,
        ADMIN_LIMITS_FILE,
        PAYMENTS_FILE,
        BLOCKED_USERS_FILE,
        FREE_GENERATIONS_FILE,
        PROMOCODES_FILE,
        CURRENCY_RATE_FILE,
        REFERRALS_FILE,
        BROADCASTS_FILE,
        GENERATIONS_HISTORY_FILE
    ]
    
    created_count = 0
    for filename in data_files:
        if not os.path.exists(filename):
            try:
                # Ensure directory exists
                dir_path = os.path.dirname(filename)
                if dir_path and not os.path.exists(dir_path):
                    os.makedirs(dir_path, exist_ok=True)
                
                # Create empty JSON file
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump({}, f, ensure_ascii=False, indent=2)
                logger.info(f"‚úÖ Created data file: {filename}")
                created_count += 1
            except Exception as e:
                logger.error(f"‚ùå Failed to create {filename}: {e}", exc_info=True)
        else:
            file_size = os.path.getsize(filename)
            logger.info(f"‚úì Data file exists: {filename} ({file_size} bytes)")
    
    if created_count > 0:
        logger.info(f"‚úÖ Initialized {created_count} new data files")
    else:
        logger.info("‚úÖ All data files already exist")
    
    # Log critical files status
    critical_files = [BALANCES_FILE, GENERATIONS_HISTORY_FILE, PAYMENTS_FILE]
    for critical_file in critical_files:
        if os.path.exists(critical_file):
            file_size = os.path.getsize(critical_file)
            logger.info(f"üîí Critical file: {critical_file} ({file_size} bytes)")
        else:
            logger.warning(f"‚ö†Ô∏è Critical file missing: {critical_file}")
    
    # Also initialize knowledge store
    try:
        storage = KnowledgeStorage()
        storage.ensure_storage_exists()
        logger.info("‚úÖ Knowledge store initialized")
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize knowledge store: {e}")

def acquire_single_instance_lock_or_exit() -> None:
    # ==================== SINGLE INSTANCE LOCK ====================
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –µ–¥–∏–Ω—ã–π –º–æ–¥—É–ª—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è 409 Conflict
    from app.locking.single_instance import (
        acquire_single_instance_lock,
        release_single_instance_lock,
        is_lock_held,
    )
    from app.utils.singleton_lock import get_lock_mode, is_lock_degraded

    logger.info("üîí Acquiring single instance lock...")
    if not acquire_single_instance_lock():
        logger.error("‚ùå‚ùå‚ùå Failed to acquire single instance lock!")
        logger.error("   Another bot instance is already running")
        logger.error("   Exiting gracefully (exit code 0) to prevent restart loop")
        sys.exit(0)

    logger.info("‚úÖ Single instance lock acquired - this is the leader instance")
    lock_mode = get_lock_mode()
    lock_degraded = is_lock_degraded()
    logger.info("üîí [LOCK_STATUS] mode=%s degraded=%s", lock_mode, lock_degraded)
    if lock_degraded:
        logger.warning("‚ö†Ô∏è  DEGRADED LOCK MODE: For multi-instance scaling on Render, set DATABASE_URL + REDIS_URL")
    else:
        logger.info("‚úÖ Distributed lock healthy (postgres advisory or redis)")

    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ lock –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
    import atexit

    def release_lock_on_exit():
        try:
            release_single_instance_lock()
        except Exception as e:
            logger.error(f"Error releasing lock on exit: {e}")

    atexit.register(release_lock_on_exit)


async def create_bot_application(settings: Settings, *, bot_override=None) -> Application:
    """
    –°–æ–∑–¥–∞–µ—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç Telegram Application —Å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ handlers.
    –ù–ï –∑–∞–ø—É—Å–∫–∞–µ—Ç polling/webhook - —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞–µ—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç application.
    
    Args:
        settings: –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ app.config.Settings
        
    Returns:
        Application —Å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ handlers
    """
    # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º Settings –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞
    from app.config import Settings
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø settings (–º–æ–∂–µ—Ç –±—ã—Ç—å Settings –∏–ª–∏ dict)
    if not isinstance(settings, Settings):
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω dict, —Å–æ–∑–¥–∞–µ–º Settings –∏–∑ –Ω–µ–≥–æ
        if isinstance(settings, dict):
            from app.config import get_settings
            settings = get_settings(validate=False)
        else:
            raise TypeError(f"settings must be Settings or dict, got {type(settings)}")
    
    if not settings.telegram_bot_token:
        raise ValueError("telegram_bot_token is required in settings")
    
    ensure_source_of_truth()
    try:
        from app.pricing.coverage_guard import (
            mark_pricing_preflight_degraded,
            refresh_pricing_coverage_guard,
        )

        try:
            disabled_models = await asyncio.wait_for(
                asyncio.to_thread(refresh_pricing_coverage_guard),
                timeout=PRICING_PREFLIGHT_TIMEOUT_SECONDS,
            )
        except asyncio.TimeoutError:
            mark_pricing_preflight_degraded("timeout")
            disabled_models = {}
            logger.warning(
                "PRICING_PREFLIGHT_TIMEOUT timeout_s=%s",
                PRICING_PREFLIGHT_TIMEOUT_SECONDS,
            )
        if disabled_models:
            logger.warning(
                "PRICING_PREFLIGHT_BLOCKED_COUNT=%s models=%s",
                len(disabled_models),
                sorted(disabled_models.keys()),
            )
        else:
            logger.info("PRICING_PREFLIGHT_OK models=all")
    except Exception as exc:
        try:
            mark_pricing_preflight_degraded(str(exc))
        except Exception:
            logger.debug("PRICING_PREFLIGHT degraded marker failed", exc_info=True)
        logger.error("PRICING_PREFLIGHT_FAILED error=%s", exc, exc_info=True)
    _recover_jobs_on_startup()

    # Verify models are loaded correctly (using registry)
    from app.models.registry import get_models_sync, get_model_registry
    from app.models.yaml_registry import get_registry_path
    models_list = get_models_sync()
    registry_info = get_model_registry()
    
    categories = get_categories_from_registry()
    
    # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ registry
    logger.info(
        f"üìä models_registry source={registry_info['used_source']} "
        f"path={get_registry_path()} count={registry_info['count']}"
    )
    yaml_total = registry_info.get('yaml_total_models')
    if yaml_total:
        logger.info(f"üìä YAML total_models={yaml_total}")
        runtime_delta = len(models_list) - yaml_total
        if runtime_delta:
            logger.info(
                "üìä runtime_models_added=%s total_models=%s yaml_total=%s",
                runtime_delta,
                len(models_list),
                yaml_total,
            )
    
    logger.info(f"Creating application with {len(models_list)} models in {len(categories)} categories: {categories}")
    
    # Create the Application —á–µ—Ä–µ–∑ bootstrap (—Å dependency container)
    from app.bootstrap import create_application
    application = await create_application(settings, bot_override=bot_override)
    
    # –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    # NOTE: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ handlers
    global storage, kie, user_sessions
    deps = application.bot_data["deps"]
    storage = deps.get_storage()
    kie = deps.get_kie_client()
    user_sessions = get_session_store(application=application)

    # DB-only storage preflight with counts (users/balances/payments/free_limits)
    if storage is not None:
        try:
            from app.diagnostics.billing_preflight import run_billing_preflight

            preflight_report = await asyncio.wait_for(
                run_billing_preflight(storage, db_pool=None),
                timeout=BILLING_PREFLIGHT_TIMEOUT_SECONDS,
            )
            sections = preflight_report.get("sections", {})
            users_count = sections.get("users", {}).get("meta", {}).get("records")
            balances_count = sections.get("balances", {}).get("meta", {}).get("records")
            payments_count = sections.get("attempts", {}).get("meta", {}).get("total")
            free_limits_count = sections.get("free_limits", {}).get("meta", {}).get("records")
            logger.info(
                "BOOT_STATUS db_storage=active users=%s balances=%s payments=%s free_limits=%s",
                users_count if users_count is not None else "n/a",
                balances_count if balances_count is not None else "n/a",
                payments_count if payments_count is not None else "n/a",
                free_limits_count if free_limits_count is not None else "n/a",
            )
        except asyncio.TimeoutError:
            logger.warning(
                "BOOT_STATUS db_storage=degraded preflight_timeout=true timeout_s=%s",
                BILLING_PREFLIGHT_TIMEOUT_SECONDS,
            )
        except Exception:
            logger.warning("BOOT_STATUS db_storage=unavailable preflight_failed=true", exc_info=True)
    else:
        logger.warning("BOOT_STATUS db_storage=unavailable storage_instance=false")

    # ==================== NO-SILENCE GUARD ====================
    from app.observability.no_silence_guard import get_no_silence_guard
    no_silence_guard = get_no_silence_guard()
    logger.info("‚úÖ NO-SILENCE GUARD: Integrated in button_callback, input_parameters, error_handler")
    
    # –í—ã–∑—ã–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ handlers
    # (—Å–º. _register_all_handlers_internal –Ω–∏–∂–µ –≤ main())
    await _register_all_handlers_internal(application)
    
    logger.info("‚úÖ Application created with all handlers registered")
    return application


async def _register_all_handlers_internal(application: Application):
    """
    –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤—Å–µ—Ö handlers.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏ –≤ create_bot_application, –∏ –≤ main().
    """
    # Inbound update logger/context middleware (must be first)
    application.add_handler(TypeHandler(Update, inbound_update_logger), group=-100)
    application.add_handler(CallbackQueryHandler(user_action_audit_callback, pattern=".*"), group=-100)
    application.add_handler(MessageHandler(filters.ALL, user_action_audit_message), group=-100)
    application.add_handler(TypeHandler(Update, inbound_rate_limit_guard), group=-99)
    # Create conversation handler for generation
    generation_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(confirm_generation, pattern='^confirm_generate$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^show_models$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^show_all_models_list$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^other_models$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^category:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^all_models$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^free_tools$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^claim_gift$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^model:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^modelk:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^start:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^example:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^info:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_set_currency_rate$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^view_payment_screenshots$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^payment_screenshot_nav:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_payments_back$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^pay_sbp:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^pay_card:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
            CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^retry_delivery:')
        ],
        states={
            SELECTING_MODEL: [
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^show_models$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^show_all_models_list$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^other_models$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^category:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^all_models$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^free_tools$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_previous_step$')
            ],
            CONFIRMING_GENERATION: [
                CallbackQueryHandler(confirm_generation, pattern='^confirm_generate$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^retry_generate:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^retry_delivery:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_previous_step$')
            ],
            INPUTTING_PARAMS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.Document.ALL, input_parameters),
                MessageHandler(filters.AUDIO | filters.VOICE, input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^modelk:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^start:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^example:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^info:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_previous_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$')
            ]
        },
        fallbacks=[CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$'),
                   CommandHandler('cancel', cancel)],
        per_message=True,
        per_chat=True,
        per_user=True,
    )
    
    # NOTE: –ü–æ–ª–Ω–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è handlers –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ main() –Ω–∞—á–∏–Ω–∞—è —Å–æ —Å—Ç—Ä–æ–∫–∏ ~25292
    # –ó–¥–µ—Å—å –º—ã —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ handlers, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ main()
    # –î–ª—è –ø–æ–ª–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –ø–æ–ª–Ω—É—é —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∏–∑ main()
    # –ù–æ –¥–ª—è create_bot_application –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–∑–æ–≤–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
    
    # Error handler —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ Application.builder().build()
    # —á–µ—Ä–µ–∑ app.telegram_error_handler.ensure_error_handler_registered
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º generation_handler
    application.add_handler(
        MessageHandler(
            filters.TEXT
            | filters.PHOTO
            | filters.AUDIO
            | filters.VOICE
            | filters.Document.ALL,
            active_session_router,
        ),
        group=-2,
    )
    application.add_handler(generation_handler)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, global_text_router), group=1)
    application.add_handler(MessageHandler(filters.PHOTO, global_photo_router), group=1)
    application.add_handler(
        MessageHandler(
            filters.AUDIO | filters.VOICE | (filters.Document.MimeType("audio/*")),
            global_audio_router,
        ),
        group=1,
    )
    # –ë–∞–∑–æ–≤—ã–µ command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("reset", reset_wizard_command))
    application.add_handler(CommandHandler("reset", reset_wizard_command))
    application.add_handler(CommandHandler("reset", reset_wizard_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("balance", check_balance))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("cancel", cancel))
    application.add_handler(CommandHandler('generate', start_generation))
    application.add_handler(CommandHandler('models', list_models))
    
    # –ë–∞–∑–æ–≤—ã–µ callback handlers
    application.add_handler(CallbackQueryHandler(button_callback, block=True))
    
    # Fallback handler for unknown callbacks (must be last, lowest priority)
    async def unknown_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Fallback handler for unknown callbacks - ensures no silence"""
        query = update.callback_query
        user_id = query.from_user.id if query and query.from_user else None
        user_lang = get_user_language(user_id) if user_id else "ru"
        await _answer_callback_early(
            query,
            user_lang=user_lang,
            callback_data=query.data if query else None,
        )
        if context and getattr(context, "user_data", None) is not None:
            if context.user_data.get("last_callback_handled_update_id") == update.update_id:
                return
        if query and is_known_callback_data(query.data):
            logger.debug(f"Skipping unknown_callback_handler for known callback: {query.data}")
            return
        correlation_id = ensure_correlation_id(update, context)
        chat_id = query.message.chat_id if query and query.message else None
        from app.observability.no_silence_guard import get_no_silence_guard
        guard = get_no_silence_guard()
        guard.set_trace_context(
            update,
            context,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update.update_id,
            message_id=query.message.message_id if query and query.message else None,
            update_type="callback",
            correlation_id=correlation_id,
            action="UNKNOWN_CALLBACK",
            action_path=build_action_path(query.data if query else None),
            stage="UI_ROUTER",
            outcome="unknown_callback",
        )
        try:
            log_structured_event(
                correlation_id=correlation_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update.update_id,
                action="UNKNOWN_CALLBACK",
                action_path=build_action_path(query.data if query else None),
                stage="UI_ROUTER",
                outcome="unknown_callback",
                error_code="UI_UNKNOWN_CALLBACK",
                fix_hint="register_callback_handler_or_validate_callback_data",
            )
        except Exception as structured_log_error:
            logger.warning("STRUCTURED_LOG unknown callback handler failed: %s", structured_log_error, exc_info=True)
        trace_event(
            "info",
            correlation_id,
            event="TRACE_IN",
            stage="UI_ROUTER",
            update_type="callback",
            action="UNKNOWN_CALLBACK",
            action_path=build_action_path(query.data if query else None),
            user_id=user_id,
            chat_id=chat_id,
            callback_data=query.data if query else None,
            outcome="unknown_callback",
            reason="no_handler",
        )
        if query:
            try:
                await query.answer("–ù–µ –ø–æ–Ω—è–ª –Ω–∞–∂–∞—Ç–∏–µ, –æ–±–Ω–æ–≤–∏–ª –º–µ–Ω—é.", show_alert=False)
                from app.observability.no_silence_guard import track_outgoing_action
                track_outgoing_action(update.update_id, action_type="answerCallbackQuery")
            except Exception as e:
                logger.error(f"Error in unknown_callback_handler: {e}", exc_info=True)
                try:
                    if context and query.id:
                        await context.bot.answer_callback_query(
                            query.id,
                            text="–ù–µ –ø–æ–Ω—è–ª –Ω–∞–∂–∞—Ç–∏–µ, –æ–±–Ω–æ–≤–∏–ª –º–µ–Ω—é.",
                            show_alert=False,
                        )
                except Exception:
                    pass
                trace_error(
                    correlation_id,
                    "UI_UNKNOWN_CALLBACK",
                    ERROR_CATALOG["UI_UNKNOWN_CALLBACK"],
                    e,
                    callback_data=query.data if query else None,
                )
        await ensure_main_menu(update, context, source="unknown_callback", prefer_edit=True)
    
    # Add fallback handlers with lowest priority (group=100, added last)
    application.add_handler(CallbackQueryHandler(unknown_callback_handler), group=100)
    application.add_handler(
        MessageHandler(
            (filters.TEXT & ~filters.COMMAND)
            | filters.PHOTO
            | filters.AUDIO
            | filters.VOICE
            | filters.Document.ALL,
            unhandled_update_fallback,
            block=False,
        ),
        group=100,
    )
    
    logger.info("‚úÖ Basic handlers registered (full registration happens in main())")


# Global webhook handler for aiohttp (webhook mode)
_application_for_webhook: Optional[Application] = None
_webhook_app_ready_event = asyncio.Event()
_webhook_init_lock = asyncio.Lock()
_webhook_init_task: Optional[asyncio.Task] = None
_webhook_early_update_log_last_ts: Optional[float] = None
_early_update_buffer: Optional[EarlyUpdateBuffer] = None
_early_update_drain_task: Optional[asyncio.Task] = None
_webhook_setter_task: Optional[asyncio.Task] = None
_webhook_setter_lock = asyncio.Lock()


def _webhook_is_application_initialized(application: Optional[Application]) -> bool:
    if application is None:
        # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
        logger.info("üîç WEBHOOK_APP_CHECK application=None result=false")
        return False
    initialized_attr = getattr(application, "initialized", None)
    if isinstance(initialized_attr, bool):
        result = initialized_attr
    else:
        result = bool(getattr(application, "_initialized", False))
    
    # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
    logger.info("üîç WEBHOOK_APP_CHECK initialized=%s _initialized=%s result=%s", 
                initialized_attr, getattr(application, "_initialized", None), result)
    
    return result


def _should_log_webhook_early_update(now: float, throttle_seconds: float) -> bool:
    global _webhook_early_update_log_last_ts
    if _webhook_early_update_log_last_ts is None or (now - _webhook_early_update_log_last_ts) >= throttle_seconds:
        _webhook_early_update_log_last_ts = now
        return True
    return False


def _get_early_update_buffer() -> EarlyUpdateBuffer:
    global _early_update_buffer
    if _early_update_buffer is not None:
        return _early_update_buffer
    ttl_seconds_raw = float(os.getenv("WEBHOOK_EARLY_UPDATE_TTL_SECONDS", "180"))
    ttl_seconds = max(120.0, min(300.0, ttl_seconds_raw))
    max_size_raw = int(os.getenv("WEBHOOK_EARLY_UPDATE_MAX_SIZE", "500"))
    max_size = max(50, min(5000, max_size_raw))
    _early_update_buffer = EarlyUpdateBuffer(ttl_seconds=ttl_seconds, max_size=max_size)
    return _early_update_buffer


async def _drain_early_update_buffer(
    application: Application,
    *,
    correlation_id: str,
) -> None:
    buffer = _early_update_buffer
    if buffer is None:
        return
    drain_started = time.monotonic()
    items = await buffer.drain()
    total = len(items)
    log_structured_event(
        correlation_id=correlation_id,
        action="EARLY_UPDATE_DRAIN_START",
        action_path="webhook:early_update_drain",
        outcome="start",
        param={"count": total},
    )
    processed = 0
    deduped = 0
    failed = 0
    for item in items:
        update_id = item.update_id
        if update_id and _update_deduper.seen(update_id):
            deduped += 1
            log_structured_event(
                correlation_id=item.correlation_id or correlation_id,
                action="DEDUP_HIT",
                action_path="webhook:update_id",
                outcome="deduped",
                param={"update_id": update_id, "source": "early_update_buffer"},
            )
            continue
        try:
            update = Update.de_json(item.payload, application.bot)
            if not update:
                failed += 1
                continue
            await application.process_update(update)
            processed += 1
        except Exception:
            failed += 1
            logger.exception(
                "EARLY_UPDATE_DRAIN_FAILED correlation_id=%s update_id=%s",
                item.correlation_id or correlation_id,
                update_id,
            )
    duration_ms = int((time.monotonic() - drain_started) * 1000)
    log_structured_event(
        correlation_id=correlation_id,
        action="EARLY_UPDATE_DRAIN_DONE",
        action_path="webhook:early_update_drain",
        outcome="done",
        param={
            "count": total,
            "processed": processed,
            "deduped": deduped,
            "failed": failed,
            "duration_ms": duration_ms,
        },
    )


def _schedule_early_update_drain(application: Application, *, correlation_id: str) -> None:
    global _early_update_drain_task
    if _early_update_drain_task and not _early_update_drain_task.done():
        return
    _early_update_drain_task = _create_background_task(
        _drain_early_update_buffer(application, correlation_id=correlation_id),
        action="early_update_drain",
    )


def _read_int_env(name: str, default: int, *, min_value: int = 1, max_value: int = 10) -> int:
    raw_value = os.getenv(name)
    if raw_value is None:
        return default
    try:
        value = int(raw_value.strip())
    except ValueError:
        logger.warning("Invalid %s value '%s', defaulting to %s", name, raw_value, default)
        return default
    return max(min_value, min(max_value, value))


def _read_float_env(name: str, default: float, *, min_value: float = 0.1, max_value: float = 120.0) -> float:
    raw_value = os.getenv(name)
    if raw_value is None:
        return default
    try:
        value = float(raw_value.strip())
    except ValueError:
        logger.warning("Invalid %s value '%s', defaulting to %s", name, raw_value, default)
        return default
    return max(min_value, min(max_value, value))


_webhook_set_test_random = random.Random(0)


def _resolve_webhook_set_sleep(base: float, jitter_ratio: float) -> float:
    jitter = base * jitter_ratio
    if jitter <= 0:
        return base
    rng = _webhook_set_test_random if is_test_mode() else random
    return base + rng.uniform(0.0, jitter)

def _compute_webhook_set_next_retry(
    *,
    failure_count: int,
    backoff_base: float,
    backoff_cap: float,
    jitter_ratio: float,
    max_fast_retries: int,
    long_sleep_seconds: float,
) -> float:
    if failure_count <= max_fast_retries:
        backoff = min(backoff_cap, backoff_base * (2 ** (failure_count - 1)))
        return _resolve_webhook_set_sleep(backoff, jitter_ratio)
    return _resolve_webhook_set_sleep(long_sleep_seconds, jitter_ratio)


def _is_render_environment() -> bool:
    return bool(
        os.getenv("RENDER")
        or os.getenv("RENDER_SERVICE_NAME")
        or os.getenv("RENDER_EXTERNAL_URL")
    )


def _is_production_env() -> bool:
    env_name = os.getenv("ENV", "").strip().lower()
    return env_name in {"prod", "production"}


def _resolve_webhook_url_from_env() -> str:
    try:
        from app.bot_mode import get_webhook_url_from_env
    except Exception:
        return (os.getenv("WEBHOOK_URL") or "").strip()
    return get_webhook_url_from_env()


def _current_telegram_request_timeout_seconds() -> float:
    return _read_float_env(
        "TELEGRAM_REQUEST_TIMEOUT_SECONDS",
        TELEGRAM_REQUEST_TIMEOUT_SECONDS,
        min_value=0.2,
        max_value=30.0,
    )


def _current_webhook_process_timeout_seconds() -> float:
    return _read_float_env(
        "WEBHOOK_PROCESS_TIMEOUT_SECONDS",
        WEBHOOK_PROCESS_TIMEOUT_SECONDS,
        min_value=0.2,
        max_value=60.0,
    )


def _resolve_telegram_request_timeout(cycle_timeout_s: float) -> float:
    return max(0.2, min(_current_telegram_request_timeout_seconds(), cycle_timeout_s))


def _auto_set_webhook_enabled() -> bool:
    raw_value = os.getenv("AUTO_SET_WEBHOOK")
    if raw_value is not None:
        return raw_value.strip().lower() in {"1", "true", "yes", "on"}
    bot_mode = os.getenv("BOT_MODE", "").strip().lower()
    webhook_url = _resolve_webhook_url_from_env()
    if bot_mode == "webhook" and webhook_url:
        return True
    render_flag = _is_render_environment() or os.getenv("ON_RENDER", "").strip().lower() in {"1", "true", "yes", "on"}
    if bot_mode == "webhook" and render_flag:
        return True
    if _is_render_environment() or _is_production_env():
        return False
    return True


def _require_webhook_registered() -> bool:
    raw_value = os.getenv("REQUIRE_WEBHOOK_REGISTERED")
    if raw_value is not None:
        return raw_value.strip().lower() in {"1", "true", "yes", "on"}
    return os.getenv("BOT_MODE", "").strip().lower() == "webhook"


def _build_webhook_how_to_fix(expected_url: str) -> str:
    return (
        "HOW_TO_FIX curl -sS https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/setWebhook "
        f"-d url={expected_url} -d drop_pending_updates=true"
    )


async def _fetch_webhook_info(bot, *, timeout_s: float) -> Optional[object]:
    try:
        return await bot.get_webhook_info(connect_timeout=timeout_s, read_timeout=timeout_s)
    except Exception:
        return None


async def _log_webhook_info(
    bot,
    expected_url: str,
    *,
    label: str,
    failure_level: int = logging.WARNING,
) -> Optional[str]:
    webhook_info = await _fetch_webhook_info(
        bot,
        timeout_s=_current_telegram_request_timeout_seconds(),
    )
    if webhook_info is None:
        logger.log(failure_level, "WEBHOOK_INFO_MISSING label=%s expected_url=%s", label, expected_url)
        return None
    current_url = getattr(webhook_info, "url", "") or ""
    pending_count = getattr(webhook_info, "pending_update_count", None)
    last_error_date = getattr(webhook_info, "last_error_date", None)
    last_error_message = getattr(webhook_info, "last_error_message", None)
    logger.info(
        "WEBHOOK_INFO label=%s expected_url=%s current_url=%s pending_update_count=%s last_error_date=%s last_error_message=%s",
        label,
        expected_url,
        current_url,
        pending_count,
        last_error_date,
        last_error_message,
    )
    return current_url


async def _fail_fast_if_webhook_missing(bot, expected_url: str) -> None:
    current_url = await _log_webhook_info(bot, expected_url, label="preflight")
    if current_url is None:
        logger.error(_build_webhook_how_to_fix(expected_url))
        raise SystemExit(1)
    if current_url != expected_url:
        logger.error("WEBHOOK_URL_MISMATCH expected_url=%s current_url=%s", expected_url, current_url)
        logger.error(_build_webhook_how_to_fix(expected_url))
        raise SystemExit(1)


async def _run_webhook_setter_cycle(
    webhook_url: str,
    *,
    attempt_cycle: int,
    cycle_timeout_s: float,
) -> Dict[str, Any]:
    from app.bot_mode import get_webhook_set_last_result

    started = time.monotonic()
    log_structured_event(
        action="WEBHOOK_SETTER_START",
        action_path="webhook:setter",
        stage="WEBHOOK",
        outcome="start",
        param={"attempt": attempt_cycle, "timeout_s": cycle_timeout_s},
    )
    logger.info(
        "WEBHOOK_SETTER_START cycle=%s timeout_s=%s",
        attempt_cycle,
        cycle_timeout_s,
    )
    try:
        from telegram import Bot
        from telegram.request import HTTPXRequest
        from app.bot_mode import ensure_webhook_mode

        request_timeout = _resolve_telegram_request_timeout(cycle_timeout_s)
        request = HTTPXRequest(
            connect_timeout=request_timeout,
            read_timeout=request_timeout,
            write_timeout=request_timeout,
            pool_timeout=request_timeout,
        )

        async with Bot(token=BOT_TOKEN, request=request) as temp_bot:
            webhook_task = asyncio.create_task(
                ensure_webhook_mode(
                    temp_bot,
                    webhook_url,
                    cycle_timeout_s=cycle_timeout_s,
                )
            )
            done, pending = await asyncio.wait({webhook_task}, timeout=cycle_timeout_s)
            if pending:
                for task in pending:
                    task.cancel()
                    task.add_done_callback(
                        lambda t: _suppress_task_exceptions(t, action="webhook_setter_timeout")
                    )
                duration_ms = int((time.monotonic() - started) * 1000)
                return {
                    "ok": False,
                    "outcome": "timeout",
                    "error_type": "Timeout",
                    "error": "webhook_setter_deadline",
                    "duration_ms": duration_ms,
                }
            ok = list(done)[0].result()
    except asyncio.TimeoutError as exc:
        duration_ms = int((time.monotonic() - started) * 1000)
        return {
            "ok": False,
            "outcome": "timeout",
            "error_type": "Timeout",
            "error": str(exc) or "webhook_setter_deadline",
            "duration_ms": duration_ms,
        }
    except Conflict as exc:
        handle_conflict_gracefully(exc, "webhook")
        return {"ok": False, "outcome": "conflict", "error_type": "Conflict", "error": str(exc), "duration_ms": 0}
    except Exception as exc:
        duration_ms = int((time.monotonic() - started) * 1000)
        return {
            "ok": False,
            "outcome": "failed",
            "error_type": type(exc).__name__ or "Exception",
            "error": str(exc),
            "duration_ms": duration_ms,
        }

    duration_ms = int((time.monotonic() - started) * 1000)
    result = get_webhook_set_last_result()
    outcome = result.get("reason") or "unknown"
    error_type = result.get("error_type") or "UnknownError"
    error = result.get("error") or outcome
    return {
        "ok": ok,
        "outcome": outcome,
        "error_type": error_type,
        "error": error,
        "duration_ms": duration_ms,
    }


async def _run_webhook_setter_loop(webhook_url: str) -> None:
    if not _auto_set_webhook_enabled():
        logger.info("SKIPPED_AUTO_SET reason=auto_set_webhook_disabled")
        return

    max_fast_retries = _read_int_env("WEBHOOK_SET_MAX_FAST_RETRIES", 0, min_value=0, max_value=12)
    backoff_base = _read_float_env("WEBHOOK_SET_BACKOFF_BASE_SECONDS", 0.5, min_value=0.1, max_value=10.0)
    backoff_cap = _read_float_env("WEBHOOK_SET_BACKOFF_CAP_SECONDS", 5.0, min_value=0.5, max_value=30.0)
    retry_jitter_ratio = _read_float_env(
        "WEBHOOK_SET_RETRY_JITTER_RATIO",
        0.2,
        min_value=0.0,
        max_value=1.0,
    )
    long_sleep_seconds = _read_float_env(
        "WEBHOOK_SET_LONG_SLEEP_SECONDS",
        900.0,
        min_value=60.0,
        max_value=1800.0,
    )
    cycle_timeout_s = _read_float_env(
        "WEBHOOK_SET_CYCLE_TIMEOUT_SECONDS",
        2.8,
        min_value=1.0,
        max_value=5.0,
    )
    attempt_cycle = 0
    failure_count = 0

    while True:
        attempt_cycle += 1
        async with _webhook_setter_lock:
            result = await _run_webhook_setter_cycle(
                webhook_url,
                attempt_cycle=attempt_cycle,
                cycle_timeout_s=cycle_timeout_s,
            )

        if result.get("ok"):
            outcome = result.get("outcome")
            if outcome == "already_set":
                logger.info(
                    "WEBHOOK_SETTER_ALREADY_SET cycle=%s duration_ms=%s timeout_s=%s",
                    attempt_cycle,
                    result.get("duration_ms"),
                    cycle_timeout_s,
                )
                return
            logger.info(
                "WEBHOOK_SETTER_OK cycle=%s duration_ms=%s timeout_s=%s",
                attempt_cycle,
                result.get("duration_ms"),
                cycle_timeout_s,
            )
            return

        failure_count += 1
        next_retry_s = _compute_webhook_set_next_retry(
            failure_count=failure_count,
            backoff_base=backoff_base,
            backoff_cap=backoff_cap,
            jitter_ratio=retry_jitter_ratio,
            max_fast_retries=max_fast_retries,
            long_sleep_seconds=long_sleep_seconds,
        )
        error_type = result.get("error_type") or "UnknownError"
        error = result.get("error") or error_type
        logger.warning(
            "WEBHOOK_SETTER_FAIL cycle=%s error_type=%s error=%s duration_ms=%s timeout_s=%s next_retry_s=%s",
            attempt_cycle,
            error_type,
            error,
            result.get("duration_ms"),
            cycle_timeout_s,
            next_retry_s,
        )
        await asyncio.sleep(next_retry_s)


async def _run_webhook_info_probe(webhook_url: str, *, label: str) -> None:
    try:
        from telegram import Bot
        from telegram.request import HTTPXRequest

        request_timeout = _resolve_telegram_request_timeout(_current_telegram_request_timeout_seconds())
        request = HTTPXRequest(
            connect_timeout=request_timeout,
            read_timeout=request_timeout,
            write_timeout=request_timeout,
            pool_timeout=request_timeout,
        )
        warn_after = _read_int_env("WEBHOOK_INFO_WARN_AFTER", 3, min_value=1, max_value=10)
        max_attempts = _read_int_env("WEBHOOK_INFO_MAX_ATTEMPTS", 5, min_value=1, max_value=20)
        backoff_base = _read_float_env("WEBHOOK_INFO_BACKOFF_BASE_SECONDS", 0.4, min_value=0.1, max_value=5.0)
        backoff_cap = _read_float_env("WEBHOOK_INFO_BACKOFF_CAP_SECONDS", 3.0, min_value=0.5, max_value=10.0)
        async with Bot(token=BOT_TOKEN, request=request) as temp_bot:
            for attempt in range(1, max_attempts + 1):
                failure_level = logging.INFO if attempt <= warn_after else logging.WARNING
                current_url = await _log_webhook_info(
                    temp_bot,
                    webhook_url,
                    label=label,
                    failure_level=failure_level,
                )
                if current_url is not None:
                    return
                if attempt < max_attempts:
                    backoff_s = min(backoff_cap, backoff_base * (2 ** (attempt - 1)))
                    await asyncio.sleep(backoff_s)
    except Exception as exc:
        logger.info("WEBHOOK_INFO_PROBE_FAILED label=%s error=%s", label, exc)


def _schedule_webhook_setter(webhook_url: str) -> None:
    global _webhook_setter_task
    try:
        from app.locking.single_instance import is_lock_held
    except Exception:
        is_lock_held = None

    if is_lock_held is not None and not is_lock_held():
        logger.info("SKIPPED_AUTO_SET reason=not_leader_instance")
        _create_background_task(
            _run_webhook_info_probe(webhook_url, label="follower"),
            action="webhook_info_probe",
        )
        return
    if _webhook_setter_task and not _webhook_setter_task.done():
        return
    _webhook_setter_task = _create_background_task(
        _run_webhook_setter_loop(webhook_url),
        action="webhook_setter",
    )


async def _register_webhook_application(application: Application) -> None:
    global _application_for_webhook
    # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
    logger.info("üîç WEBHOOK_REGISTER_START app_is_none=%s", _application_for_webhook is None)
    
    async with _webhook_init_lock:
        if _application_for_webhook is None:
            _application_for_webhook = application
            # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
            logger.info("üîç WEBHOOK_REGISTER_DONE app_registered=true")
        else:
            # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
            logger.info("üîç WEBHOOK_REGISTER_SKIP app_already_registered=true")


async def create_webhook_handler():
    """Create aiohttp webhook handler for Telegram updates."""
    from aiohttp import web
    import uuid
    import math

    max_payload_bytes = int(os.getenv("WEBHOOK_MAX_PAYLOAD_BYTES", "1048576"))
    ip_rate_limit_per_sec = float(os.getenv("WEBHOOK_IP_RATE_LIMIT_PER_SEC", "4"))
    ip_rate_limit_burst = float(os.getenv("WEBHOOK_IP_RATE_LIMIT_BURST", "12"))
    request_dedup_ttl_seconds = float(os.getenv("WEBHOOK_REQUEST_DEDUP_TTL_SECONDS", "30"))
    process_timeout_seconds = _current_webhook_process_timeout_seconds()
    concurrency_limit = int(os.getenv("WEBHOOK_CONCURRENCY_LIMIT", "24"))
    concurrency_timeout_seconds = float(os.getenv("WEBHOOK_CONCURRENCY_TIMEOUT_SECONDS", "1.5"))
    ack_max_ms = int(os.getenv("WEBHOOK_ACK_MAX_MS", "200"))
    early_update_retry_after = int(os.getenv("WEBHOOK_EARLY_UPDATE_RETRY_AFTER", "2"))
    early_update_log_throttle_seconds = float(os.getenv("WEBHOOK_EARLY_UPDATE_LOG_THROTTLE_SECONDS", "30"))
    handler_stall_seconds = float(os.getenv("WEBHOOK_HANDLER_STALL_SECONDS", "6.0"))

    ip_rate_limiter = (
        PerKeyRateLimiter(ip_rate_limit_per_sec, ip_rate_limit_burst)
        if ip_rate_limit_per_sec > 0 and ip_rate_limit_burst > 0
        else None
    )
    request_deduper = TTLCache(request_dedup_ttl_seconds)
    webhook_semaphore = asyncio.Semaphore(concurrency_limit) if concurrency_limit > 0 else None
    early_update_buffer = _get_early_update_buffer()
    process_in_background_raw = os.getenv("WEBHOOK_PROCESS_IN_BACKGROUND")
    if process_in_background_raw is None:
        process_in_background = not is_test_mode()
    else:
        process_in_background = process_in_background_raw.strip().lower() in {"1", "true", "yes", "on"}
    early_ack_raw = os.getenv("WEBHOOK_EARLY_ACK")
    if early_ack_raw is None:
        early_ack_enabled = not is_test_mode()
    else:
        early_ack_enabled = early_ack_raw.strip().lower() in {"1", "true", "yes", "on"}
    ack_in_background = True

    def _resolve_update_type(update: Update) -> str:
        if update.callback_query:
            return "callback"
        if update.message:
            return "message"
        if update.edited_message:
            return "edited_message"
        if update.inline_query:
            return "inline_query"
        return "unknown"

    async def _watchdog_handler_stall(
        task: asyncio.Task,
        *,
        correlation_id: str,
        update_id: Optional[int],
        deadline_s: float,
    ) -> None:
        await asyncio.sleep(deadline_s)
        if task.done():
            return
        where = None
        try:
            frames = task.get_stack(limit=3)
            if frames:
                frame = frames[-1]
                where = f"{frame.f_code.co_filename}:{frame.f_lineno}:{frame.f_code.co_name}"
        except Exception:
            where = None
        log_critical_event(
            correlation_id=correlation_id,
            update_id=update_id,
            stage="HANDLER",
            latency_ms=None,
            retry_after=None,
            timeout_s=None,
            attempt=None,
            error_code="HANDLER_STALL",
            error_id="HANDLER_STALL",
            exception_class=None,
            where=where,
            fix_hint="Check slow handler dependencies/locks; move heavy work off hot path.",
            retryable=True,
            upstream=None,
            deadline_s=deadline_s,
            elapsed_ms=deadline_s * 1000,
        )

    async def _process_update_async(
        update: Update,
        *,
        correlation_id: str,
        client_ip: str,
        semaphore_acquired: bool,
        route: str,
        request_id: Optional[str],
    ) -> None:
        process_started = time.monotonic()
        update_id = getattr(update, "update_id", None)
        user_id = update.effective_user.id if update.effective_user else None
        chat_id = update.effective_chat.id if update.effective_chat else None
        increment_update_metric("webhook_process_start")
        log_structured_event(
            correlation_id=correlation_id,
            request_id=request_id,
            user_id=user_id,
            chat_id=chat_id,
            update_id=update_id,
            action="WEBHOOK_PROCESS_START",
            action_path="webhook:process_update",
            stage="WEBHOOK",
            outcome="start",
            update_type=_resolve_update_type(update),
            route=route,
        )
        process_task = asyncio.create_task(_application_for_webhook.process_update(update))
        watchdog_task = asyncio.create_task(
            _watchdog_handler_stall(
                process_task,
                correlation_id=correlation_id,
                update_id=update_id,
                deadline_s=handler_stall_seconds,
            )
        )
        release_in_finally = True

        def _release_after_task(done_task: asyncio.Task) -> None:
            if webhook_semaphore is not None and semaphore_acquired:
                webhook_semaphore.release()
            try:
                done_task.result()
                log_structured_event(
                    correlation_id=correlation_id,
                    request_id=request_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update_id,
                    action="WEBHOOK_PROCESS_LATE_DONE",
                    action_path="webhook:process_update",
                    stage="WEBHOOK",
                    outcome="ok",
                    param={"duration_ms": int((time.monotonic() - process_started) * 1000)},
                    update_type=_resolve_update_type(update),
                    route=route,
                )
            except Exception as exc:
                log_structured_event(
                    correlation_id=correlation_id,
                    request_id=request_id,
                    user_id=user_id,
                    chat_id=chat_id,
                    update_id=update_id,
                    action="WEBHOOK_PROCESS_LATE_DONE",
                    action_path="webhook:process_update",
                    stage="WEBHOOK",
                    outcome="failed",
                    error_id="WEBHOOK_PROCESS_FAILED",
                    param={"error": str(exc)[:200]},
                    update_type=_resolve_update_type(update),
                    route=route,
                )

        outcome = "ok"
        try:
            await asyncio.shield(process_task)
            duration_ms = int((time.monotonic() - process_started) * 1000)
            increment_update_metric("webhook_process_done")
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="WEBHOOK_PROCESS_DONE",
                action_path="webhook:process_update",
                stage="WEBHOOK",
                outcome="ok",
                duration_ms=duration_ms,
                handler_total_ms=duration_ms,
                update_type=_resolve_update_type(update),
                route=route,
            )
            logger.debug(f"[WEBHOOK] {correlation_id} update_processed")
        except Exception as exc:
            outcome = "failed"
            increment_update_metric("webhook_process_done")
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="WEBHOOK_PROCESS_DONE",
                action_path="webhook:process_update",
                stage="WEBHOOK",
                outcome="failed",
                error_id="WEBHOOK_PROCESS_FAILED",
                param={"error": str(exc)[:200]},
                update_type=_resolve_update_type(update),
                route=route,
            )
            logger.error(f"[WEBHOOK] {correlation_id} process_error={exc}", exc_info=True)
        finally:
            handler_total_ms = int((time.monotonic() - process_started) * 1000)
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                user_id=user_id,
                chat_id=chat_id,
                update_id=update_id,
                action="HANDLER_DONE",
                action_path="webhook:handler",
                stage="HANDLER",
                outcome=outcome,
                handler_total_ms=handler_total_ms,
                update_type=_resolve_update_type(update),
                route=route,
            )
            if not watchdog_task.done():
                watchdog_task.cancel()
            if release_in_finally and webhook_semaphore is not None and semaphore_acquired:
                webhook_semaphore.release()

    async def _process_update_with_semaphore(
        update: Update,
        *,
        correlation_id: str,
        client_ip: str,
        route: str,
        request_id: Optional[str],
    ) -> None:
        semaphore_acquired = False
        if webhook_semaphore is not None:
            try:
                await asyncio.wait_for(webhook_semaphore.acquire(), timeout=concurrency_timeout_seconds)
                semaphore_acquired = True
            except asyncio.TimeoutError:
                retry_after = max(1, int(math.ceil(concurrency_timeout_seconds)))
                log_structured_event(
                    correlation_id=correlation_id,
                    request_id=request_id,
                    action="WEBHOOK_BACKPRESSURE",
                    action_path="webhook:concurrency_limit",
                    outcome="throttled",
                    error_id="WEBHOOK_CONCURRENCY_LIMIT",
                    abuse_id="concurrency_limit",
                    param={"client_ip": client_ip, "retry_after": retry_after},
                    route=route,
                )
                return
        await _process_update_async(
            update,
            correlation_id=correlation_id,
            client_ip=client_ip,
            semaphore_acquired=semaphore_acquired,
            route=route,
            request_id=request_id,
        )

    async def webhook_handler(request: web.Request) -> web.StreamResponse:
        """Handle incoming Telegram webhook updates."""
        handler_start = time.monotonic()
        correlation_id = "unknown"
        update_id: Optional[int] = None
        request_id = None
        ack_deadline_ms = ack_max_ms
        try:
            correlation_id = (
                request.headers.get("X-Request-ID")
                or request.headers.get("X-Correlation-ID")
                or request.headers.get("X-Trace-ID")
                or str(uuid.uuid4())[:8]
            )
            request_id = request.headers.get("X-Request-ID") or request.headers.get("X-Correlation-ID")
            logger.debug(f"[WEBHOOK] {correlation_id} handler_invoked")
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                action="ACK_SCHEDULED",
                action_path="webhook:ack",
                stage="WEBHOOK",
                outcome="scheduled",
                ack_ms=0,
                route=request.path,
                param={"ack_deadline_ms": ack_deadline_ms},
            )

            forwarded_for = request.headers.get("X-Forwarded-For", "")
            client_ip = (
                forwarded_for.split(",", 1)[0].strip()
                if forwarded_for
                else request.headers.get("X-Real-IP") or request.remote or "unknown"
            )

            # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –î–õ–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
            logger.info("üîç WEBHOOK_READY_CHECK app_ready=%s app_is_none=%s", 
                        _webhook_app_ready_event.is_set(), _application_for_webhook is None)

            if not _webhook_app_ready_event.is_set() or not _webhook_is_application_initialized(_application_for_webhook):
                update_id = None
                payload = None
                try:
                    payload = await request.json()
                    if isinstance(payload, dict):
                        update_id = payload.get("update_id")
                except Exception:
                    update_id = None
                if update_id is not None and isinstance(payload, dict):
                    try:
                        update_id_int = int(update_id)
                    except (TypeError, ValueError):
                        update_id_int = None
                    if update_id_int is not None:
                        buffered, buffer_size = await early_update_buffer.add(
                            update_id_int,
                            payload,
                            correlation_id=correlation_id,
                        )
                    else:
                        buffered = False
                        buffer_size = 0
                    outcome = "buffered" if buffered else "deduped"
                    log_structured_event(
                        correlation_id=correlation_id,
                        request_id=request_id,
                        action="EARLY_UPDATE_BUFFERED",
                        action_path="webhook:early_update",
                        outcome=outcome,
                        param={
                            "update_id": update_id_int if update_id_int is not None else update_id,
                            "buffer_size": buffer_size,
                            "ready": False,
                        },
                        route=request.path,
                    )
                    if update_id_int is not None and not buffered:
                        log_structured_event(
                            correlation_id=correlation_id,
                            request_id=request_id,
                            action="DEDUP_HIT",
                            action_path="webhook:update_id",
                            outcome="deduped",
                            param={"update_id": update_id, "source": "early_update_buffer"},
                            route=request.path,
                        )
                if _should_log_webhook_early_update(time.monotonic(), early_update_log_throttle_seconds):
                    logger.info(
                        "action=WEBHOOK_EARLY_UPDATE correlation_id=%s update_id=%s ready=false "
                        "outcome=buffered retry_after=%s",
                        correlation_id,
                        update_id,
                        early_update_retry_after,
                    )
                return web.Response(
                    status=200,
                    text="ok",
                    headers={"Retry-After": str(early_update_retry_after)},
                )

            content_length = request.content_length
            if content_length is not None and content_length > max_payload_bytes:
                log_structured_event(
                    correlation_id=correlation_id,
                    request_id=request_id,
                    action="WEBHOOK_ABUSE",
                    action_path="webhook:payload_too_large",
                    outcome="rejected",
                    error_id="WEBHOOK_PAYLOAD_TOO_LARGE",
                    abuse_id="payload_oversize",
                    param={"client_ip": client_ip, "content_length": content_length},
                    route=request.path,
                )
                return web.Response(status=413, text="Payload too large")

            if ip_rate_limiter is not None:
                allowed, retry_after = ip_rate_limiter.check(client_ip)
                if not allowed:
                    retry_after_seconds = max(1, int(math.ceil(retry_after)))
                    log_structured_event(
                        correlation_id=correlation_id,
                        request_id=request_id,
                        action="WEBHOOK_ABUSE",
                        action_path="webhook:rate_limit_ip",
                        outcome="throttled",
                        error_id="WEBHOOK_RATE_LIMIT",
                        abuse_id="rate_limit_ip",
                        param={"client_ip": client_ip, "retry_after": retry_after_seconds},
                        route=request.path,
                    )
                    return web.Response(
                        status=429,
                        text="Too many requests",
                        headers={"Retry-After": str(retry_after_seconds)},
                    )

            if request_id and request_deduper.seen(request_id):
                log_structured_event(
                    correlation_id=correlation_id,
                    request_id=request_id,
                    action="WEBHOOK_DEDUP",
                    action_path="webhook:request_id",
                    outcome="deduped",
                    abuse_id="duplicate_request_id",
                    param={"client_ip": client_ip},
                    route=request.path,
                )
                return web.Response(status=200, text="ok")

            try:
                data = await request.json()
            except Exception as exc:
                logger.warning(f"[WEBHOOK] {correlation_id} parse_error={exc}")
                return web.Response(status=400, text="Invalid JSON")

            # Process update
            try:
                update = Update.de_json(data, _application_for_webhook.bot)
                if update:
                    update_id = getattr(update, "update_id", None)
                    user_id = update.effective_user.id if update.effective_user else None
                    chat_id = update.effective_chat.id if update.effective_chat else None
                    if update_id is not None and _update_deduper.seen(update_id):
                        log_structured_event(
                            correlation_id=correlation_id,
                            request_id=request_id,
                            action="DEDUP_HIT",
                            action_path="webhook:update_id",
                            outcome="deduped",
                            param={"update_id": update_id, "source": "webhook_handler"},
                            route=request.path,
                        )
                        increment_update_metric("webhook_update_in")
                        log_structured_event(
                            correlation_id=correlation_id,
                            request_id=request_id,
                            user_id=user_id,
                            chat_id=chat_id,
                            update_id=update_id,
                            action="WEBHOOK_UPDATE_IN",
                            action_path="webhook:update",
                            stage="WEBHOOK",
                            outcome="deduped",
                            update_type=_resolve_update_type(update),
                            route=request.path,
                        )
                        return web.Response(status=200, text="ok")
                    increment_update_metric("webhook_update_in")
                    log_structured_event(
                        correlation_id=correlation_id,
                        request_id=request_id,
                        user_id=user_id,
                        chat_id=chat_id,
                        update_id=update_id,
                        action="WEBHOOK_UPDATE_IN",
                        action_path="webhook:update",
                        stage="WEBHOOK",
                        outcome="received",
                        update_type=_resolve_update_type(update),
                        route=request.path,
                    )
                    logger.debug(f"[WEBHOOK] {correlation_id} update_received user={update.effective_user.id if update.effective_user else 'unknown'}")
                    log_structured_event(
                        correlation_id=correlation_id,
                        request_id=request_id,
                        user_id=user_id,
                        chat_id=chat_id,
                        update_id=update_id,
                        action="HANDLER_START",
                        action_path="webhook:handler",
                        stage="HANDLER",
                        outcome="start",
                        update_type=_resolve_update_type(update),
                        route=request.path,
                    )
                    if ack_in_background:
                        _create_background_task(
                            _process_update_with_semaphore(
                                update,
                                correlation_id=correlation_id,
                                client_ip=client_ip,
                                route=request.path,
                                request_id=request_id,
                            ),
                            action="webhook_update",
                        )
                    else:
                        await _process_update_with_semaphore(
                            update,
                            correlation_id=correlation_id,
                            client_ip=client_ip,
                            route=request.path,
                            request_id=request_id,
                        )
                    response = web.Response(status=200, text="ok")
                    return response
                else:
                    logger.warning(f"[WEBHOOK] {correlation_id} update_parse_failed")
                    return web.Response(status=400, text="Invalid update")
            except Exception as exc:
                logger.error(f"[WEBHOOK] {correlation_id} process_error={exc}", exc_info=True)
                log_critical_event(
                    correlation_id=correlation_id,
                    update_id=update_id,
                    stage="WEBHOOK",
                    latency_ms=None,
                    retry_after=None,
                    timeout_s=process_timeout_seconds,
                    attempt=None,
                    error_code="WEBHOOK_PROCESS_ERROR",
                    error_id="WEBHOOK_PROCESS_ERROR",
                    exception_class=type(exc).__name__,
                    where="webhook_handler.process_update",
                    fix_hint="Check handler error and upstream dependencies.",
                    retryable=False,
                    upstream="telegram",
                    elapsed_ms=(time.monotonic() - handler_start) * 1000,
                )
                return web.Response(status=500, text="Processing error")
        except Exception as exc:
            logger.error(f"[WEBHOOK] handler_exception={exc}", exc_info=True)
            log_critical_event(
                correlation_id=correlation_id,
                update_id=update_id,
                stage="WEBHOOK",
                latency_ms=None,
                retry_after=None,
                timeout_s=process_timeout_seconds,
                attempt=None,
                error_code="WEBHOOK_HANDLER_EXCEPTION",
                error_id="WEBHOOK_HANDLER_EXCEPTION",
                exception_class=type(exc).__name__,
                where="webhook_handler",
                fix_hint="Inspect webhook handler error and payload parsing.",
                retryable=False,
                upstream="telegram",
                elapsed_ms=(time.monotonic() - handler_start) * 1000,
            )
            return web.Response(status=500, text="Internal error")
        finally:
            duration_ms = int((time.monotonic() - handler_start) * 1000)
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                update_id=update_id,
                action="WEBHOOK_ACK",
                action_path="webhook:handler",
                stage="WEBHOOK",
                outcome="ok",
                ack_ms=duration_ms,
                handler_total_ms=duration_ms,
                route=request.path if "request" in locals() else None,
            )
            try:
                loop = asyncio.get_running_loop()
                event_loop_lag_ms = max(0.0, (time.monotonic() - loop.time()) * 1000)
            except RuntimeError:
                event_loop_lag_ms = None
            log_structured_event(
                correlation_id=correlation_id,
                request_id=request_id,
                update_id=update_id,
                action="WEBHOOK_TIMING_PROFILE",
                action_path="webhook:timing",
                stage="WEBHOOK",
                outcome="ok",
                ack_ms=duration_ms,
                handler_total_ms=duration_ms,
                event_loop_lag_ms=event_loop_lag_ms,
                route=request.path if "request" in locals() else None,
            )
            if duration_ms > ack_max_ms:
                logger.warning("WEBHOOK_ACK_SLOW correlation_id=%s duration_ms=%s", correlation_id, duration_ms)
    
    return webhook_handler


async def _ensure_webhook_initialized(
    application: Application,
    webhook_url: str,
) -> None:
    global _webhook_init_task
    async with _webhook_init_lock:
        if _webhook_init_task is None:
            _webhook_init_task = asyncio.create_task(
                _run_webhook_initialization(application, webhook_url)
            )
    await _webhook_init_task


async def _run_webhook_initialization(
    application: Application,
    webhook_url: str,
) -> None:
    init_started = time.monotonic()
    await application.initialize()
    logger.info("‚úÖ Application initialized for webhook mode")
    start_delivery_reconciler(application.bot)
    start_dedupe_reconciler(application.bot)

    # üöë –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ HTTP —Å–µ—Ä–≤–µ—Ä —Å /webhook –ø–æ–¥–Ω—è—Ç –¥–∞–∂–µ –±–µ–∑ entrypoints/run_bot
    try:
        from app.utils.healthcheck import get_health_status, start_health_server

        port_str = os.getenv("PORT", "10000").strip()
        try:
            port = int(port_str)
        except ValueError:
            port = 10000
        if not get_health_status().get("health_server_running"):
            webhook_handler = await create_webhook_handler()
            started = await start_health_server(port=port, webhook_handler=webhook_handler, self_check=True)
            logger.info("[WEBHOOK] health_server_started=%s port=%s", started, port)
    except Exception as health_exc:
        logger.warning("[WEBHOOK] health_server_start_failed: %s", health_exc, exc_info=True)

    init_ms = int((time.monotonic() - init_started) * 1000)
    _webhook_app_ready_event.set()
    logger.info("action=WEBHOOK_APP_READY ready=true init_ms=%s", init_ms)
    _schedule_early_update_drain(application, correlation_id="BOOT")
    _create_background_task(
        _run_webhook_info_probe(webhook_url, label="startup"),
        action="webhook_info_probe",
    )
    if not _auto_set_webhook_enabled() and _require_webhook_registered():
        await _fail_fast_if_webhook_missing(application.bot, webhook_url)
    _schedule_webhook_setter(webhook_url)


async def main():
    """Start the bot."""
    global storage, kie
    
    # ==================== –ù–ê–ß–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê ====================
    logger.info("=" * 60)
    logger.info("üöÄ Starting KIE Telegram Bot")
    logger.info("=" * 60)
    logger.info(f"üì¶ Python version: {sys.version}")
    logger.info(f"üìÅ Working directory: {os.getcwd()}")
    logger.info(f"üÜî Process ID: {os.getpid()}")
    logger.info(f"üåç Platform: {platform.system()} {platform.release()}")

    # ==================== HEALTHCHECK SINGLETON ====================
    if os.getenv("ENABLE_HEALTH_SERVER", "1") == "1":
        bot_mode_env = os.getenv("BOT_MODE", "").strip().lower()
        if bot_mode_env not in {"webhook"}:
            try:
                from app.utils.healthcheck import start_health_server

                port_str = os.getenv("PORT", "10000").strip()
                try:
                    port = int(port_str)
                except ValueError:
                    port = 10000
                started = await start_health_server(port=port, webhook_handler=None, self_check=True)
                logger.info("[BOOT] health_server_started=%s port=%s", started, port)
            except Exception as exc:
                logger.warning("[BOOT] health_server_start_failed: %s", exc, exc_info=True)
        else:
            logger.info("[BOOT] health_server_skip reason=webhook_mode")

    # ==================== PRICING SCHEMA AUDIT ====================
    try:
        from app.pricing.ssot_catalog import validate_pricing_schema_consistency

        pricing_issues = validate_pricing_schema_consistency()
        if pricing_issues:
            audit_mode = os.getenv("PRICING_AUDIT_MODE", "0").strip().lower() in {"1", "true", "yes"}
            logger.warning("PRICING_SCHEMA_ISSUES issues=%s", pricing_issues)
            if audit_mode:
                raise RuntimeError(f"PRICING_AUDIT_MODE: schema issues detected: {pricing_issues}")
    except Exception as exc:
        logger.error("PRICING_SCHEMA_AUDIT_FAILED error=%s", exc, exc_info=True)
        if os.getenv("PRICING_AUDIT_MODE", "0").strip().lower() in {"1", "true", "yes"}:
            raise

    # ==================== PR-2: –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø ENV –í–ê–õ–ò–î–ê–¶–ò–Ø ====================
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ü–ï–†–ï–î –ª—é–±–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
    validation_errors = []
    
    storage_mode_raw = os.getenv("STORAGE_MODE", "").strip().lower()
    storage_mode_effective = "db"
    telegram_bot_token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
    kie_api_key = os.getenv("KIE_API_KEY", "").strip()
    database_url = os.getenv("DATABASE_URL", "").strip()
    redis_url = os.getenv("REDIS_URL", "").strip()

    if not telegram_bot_token:
        validation_errors.append("TELEGRAM_BOT_TOKEN is required")

    if not database_url:
        validation_errors.append("DATABASE_URL is required for DB storage")

    logger.info(f"üîë TELEGRAM_BOT_TOKEN: {'‚úÖ Set' if telegram_bot_token else '‚ùå NOT SET'}")
    logger.info(f"üîë KIE_API_KEY: {'‚úÖ Set' if kie_api_key else '‚ö†Ô∏è NOT SET (degraded mode)'}")
    if storage_mode_raw and storage_mode_raw not in {"db", "postgres"}:
        logger.warning("‚ö†Ô∏è STORAGE_MODE=%s ignored (db-only runtime)", storage_mode_raw)
    logger.info("üóÑÔ∏è STORAGE_MODE: %s (effective=%s)", storage_mode_raw or "db", storage_mode_effective)
    logger.info(f"üóÉÔ∏è DATABASE_URL: {'‚úÖ Set' if database_url else '‚ùå NOT SET'}")
    logger.info(f"üîó REDIS_URL: {'‚úÖ Set' if redis_url else '‚ùå NOT SET'}")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∂–∏–º–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    redis_url = os.getenv("REDIS_URL", "").strip()
    if redis_url:
        logger.info(f"üîí LOCK_MODE=redis (multi-instance safe)")
        logger.info(f"üîó REDIS_URL: {'‚úÖ Set (multi-instance scaling enabled)' if redis_url else '‚ùå NOT SET'}")
    else:
        logger.info(f"üîí LOCK_MODE=file (single-instance only)")
        logger.warning("‚ö†Ô∏è REDIS_URL not set - using file-based locks (not suitable for multi-instance)")
    
    # FAIL-FAST: –µ—Å–ª–∏ –µ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ - –≤—ã—Ö–æ–¥–∏–º —Å—Ä–∞–∑—É
    if validation_errors:
        logger.error("=" * 60)
        logger.error("‚ùå‚ùå‚ùå CRITICAL ENV VALIDATION FAILED")
        logger.error("=" * 60)
        for error in validation_errors:
            logger.error(f"  ‚ùå {error}")
        logger.error("=" * 60)
        logger.error("üîß Fix these in Render Dashboard ‚Üí Environment Variables")
        logger.error("üîß Then redeploy the service")
        logger.error("=" * 60)
        sys.exit(1)

    logger.info(
        "BOOT_STATUS storage_mode=%s db_enabled=%s redis_enabled=%s lock_mode_target=%s",
        storage_mode_effective,
        str(bool(database_url)).lower(),
        str(bool(redis_url)).lower(),
        "redis" if redis_url else "file",
    )
    
    # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö, –Ω–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
    if not kie_api_key:
        logger.warning("‚ö†Ô∏è KIE_API_KEY not set - KIE AI features will NOT work")
        logger.warning("   Bot will start but generation features will fail")
    
    logger.info("‚úÖ ENV validation passed - all critical variables present")
    logger.info("=" * 60)

    from app.config import get_settings
    settings = get_settings(validate=True)
    logger.info(
        "BOOT_TIMEOUTS telegram_request_timeout_s=%s webhook_process_timeout_s=%s",
        settings.telegram_request_timeout_seconds,
        settings.webhook_process_timeout_seconds,
    )
    
    # CRITICAL: Ensure storage is reachable before anything else
    logger.info("üîí Ensuring storage persistence...")
    storage_instance = None
    try:
        from app.storage.factory import get_storage

        storage_instance = get_storage()
        if hasattr(storage_instance, "ping") and asyncio.iscoroutinefunction(storage_instance.ping):
            storage_ok = await storage_instance.ping()
        else:
            storage_ok = storage_instance.test_connection()
        if storage_ok:
            logger.info("‚úÖ Storage backend ready")
        else:
            logger.warning("‚ö†Ô∏è Storage backend test did not pass")
    except Exception as e:
        logger.error(f"‚ùå CRITICAL: Storage health check failed: {e}")
        logger.error("‚ùå Persistence may be unavailable!")

    # Initialize all data files first (legacy JSON fallback)
    logger.info("üîß Initializing data files...")
    initialize_data_files(storage_mode_effective)

    # ==================== SINGLE INSTANCE LOCK ====================
    acquire_single_instance_lock_or_exit()

    # ==================== SINGLE INSTANCE LOCK ====================
    # Lock is acquired during startup; verify it is held.
    from app.locking.single_instance import is_lock_held
    if not is_lock_held():
        logger.error("‚ùå‚ùå‚ùå CRITICAL: Single instance lock is not held!")
        logger.error("   Lock acquisition should have happened during initialization")
        logger.error("   Exiting to prevent 409 Conflict...")
        sys.exit(1)
    
    logger.info("‚úÖ Single instance lock verified - proceeding with bot initialization")
    
    # Final verification of critical files (legacy JSON fallback)
    if storage_mode_effective != "db":
        logger.info("üîí Verifying critical data files...")
        critical_files = [BALANCES_FILE, GENERATIONS_HISTORY_FILE, PAYMENTS_FILE, GIFT_CLAIMED_FILE]
        all_critical_ok = True
        for critical_file in critical_files:
            if os.path.exists(critical_file):
                file_size = os.path.getsize(critical_file)
                if file_size > 0:
                    logger.info(f"‚úÖ Critical file OK: {critical_file} ({file_size} bytes)")
                else:
                    logger.warning(f"‚ö†Ô∏è Critical file is empty: {critical_file}")
                    all_critical_ok = False
            else:
                logger.warning(f"‚ö†Ô∏è Critical file missing: {critical_file}")
                all_critical_ok = False
        if all_critical_ok:
            logger.info("‚úÖ All critical data files verified and ready (legacy JSON storage)")
        else:
            logger.warning("‚ö†Ô∏è Some critical files need attention, but bot will continue")
    
    # NOTE: Health check server –¥–ª—è Render
    # –ï—Å–ª–∏ –Ω—É–∂–µ–Ω health check endpoint, —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –∫–æ–¥ –Ω–∏–∂–µ
    # –í–ê–ñ–ù–û: –≠—Ç–æ Python –ø—Ä–æ–µ–∫—Ç, –ù–ï Node.js! –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ index.js!
    #
    # import threading
    # from http.server import HTTPServer, BaseHTTPRequestHandler
    # 
    # class HealthCheckHandler(BaseHTTPRequestHandler):
    #     def do_GET(self):
    #         if self.path == '/health' or self.path == '/':
    #             self.send_response(200)
    #             self.send_header('Content-type', 'application/json')
    #             self.end_headers()
    #             self.wfile.write(b'{"status":"ok","service":"telegram-bot"}')
    #         else:
    #             self.send_response(404)
    #             self.end_headers()
    #     
    #     def log_message(self, format, *args):
    #         pass  # Suppress HTTP server logs
    # 
    # def start_health_server():
    #     port = int(os.getenv('PORT', 10000))
    #     try:
    #         server = HTTPServer(('0.0.0.0', port), HealthCheckHandler)
    #         logger.info(f"‚úÖ Health check server started on port {port}")
    #         server.serve_forever()
    #     except Exception as e:
    #         logger.error(f"‚ùå Failed to start health server: {e}")
    #         import traceback
    #         traceback.print_exc()
    # 
    # health_thread = threading.Thread(target=start_health_server, daemon=True)
    # health_thread.start()
    # logger.info("üöÄ Health check server thread started")
    # time.sleep(2)
    
    logger.info("‚úÖ Bot initialization complete (Python only, no Node.js needed)")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ bootstrap (dependency container)
    # –ù–ï –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º storage/kie –∫–∞–∫ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º dependency container
    from app.config import get_settings
    
    settings = get_settings()
    
    if not settings.telegram_bot_token:
        logger.error("No TELEGRAM_BOT_TOKEN found in environment variables!")
        return
    logger.info("‚úÖ STORAGE_MODE=DB (postgres storage active)")
    
    ensure_source_of_truth()

    # Verify models are loaded correctly (using registry)
    from app.models.registry import get_models_sync, get_model_registry
    from app.models.yaml_registry import get_registry_path
    models_list = get_models_sync()
    registry_info = get_model_registry()
    
    categories = get_categories_from_registry()
    sora_models = [m for m in models_list if m.get('id') == 'sora-watermark-remover']
    
    # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ registry (source, count)
    logger.info(
        f"üìä models_registry source={registry_info['used_source']} "
        f"path={get_registry_path()} count={registry_info['count']}"
    )
    yaml_total = registry_info.get('yaml_total_models')
    if yaml_total:
        logger.info(f"üìä YAML total_models={yaml_total}")
        runtime_delta = len(models_list) - yaml_total
        if runtime_delta:
            logger.info(
                "üìä runtime_models_added=%s total_models=%s yaml_total=%s",
                runtime_delta,
                len(models_list),
                yaml_total,
            )
    
    logger.info(f"Bot starting with {len(models_list)} models in {len(categories)} categories: {categories}")
    if sora_models:
        logger.info(f"[OK] Sora model loaded: {sora_models[0].get('name', 'unknown')} ({sora_models[0].get('category', 'unknown')})")
    else:
        logger.warning(f"[WARN] Sora model NOT found! Available models: {[m.get('id') for m in models_list[:10]]}")
    
    # Create the Application —á–µ—Ä–µ–∑ bootstrap (—Å dependency container)
    from app.bootstrap import create_application
    application = await create_application(settings)
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º application –≥–ª–æ–±–∞–ª—å–Ω–æ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ run_webhook_sync
    globals()['application'] = application
    
    # –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    # NOTE: —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ –ø–æ–ª–Ω–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ handlers
    global storage, kie
    deps = application.bot_data["deps"]
    storage = deps.get_storage()
    kie = deps.get_kie_client()

    # DB-only storage preflight with counts (users/balances/payments/free_limits)
    if storage is not None:
        try:
            from app.diagnostics.billing_preflight import run_billing_preflight

            preflight_report = await asyncio.wait_for(
                run_billing_preflight(storage, db_pool=None),
                timeout=BILLING_PREFLIGHT_TIMEOUT_SECONDS,
            )
            sections = preflight_report.get("sections", {})
            users_count = sections.get("users", {}).get("meta", {}).get("records")
            balances_count = sections.get("balances", {}).get("meta", {}).get("records")
            payments_count = sections.get("attempts", {}).get("meta", {}).get("total")
            free_limits_count = sections.get("free_limits", {}).get("meta", {}).get("records")
            logger.info(
                "BOOT_STATUS db_storage=active users=%s balances=%s payments=%s free_limits=%s",
                users_count if users_count is not None else "n/a",
                balances_count if balances_count is not None else "n/a",
                payments_count if payments_count is not None else "n/a",
                free_limits_count if free_limits_count is not None else "n/a",
            )
        except asyncio.TimeoutError:
            logger.warning(
                "BOOT_STATUS db_storage=degraded preflight_timeout=true timeout_s=%s",
                BILLING_PREFLIGHT_TIMEOUT_SECONDS,
            )
        except Exception:
            logger.warning("BOOT_STATUS db_storage=unavailable preflight_failed=true", exc_info=True)
    else:
        logger.warning("BOOT_STATUS db_storage=unavailable storage_instance=false")
    
    # ==================== BOOT WARMUPS (BACKGROUND + WATCHDOG) ====================
    logger.info("üî• Scheduling boot warmups in background (watchdog)...")
    start_boot_warmups(correlation_id="BOOT")
    # ==================== END BOOT WARMUPS ====================
    
    # ==================== NO-SILENCE GUARD (–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ò–ù–í–ê–†–ò–ê–ù–¢) ====================
    # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç –Ω–∞ –∫–∞–∂–¥—ã–π –≤—Ö–æ–¥—è—â–∏–π update
    # NO-SILENCE GUARD —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —á–µ—Ä–µ–∑:
    # 1. app/observability/no_silence_guard.py - middleware –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è outgoing actions
    # 2. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ button_callback - –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç query.answer() –∏ –≤—Å–µ send/edit
    # 3. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ input_parameters - –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç reply_text –∏ –≤—Å–µ send/edit
    # 4. –£–ª—É—á—à–µ–Ω–Ω—ã–π error_handler - –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç fallback –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
    # 5. –ì–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç–≤–µ—Ç–∞ –≤ button_callback (–≤—Å–µ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç query.answer())
    # 6. –ì–∞—Ä–∞–Ω—Ç–∏—è –æ—Ç–≤–µ—Ç–∞ –≤ input_parameters (–æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...")
    from app.observability.no_silence_guard import get_no_silence_guard
    no_silence_guard = get_no_silence_guard()
    logger.info("‚úÖ NO-SILENCE GUARD: Integrated in button_callback, input_parameters, error_handler")
    # ==================== END NO-SILENCE GUARD ====================
    
    # Create conversation handler for generation
    # Note: # D) per_message=True removed to avoid PTBUserWarning
    # So we handle commands separately and use only callbacks for conversation
    generation_handler = ConversationHandler(
        entry_points=[
            # Only CallbackQueryHandler for # D) per_message=True removed to avoid PTBUserWarning
        CallbackQueryHandler(button_callback, block=True, pattern='^show_models$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^show_all_models_list$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^category:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^all_models$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^free_tools$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^claim_gift$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^model:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^modelk:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^start:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^example:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^info:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_set_currency_rate$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^view_payment_screenshots$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^payment_screenshot_nav:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_payments_back$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^pay_sbp:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^pay_card:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
            CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
            CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$')
        ],
        states={
            SELECTING_MODEL: [
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^show_models$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^show_all_models_list$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^category:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^all_models$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^free_tools$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_previous_step$')
            ],
            CONFIRMING_GENERATION: [
                CallbackQueryHandler(confirm_generation, pattern='^confirm_generate$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^retry_generate:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^retry_delivery:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^modelk:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^start:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^example:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^info:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_previous_step$')
            ],
            INPUTTING_PARAMS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.AUDIO | filters.VOICE | (filters.Document.MimeType("audio/*")), input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^set_param:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^add_image$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^skip_image$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^image_done$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^add_audio$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^skip_audio$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^modelk:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^start:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^example:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^info:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$')
            ],
            SELECTING_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^pay_stars:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^pay_sbp:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^pay_card:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^claim_gift$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$')
            ],
            WAITING_PAYMENT_SCREENSHOT: [
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$')
            ],
            ADMIN_TEST_OCR: [
                MessageHandler(filters.PHOTO, input_parameters),
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'),
                CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_view_generations$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_nav:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_gen_view:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_search$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_add$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_promocodes$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_create_broadcast$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_broadcast_stats$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_test_ocr$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_mode$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_back_to_admin$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^select_model:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$')
            ],
            WAITING_BROADCAST_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                MessageHandler(filters.PHOTO, input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'),
            ],
            WAITING_CURRENCY_RATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_parameters),
                CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^reset_step$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^admin_settings$'),
                CallbackQueryHandler(button_callback, block=True, pattern='^cancel(:.*)?$')
            ]
        },
        fallbacks=[
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_info:'),
            CallbackQueryHandler(button_callback, block=True, pattern='^admin_topup_user:'),
            CallbackQueryHandler(cancel, pattern='^cancel(:.*)?$'),
            CommandHandler('cancel', cancel)
        ],
        per_message=True,
        per_chat=True,
        per_user=True,
    )

    # Inbound update logger/context middleware (must be first)
    application.add_handler(TypeHandler(Update, inbound_update_logger), group=-100)
    application.add_handler(CallbackQueryHandler(user_action_audit_callback, pattern=".*"), group=-100)
    application.add_handler(MessageHandler(filters.ALL, user_action_audit_message), group=-100)
    
    # ==================== PHASE 1: GLOBAL INPUT ROUTERS (BEFORE ConversationHandler) ====================
    # These routers catch TEXT/PHOTO/AUDIO OUTSIDE conversation and route to input_parameters if waiting_for exists
    # This ensures NO SILENCE even if ConversationHandler doesn't catch the message
    
    # ==================== END PHASE 1: GLOBAL INPUT ROUTERS ====================
    
    # Add command handlers separately (not in conversation, as # D) per_message=True removed to avoid PTBUserWarning
    application.add_handler(CommandHandler('generate', start_generation))
    application.add_handler(CommandHandler('models', list_models))
    application.add_handler(CommandHandler('cancel', cancel))
    
    # Add handlers
    # Admin commands
    async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Admin user lookup and manual top-up or show diagnostics."""
        user_id = update.effective_user.id if update.effective_user else None
        logger.info("ADMIN_COMMAND: user_id=%s", user_id)
        if user_id is None or not is_admin(user_id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        _create_background_task(
            upsert_user_registry_entry(update.effective_user),
            action="user_registry_upsert",
        )
        reset_session_context(
            user_id,
            reason="command:/admin",
            clear_gen_type=True,
            correlation_id=ensure_correlation_id(update, context),
            update_id=update.update_id,
            chat_id=update.effective_chat.id if update.effective_chat else None,
        )
        
        # If "info" argument, show instance diagnostics
        if context.args and context.args[0].lower() == "info":
            from app.admin.diagnostics import build_admin_diagnostics_report

            report = await build_admin_diagnostics_report()
            await update.message.reply_text(report, parse_mode='HTML')
            return

        if context.args and context.args[0].lower() == "preflight":
            from app.diagnostics.billing_preflight import (
                format_billing_preflight_report,
                run_billing_preflight,
            )
            from app.storage import get_storage

            storage_instance = get_storage()
            report = await run_billing_preflight(storage_instance, db_pool=None)
            await update.message.reply_text(format_billing_preflight_report(report))
            return

        if context.args and context.args[0].lower() == "corr" and len(context.args) >= 2:
            from app.observability.error_buffer import get_error_summary
            import datetime

            corr_id = context.args[1].strip()
            summary = get_error_summary(corr_id)
            if not summary:
                await update.message.reply_text("‚ùå –ó–∞–ø–∏—Å—å —Å —ç—Ç–∏–º corr-id –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
                return
            timestamp = summary.get("timestamp")
            if timestamp:
                ts = datetime.datetime.fromtimestamp(timestamp).strftime("%d.%m.%Y %H:%M:%S")
            else:
                ts = "n/a"
            text = (
                "üß≠ <b>–û—à–∏–±–∫–∞ –ø–æ corr-id</b>\n\n"
                f"ID: <code>{summary.get('correlation_id')}</code>\n"
                f"Stage: {summary.get('stage')}\n"
                f"Handler: {summary.get('handler')}\n"
                f"Error: {summary.get('error_class')}\n"
                f"Time: {ts}"
            )
            await update.message.reply_text(text, parse_mode="HTML")
            return

        if context.args and context.args[0].lower() == "last_errors":
            from app.observability.error_buffer import get_last_errors
            import datetime

            items = get_last_errors(10)
            if not items:
                await update.message.reply_text("‚úÖ –û—à–∏–±–æ–∫ –Ω–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ.")
                return
            lines = ["üßæ <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –æ—à–∏–±–∫–∏</b>"]
            for item in items:
                timestamp = item.get("timestamp")
                if timestamp:
                    ts = datetime.datetime.fromtimestamp(timestamp).strftime("%d.%m %H:%M:%S")
                else:
                    ts = "n/a"
                lines.append(
                    f"‚Ä¢ <code>{item.get('correlation_id')}</code> "
                    f"{item.get('stage')}/{item.get('handler')} "
                    f"{item.get('error_class')} @ {ts}"
                )
            await update.message.reply_text("\n".join(lines), parse_mode="HTML")
            return
        
        if not context.args or len(context.args) == 0:
            try:
                from app.admin.router import show_admin_root
                await show_admin_root(update, context, is_callback=False)
                return
            except Exception:
                # Fallback to legacy admin panel
                await render_admin_panel(update, context, is_callback=False)
                return
        try:
            target_user_id = int(context.args[0])
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
            return
        text, keyboard = await build_admin_user_overview(target_user_id)
        await update.message.reply_text(text, reply_markup=keyboard, parse_mode='HTML')

    async def show_admin_payments(update_or_query, context: ContextTypes.DEFAULT_TYPE, is_callback: bool = False):
        """Show all payments (admin only). Can be called from command or callback."""
        # Determine if it's a callback query or message
        if is_callback:
            query = update_or_query
            user_id = query.from_user.id
            message_func = query.edit_message_text
        else:
            update = update_or_query
            user_id = update.effective_user.id
            message_func = update.message.reply_text
        
        if not is_admin(user_id):
            if is_callback:
                await query.answer("‚ùå –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", show_alert=True)
            else:
                await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        stats = get_payment_stats()
        payments = stats['payments']
        
        if not payments:
            await message_func("üìä <b>–ü–ª–∞—Ç–µ–∂–∏</b>\n\n–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π.", parse_mode='HTML')
            return
        
        # Show last 10 payments
        total_amount = stats['total_amount']
        total_count = stats['total_count']
        total_str = format_rub_amount(total_amount)
        
        text = f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π:</b>\n\n"
        text += f"üí∞ <b>–í—Å–µ–≥–æ:</b> {total_str}\n"
        text += f"üìù <b>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</b> {total_count}\n\n"
        text += f"<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∏:</b>\n\n"
        
        import datetime
        payments_with_screenshots = 0
        for payment in payments[:10]:
            user_id_payment = payment.get('user_id', 0)
            amount = payment.get('amount', 0)
            timestamp = payment.get('timestamp', 0)
            amount_str = format_rub_amount(amount)
            
            if timestamp:
                dt = datetime.datetime.fromtimestamp(timestamp)
                date_str = dt.strftime("%d.%m.%Y %H:%M")
            else:
                date_str = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            
            # Create user link: tg://user?id=USER_ID
            user_link = f"tg://user?id={user_id_payment}"
            text += f"üë§ <a href=\"{user_link}\">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id_payment}</a> | üíµ {amount_str} | üìÖ {date_str}\n"
            
            if payment.get('screenshot_file_id'):
                payments_with_screenshots += 1
        
        if total_count > 10:
            text += f"\n... –∏ –µ—â–µ {total_count - 10} –ø–ª–∞—Ç–µ–∂–µ–π"
        
        # Count total payments with screenshots
        total_with_screenshots = sum(1 for p in payments if p.get('screenshot_file_id'))
        
        # Add button to view screenshots
        keyboard = []
        if total_with_screenshots > 0:
            keyboard.append([InlineKeyboardButton("üì∏ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–∫—Ä–∏–Ω—à–æ—Ç–æ–≤", callback_data="view_payment_screenshots")])
        
        reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
        
        await message_func(text, parse_mode='HTML', reply_markup=reply_markup)
    
    async def admin_payments(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show all payments (admin only)."""
        await show_admin_payments(update, context, is_callback=False)
    
    async def admin_block_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Block a user (admin only)."""
        if not is_admin(update.effective_user.id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /block_user [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            block_user(user_id)
            await update.message.reply_text(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_unblock_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Unblock a user (admin only)."""
        if not is_admin(update.effective_user.id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unblock_user [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            unblock_user(user_id)
            await update.message.reply_text(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_user_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Check user balance (admin only)."""
        if not is_admin(update.effective_user.id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /user_balance [user_id]")
            return
        
        try:
            user_id = int(context.args[0])
            balance = await get_user_balance_async(user_id)
            balance_str = format_rub_amount(balance)
            is_blocked = is_user_blocked(user_id)
            blocked_text = "üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω" if is_blocked else "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω"
            
            # Get user payments
            user_payments = get_user_payments(user_id)
            total_paid = sum(p.get('amount', 0) for p in user_payments)
            total_paid_str = format_rub_amount(total_paid)
            
            # Check if user is limited admin
            admin_info = ""
            if is_admin(user_id) and user_id != ADMIN_ID:
                limit = get_admin_limit(user_id)
                spent = get_admin_spent(user_id)
                remaining = get_admin_remaining(user_id)
                admin_info = (
                    f"\nüëë <b>–ê–¥–º–∏–Ω —Å –ª–∏–º–∏—Ç–æ–º:</b>\n"
                    f"üí≥ –õ–∏–º–∏—Ç: {format_rub_amount(limit)}\n"
                    f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: {format_rub_amount(spent)}\n"
                    f"‚úÖ –û—Å—Ç–∞–ª–æ—Å—å: {format_rub_amount(remaining)}"
                )
            
            text = (
                f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {user_id}\n"
                f"üí∞ <b>–ë–∞–ª–∞–Ω—Å:</b> {balance_str}\n"
                f"üíµ <b>–í—Å–µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–æ:</b> {total_paid_str}\n"
                f"üìù <b>–ü–ª–∞—Ç–µ–∂–µ–π:</b> {len(user_payments)}\n"
                f"üîê <b>–°—Ç–∞—Ç—É—Å:</b> {blocked_text}"
                f"{admin_info}"
            )
            
            await update.message.reply_text(text, parse_mode='HTML')
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    async def admin_add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Add admin with 100 rubles limit (main admin only)."""
        if update.effective_user.id != ADMIN_ID:
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≥–ª–∞–≤–Ω–æ–º—É –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        if not context.args or len(context.args) == 0:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_admin [user_id]\n\n–î–æ–±–∞–≤–ª—è–µ—Ç –∞–¥–º–∏–Ω–∞ —Å –ª–∏–º–∏—Ç–æ–º 100 ‚ÇΩ –Ω–∞ —Ç–µ—Å—Ç—ã.")
            return
        
        try:
            new_admin_id = int(context.args[0])
            
            # Check if already admin
            if new_admin_id == ADMIN_ID:
                await update.message.reply_text("‚ùå –≠—Ç–æ –≥–ª–∞–≤–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä.")
                return
            
            admin_limits = get_admin_limits()
            if str(new_admin_id) in admin_limits:
                await update.message.reply_text(f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {new_admin_id} —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º.")
                return
            
            # Add admin with 100 rubles limit
            # NOTE: time already imported at top level
            admin_limits[str(new_admin_id)] = {
                'limit': 100.0,
                'spent': 0.0,
                'added_by': update.effective_user.id,
                'added_at': int(time.time())
            }
            save_admin_limits(admin_limits)
            
            await update.message.reply_text(
                f"‚úÖ <b>–ê–¥–º–∏–Ω –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
                f"üë§ User ID: {new_admin_id}\n"
                f"üí≥ –õ–∏–º–∏—Ç: 100.00 ‚ÇΩ\n"
                f"üí∏ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ: 0.00 ‚ÇΩ\n"
                f"‚úÖ –û—Å—Ç–∞–ª–æ—Å—å: 100.00 ‚ÇΩ",
                parse_mode='HTML'
            )
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç user_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–æ.")
    
    from app.telegram_error_handler import ensure_error_handler_registered
    ensure_error_handler_registered(application)
    
    # Add payment handlers for Telegram Stars
    # NOTE: MessageHandler and filters already imported at top level, don't re-import
    from telegram.ext import PreCheckoutQueryHandler
    application.add_handler(PreCheckoutQueryHandler(pre_checkout_query_handler))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment_handler))
    
    # CRITICAL FIX: Add universal photo handler as fallback to catch photos that ConversationHandler misses
    # This ensures photos are ALWAYS processed, even if ConversationHandler doesn't handle them
    async def universal_photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Universal photo handler that processes photos if ConversationHandler doesn't."""
        user_id = update.effective_user.id
        logger.info(f"üîµüîµüîµ UNIVERSAL_PHOTO_HANDLER CALLED: user_id={user_id}, has_photo={bool(update.message and update.message.photo)}")
        
        # Check if user is in conversation
        if user_id in user_sessions:
            session = user_sessions[user_id]
            model_id = session.get('model_id', 'Unknown')
            waiting_for = session.get('waiting_for', 'None')
            logger.info(f"üîµ User {user_id} has session: model_id={model_id}, waiting_for={waiting_for}")
            
            # If user is waiting for image, process it
            if waiting_for in ['image_input', 'image_urls', 'image', 'mask_input', 'reference_image_input']:
                logger.info(f"üîµ User {user_id} is waiting for {waiting_for}, calling input_parameters...")
                # Call input_parameters directly
                return await input_parameters(update, context)
            else:
                logger.warning(f"üîµ User {user_id} sent photo but waiting_for={waiting_for}, not processing")
        else:
            logger.warning(f"üîµ User {user_id} sent photo but no session found")
    
    # Add universal photo handler AFTER generation_handler to catch missed photos
    application.add_handler(MessageHandler(filters.PHOTO, universal_photo_handler))
    
    # Self-test command (admin only)
    async def selftest_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Self-test command –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (admin only)."""
        user_id = update.effective_user.id
        if not is_admin(user_id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        config = get_config_summary()
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º gateway
        gateway = get_kie_gateway()
        from kie_gateway import MockKieGateway, RealKieGateway
        if isinstance(gateway, MockKieGateway):
            gateway_type = "MockKieGateway"
        elif isinstance(gateway, RealKieGateway):
            gateway_type = "RealKieGateway"
        else:
            gateway_type = f"{type(gateway).__name__}"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º storage
        storage_status = "‚ùå –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
        try:
            from app.storage.factory import get_storage
            storage = get_storage()
            if storage.test_connection():
                storage_status = "‚úÖ –¥–æ—Å—Ç—É–ø–Ω–æ"
            else:
                storage_status = "‚ö†Ô∏è —Ç–µ—Å—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ –ø—Ä–æ—à–µ–ª"
        except Exception as e:
            storage_status = f"‚ùå –æ—à–∏–±–∫–∞: {str(e)[:50]}"
        db_status = storage_status  # For compatibility with existing code
        
        # –°–æ–±–∏—Ä–∞–µ–º callback_data –∏–∑ –∫–ª–∞–≤–∏–∞—Ç—É—Ä
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ test_callbacks_smoke, –Ω–æ –µ—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é
            try:
                from tests.test_callbacks_smoke import get_all_known_callbacks
                callback_count = len(get_all_known_callbacks())
            except ImportError:
                # Fallback: —Å—á–∏—Ç–∞–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
                known_patterns = [
                    'show_models', 'show_all_models_list', 'category:', 'all_models',
                    'gen_type:', 'free_tools', 'check_balance',
                    'copy_bot', 'claim_gift', 'help_menu',
                    'support_contact', 'select_model:', 'back_to_menu', 'topup_balance',
                    'topup_amount:', 'topup_custom', 'referral_info', 'generate_again',
                    'my_generations', 'gen_view:', 'gen_repeat:', 'gen_history:',
                    'tutorial_start', 'tutorial_step', 'tutorial_complete', 'confirm_generate',
                    'retry_generate:', 'retry_delivery:', 'cancel', 'back_to_previous_step', 'set_param:',
                ]
                callback_count = len(known_patterns) + len(get_models_sync())  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
        except Exception as e:
            callback_count = f"N/A ({str(e)[:30]})"
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç
        report = (
            "üîç <b>Self-Test Report</b>\n\n"
            f"üìã <b>–†–µ–∂–∏–º—ã:</b>\n"
            f"  TEST_MODE: {'‚úÖ' if config['TEST_MODE'] else '‚ùå'}\n"
            f"  DRY_RUN: {'‚úÖ' if config['DRY_RUN'] else '‚ùå'}\n"
            f"  ALLOW_REAL_GENERATION: {'‚úÖ' if config['ALLOW_REAL_GENERATION'] else '‚ùå'}\n\n"
            f"üîß <b>Gateway:</b> {gateway_type}\n\n"
            f"üóÑÔ∏è <b>GitHub storage:</b> {db_status}\n\n"
            f"üîò <b>Callback data:</b> {callback_count} –Ω–∞–π–¥–µ–Ω–æ\n\n"
            f"‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b> –í TEST_MODE/DRY_RUN –±–∞–ª–∞–Ω—Å –ù–ï —Å–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è"
        )
        
        await update.message.reply_text(report, parse_mode='HTML')

    async def config_check_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Partner config check command (admin only)."""
        user_id = update.effective_user.id
        if not is_admin(user_id):
            await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        from app.config_env import build_config_self_check_report

        report = build_config_self_check_report()
        await update.message.reply_text(report, parse_mode="HTML")
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("balance", check_balance))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("search", search))
    application.add_handler(CommandHandler("ask", ask))
    application.add_handler(CommandHandler("add", add_knowledge))
    application.add_handler(CommandHandler("selftest", selftest_command))
    application.add_handler(CommandHandler("config_check", config_check_command))
    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(CommandHandler("payments", admin_payments))
    application.add_handler(CommandHandler("block_user", admin_block_user))
    application.add_handler(CommandHandler("unblock_user", admin_unblock_user))
    application.add_handler(CommandHandler("user_balance", admin_user_balance))
    application.add_handler(CommandHandler("add_admin", admin_add_admin))
    # Admin panel (new, modular): adm:* callbacks
    try:
        from app.admin.router import admin_callback
        application.add_handler(CallbackQueryHandler(admin_callback, pattern='^adm:'))
    except Exception:
        # If modular admin router is unavailable, skip without breaking
        pass
    # Add separate handlers for main menu buttons (works outside ConversationHandler)
    # This ensures the buttons work from main menu
    # NOTE: These handlers must be registered BEFORE generation_handler to catch callbacks first
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^show_models$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^show_all_models_list$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^other_models$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^back_to_menu$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^retry_delivery:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^gen_type:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^category:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^all_models$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^check_balance$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^topup_balance$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^topup_amount:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^topup_custom$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^referral_info$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^my_generations$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^gen_view:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^gen_repeat:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^gen_history:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^help_menu$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^support_contact$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^free_tools$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^claim_gift$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^generate_again$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^copy_bot$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_start$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_step'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^tutorial_complete$'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^admin_user_info:'))
    application.add_handler(CallbackQueryHandler(button_callback, block=True, pattern='^admin_topup_user:'))
    
    # CRITICAL: Add universal fallback handler for ALL other callbacks
    # This ensures NO button is left unhandled - catches everything not matched above
    # Must be registered AFTER specific handlers but BEFORE generation_handler
    # This handler will catch any callback_data that doesn't match patterns above
    application.add_handler(CallbackQueryHandler(button_callback, block=True))
    
    # üî¥ –ì–õ–û–ë–ê–õ–¨–ù–´–ô ERROR HANDLER
    # –î—É–±–ª–∏–∫–∞—Ç error_handler —É–¥–∞–ª–µ–Ω - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 24313)
    
    application.add_handler(
        MessageHandler(
            filters.TEXT
            | filters.PHOTO
            | filters.AUDIO
            | filters.VOICE
            | filters.Document.ALL,
            active_session_router,
        ),
        group=-2,
    )
    application.add_handler(generation_handler)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, global_text_router), group=1)
    application.add_handler(MessageHandler(filters.PHOTO, global_photo_router), group=1)
    application.add_handler(
        MessageHandler(
            filters.AUDIO | filters.VOICE | (filters.Document.MimeType("audio/*")),
            global_audio_router,
        ),
        group=1,
    )
    application.add_handler(
        MessageHandler(
            (filters.TEXT & ~filters.COMMAND)
            | filters.PHOTO
            | filters.AUDIO
            | filters.VOICE
            | filters.Document.ALL,
            unhandled_update_fallback,
            block=False,
        ),
        group=100,
    )
    application.add_handler(CommandHandler("models", list_models))
    
    # HTTP server already started at the beginning of main()
    # Run the bot
    logger.info("Bot starting...")
    
    # ==================== BOT MODE SELECTION ====================
    # –ö–†–ò–¢–ò–ß–ù–û: –°—Ç—Ä–æ–≥–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ polling –∏ webhook —á–µ—Ä–µ–∑ BOT_MODE
    try:
        bot_mode = get_bot_mode()
    except ValueError as exc:
        logger.error("‚ùå Invalid BOT_MODE: %s", exc)
        raise SystemExit(2) from exc
    logger.info(f"üì° Bot mode: {bot_mode}")
    
    # –ï—Å–ª–∏ webhook —Ä–µ–∂–∏–º - –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º polling
    logger.info("üîç BOT_MODE_CHECK bot_mode=%s", bot_mode)
    if bot_mode == "webhook":
        logger.info("üîç WEBHOOK_MODE_ENTERED registering_application=true")
        global _application_for_webhook
        await _register_webhook_application(application)  # Register app for webhook handler
        logger.info("üîç WEBHOOK_MODE_REGISTERED application_registered=true")
        
        webhook_url = _resolve_webhook_url_from_env()
        if not webhook_url:
            logger.error("‚ùå WEBHOOK_URL not set for webhook mode!")
            logger.error("   Set WEBHOOK_URL environment variable or use BOT_MODE=polling")
            return
        
        logger.info(f"üåê Webhook mode configured: {webhook_url}")
        logger.info("üîÑ Webhook server will be started by sync entrypoint")
        
        # –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º webhook –∑–¥–µ—Å—å - —ç—Ç–æ —Å–¥–µ–ª–∞–µ—Ç sync entrypoint
        # —á—Ç–æ–±—ã PTB –º–æ–≥ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–ø—Ä–∞–≤–ª—è—Ç—å lifecycle event loop
        return  # –í—ã—Ö–æ–¥–∏–º –∏–∑ main(), webhook –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –∏–∑ sync –∫–æ–¥–∞
    else:
        logger.info("üîç POLLING_MODE_ENTERED webhook_skipped=true")

        try:
            try:
                from app.utils.healthcheck import start_health_server

                port_str = os.getenv("PORT", "10000").strip()
                try:
                    port = int(port_str)
                except ValueError:
                    port = 10000
                webhook_handler = await create_webhook_handler()
                started = await start_health_server(port=port, webhook_handler=webhook_handler, self_check=True)
                logger.info("[WEBHOOK] health_server_started=%s port=%s", started, port)
            except Exception as health_exc:
                logger.warning("[WEBHOOK] health_server_start_failed: %s", health_exc, exc_info=True)

            await _ensure_webhook_initialized(application, webhook_url)

            logger.info("‚úÖ Webhook mode ready - waiting for updates via webhook")
            logger.info("   Bot will receive updates at: %s", webhook_url)

            # –í webhook —Ä–µ–∂–∏–º–µ –ø—Ä–æ—Å—Ç–æ –∂–¥—ë–º (webhook handler –Ω–∞—Å—Ç—Ä–æ–µ–Ω –≤—ã—à–µ)
            while True:
                await asyncio.sleep(60)  # Health check loop
        except asyncio.CancelledError:
            logger.info("üõë Webhook mode cancelled; shutting down cleanly.")
            return
        finally:
            try:
                await stop_reconcilers(timeout_s=5.0)
            except Exception as exc:
                logger.warning("RECONCILER_STOP_FAILED error=%s", exc)
            try:
                from app.utils.healthcheck import stop_health_server

                await stop_health_server()
            except Exception as exc:
                logger.warning("[WEBHOOK] health_server_stop_failed=%s", exc)
            try:
                await application.stop()
                await application.shutdown()
            except Exception as exc:
                logger.warning("WEBHOOK_APP_SHUTDOWN_FAILED error=%s", exc)
            await cleanup_storage()
            await cleanup_http_client()
    
    # Polling —Ä–µ–∂–∏–º - –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ
    logger.info("üì° Starting polling mode")
    
    # CRITICAL: Wait longer to let any previous instance finish completely
    # –ù–∞ Render –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤, –∑–∞–ø—É—Å–∫–∞—é—â–∏—Ö—Å—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    logger.info("‚è≥ Waiting 10 seconds to avoid conflicts with previous instance...")
    await asyncio.sleep(10)
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —É–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ polling
    logger.info("üîç Final conflict check before polling...")
    try:
        from telegram import Bot
        check_bot = Bot(token=BOT_TOKEN)
        # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å webhook info - –µ—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π polling, —ç—Ç–æ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç
        webhook_info = await check_bot.get_webhook_info()
        if webhook_info.url:
            logger.warning(f"‚ö†Ô∏è Webhook still active: {webhook_info.url}, removing...")
            await check_bot.delete_webhook(drop_pending_updates=True)
            await asyncio.sleep(2)
        
        # –ü—Ä–æ–±—É–µ–º getUpdates —Å –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–º timeout –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞
        try:
            await check_bot.get_updates(offset=-1, limit=1, timeout=1)
        except Exception as test_e:
            if "Conflict" in str(test_e) or "terminated by other getUpdates" in str(test_e):
                logger.error("‚ùå‚ùå‚ùå CONFLICT DETECTED: Another instance is polling!")
                logger.error("   Exiting gracefully to prevent 409 Conflict...")
                handle_conflict_gracefully(test_e, "polling")
                return
    except Exception as e:
        if "Conflict" in str(e) or "terminated by other getUpdates" in str(e):
            logger.error("‚ùå‚ùå‚ùå CONFLICT DETECTED during pre-check!")
            handle_conflict_gracefully(e, "polling")
            return
        logger.warning(f"‚ö†Ô∏è Pre-check warning (non-critical): {e}")
    
    # –ö–†–ò–¢–ò–ß–ù–û: –£–¥–∞–ª–∏—Ç—å –í–°–ï webhook –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º polling
    async def preflight_telegram():
        """
        Preflight –ø—Ä–æ–≤–µ—Ä–∫–∞: —É–¥–∞–ª—è–µ—Ç webhook –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤.
        –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ polling –±—É–¥–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –∞–ø–¥–µ–π—Ç–æ–≤.
        –¢–û–õ–¨–ö–û –¥–ª—è polling —Ä–µ–∂–∏–º–∞!
        """
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π bot –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ (–±–µ–∑ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ application)
            from telegram import Bot
            temp_bot = Bot(token=BOT_TOKEN)
            
            async with temp_bot:
                # –®–∞–≥ 1: –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ webhook
                logger.info("üîç Checking webhook status...")
                webhook_info = await temp_bot.get_webhook_info()
                
                if webhook_info.url:
                    logger.warning(f"‚ö†Ô∏è Webhook –æ–±–Ω–∞—Ä—É–∂–µ–Ω: {webhook_info.url}")
                    logger.info("üóëÔ∏è –£–¥–∞–ª—è—é webhook —Å drop_pending_updates=True...")
                    
                    # –£–¥–∞–ª—è–µ–º webhook —Å –æ—á–∏—Å—Ç–∫–æ–π –æ—á–µ—Ä–µ–¥–∏
                    result = await temp_bot.delete_webhook(drop_pending_updates=True)
                    logger.info(f"‚úÖ Webhook —É–¥–∞–ª—ë–Ω: {result}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ webhook –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª—ë–Ω
                    await asyncio.sleep(1)  # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è Telegram API
                    webhook_info_after = await temp_bot.get_webhook_info()
                    
                    if webhook_info_after.url:
                        logger.error(f"‚ùå Webhook –≤—Å—ë –µ—â—ë —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {webhook_info_after.url}")
                        logger.error("üîÑ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è...")
                        await temp_bot.delete_webhook(drop_pending_updates=True)
                        await asyncio.sleep(1)
                        webhook_info_final = await temp_bot.get_webhook_info()
                        if webhook_info_final.url:
                            logger.error("‚ùå‚ùå‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å webhook –ø–æ—Å–ª–µ 2 –ø–æ–ø—ã—Ç–æ–∫!")
                            raise RuntimeError(f"Webhook still active: {webhook_info_final.url}")
                        else:
                            logger.info("‚úÖ Webhook —É–¥–∞–ª—ë–Ω –ø–æ—Å–ª–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏")
                    else:
                        logger.info("‚úÖ Webhook –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—ë–Ω, –≥–æ—Ç–æ–≤ –∫ polling")
                else:
                    logger.info("‚úÖ Webhook –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≥–æ—Ç–æ–≤ –∫ polling")
                
                # –®–∞–≥ 2: –ò—Å–ø–æ–ª—å–∑—É–µ–º bot_mode helper –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ polling —Ä–µ–∂–∏–º–∞
                if not await ensure_polling_mode(temp_bot):
                    raise RuntimeError("Failed to ensure polling mode")
                
                logger.info("‚úÖ Preflight check passed: no conflicts detected, ready for polling")
        except Conflict as e:
            handle_conflict_gracefully(e, "polling")
            raise
        except Exception as e:
            error_msg = str(e)
            if "Conflict" in error_msg or "terminated by other getUpdates" in error_msg:
                from telegram.error import Conflict as TelegramConflict
                handle_conflict_gracefully(TelegramConflict(str(e)), "polling")
                raise
            else:
                logger.warning(f"‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ preflight check: {e}")
                # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
    
    # ==================== –ï–î–ò–ù–ê–Ø –¢–û–ß–ö–ê –í–•–û–î–ê –î–õ–Ø –°–¢–ê–†–¢–ê POLLING ====================
    # –ñ—ë—Å—Ç–∫–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—É—Å–∫–æ–≤ (409 Conflict)
    async def safe_start_polling(application: Application, *, drop_updates: bool = True):
        """
        –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–ø–æ—Å–æ–± –∑–∞–ø—É—Å–∫–∞ polling.
        –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ polling –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑.
        –ö–†–ò–¢–ò–ß–ù–û: –£–¥–∞–ª—è–µ—Ç webhook –ü–ï–†–ï–î –∑–∞–ø—É—Å–∫–æ–º polling.
        """
        global _POLLING_STARTED
        
        async with _POLLING_LOCK:
            if _POLLING_STARTED:
                logger.warning("‚ö†Ô∏è Polling already started; skip second start")
                return
            _POLLING_STARTED = True
        
        # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ single instance lock –≤—Å–µ –µ—â–µ –∞–∫—Ç–∏–≤–µ–Ω –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º polling
        from app.locking.single_instance import is_lock_held
        if not is_lock_held():
            logger.error("‚ùå‚ùå‚ùå Single instance lock –Ω–µ —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è! –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å polling.")
            logger.error("   This should not happen - lock should be acquired at startup")
            raise RuntimeError("Single instance lock not held - cannot start polling")
        
        logger.info("‚úÖ Single instance lock verified - proceeding with polling start")
        
        # –ö–†–ò–¢–ò–ß–ù–û: Polling mode must not have webhook
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º temp Bot –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è webhook –ü–ï–†–ï–î –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π application
        logger.info("üóëÔ∏è Removing webhook before polling start...")
        try:
            from telegram import Bot
            async with Bot(token=BOT_TOKEN) as temp_bot:
                await temp_bot.delete_webhook(drop_pending_updates=drop_updates)
                webhook_info = await temp_bot.get_webhook_info()
                if webhook_info.url:
                    logger.warning(f"‚ö†Ô∏è Webhook still present after delete: {webhook_info.url}")
                else:
                    logger.info("‚úÖ Webhook removed successfully")
        except Conflict as e:
            handle_conflict_gracefully(e, "polling")
            raise
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error removing webhook: {e}")
            # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ - –ø—Ä–æ–¥–æ–ª–∂–∏–º
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º polling
        logger.info("üöÄ Initializing application...")
        await application.initialize()
        await application.start()
        start_delivery_reconciler(application.bot)
        start_dedupe_reconciler(application.bot)
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã –≤ –º–µ–Ω—é Telegram
        logger.info("üìã Setting up bot commands menu...")
        try:
            # –ë–∞–∑–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            user_commands = [
                BotCommand("start", "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
                BotCommand("help", "–ü–æ–º–æ—â—å"),
                BotCommand("balance", "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å"),
                BotCommand("status", "–°—Ç–∞—Ç—É—Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"),
                BotCommand("cancel", "–û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ"),
            ]
            
            # –ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
            admin_commands = user_commands + [
                BotCommand("admin", "–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞"),
                BotCommand("payments", "–°–ø–∏—Å–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π"),
                BotCommand("selftest", "–°–∞–º–æ–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –±–æ—Ç–∞"),
            ]
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            await application.bot.set_my_commands(user_commands)
            logger.info(f"‚úÖ Registered {len(user_commands)} user commands")
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
            from telegram import BotCommandScopeAllChatAdministrators
            await application.bot.set_my_commands(
                admin_commands, 
                scope=BotCommandScopeAllChatAdministrators()
            )
            logger.info(f"‚úÖ Registered {len(admin_commands)} admin commands")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Failed to set bot commands: {e}")
            # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ - –ø—Ä–æ–¥–æ–ª–∂–∏–º —Ä–∞–±–æ—Ç—É
        
        logger.info("üì° Starting polling...")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º polling —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π Conflict
        try:
            await application.updater.start_polling(drop_pending_updates=drop_updates)
            logger.info("‚úÖ Polling started successfully!")
        except Conflict as e:
            logger.error(f"‚ùå‚ùå‚ùå Conflict during polling start: {e}")
            logger.error("   Another bot instance is already polling")
            try:
                await application.stop()
                await application.shutdown()
            except:
                pass
            try:
                from app.locking.single_instance import release_single_instance_lock
                release_single_instance_lock()
            except:
                pass
            handle_conflict_gracefully(e, "polling")
            import os
            os._exit(0)  # Immediate exit
        except Exception as e:
            error_msg = str(e)
            if "Conflict" in error_msg or "terminated by other getUpdates" in error_msg or "409" in error_msg:
                logger.error(f"‚ùå‚ùå‚ùå Conflict detected during polling start: {error_msg}")
                try:
                    await application.stop()
                    await application.shutdown()
                except:
                    pass
                try:
                    from app.locking.single_instance import release_single_instance_lock
                    release_single_instance_lock()
                except:
                    pass
                from telegram.error import Conflict as TelegramConflict
                handle_conflict_gracefully(TelegramConflict(error_msg), "polling")
                import os
                os._exit(0)  # Immediate exit
            else:
                raise  # Re-raise non-Conflict errors
    
    # –í—ã–ø–æ–ª–Ω—è–µ–º preflight –ø—Ä–æ–≤–µ—Ä–∫—É
    logger.info("üöÄ Starting preflight check (webhook removal + conflict detection)...")
    try:
        await preflight_telegram()
        logger.info("‚úÖ Preflight check passed: ready to start bot")
    except RuntimeError as e:
        if "Another bot instance" in str(e) or "Conflict" in str(e):
            logger.error("‚ùå Cannot start: Another bot instance is running!")
            logger.error("Fix the conflict and restart the service.")
            return
        else:
            raise
    except Conflict as e:
        handle_conflict_gracefully(e, "polling")
        return
    except Exception as e:
        if "Conflict" in str(e) or "terminated by other getUpdates" in str(e):
            from telegram.error import Conflict as TelegramConflict
            handle_conflict_gracefully(TelegramConflict(str(e)), "polling")
            return
        else:
            logger.warning(f"‚ö†Ô∏è Preflight warning (continuing): {e}")
    
    heartbeat_stop_event = asyncio.Event()
    heartbeat_interval = _normalize_heartbeat_interval(BOT_HEARTBEAT_INTERVAL_SECONDS)
    heartbeat_task: Optional[asyncio.Task] = None

    # –ó–∞–ø—É—Å–∫–∞–µ–º polling —á–µ—Ä–µ–∑ –µ–¥–∏–Ω—É—é —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞
    await safe_start_polling(application, drop_updates=True)

    if heartbeat_interval > 0:
        heartbeat_task = asyncio.create_task(
            _bot_heartbeat_loop(heartbeat_stop_event, heartbeat_interval),
            name="bot-heartbeat",
        )
    else:
        logger.info("üíì BOT_HEARTBEAT disabled interval_s=%s", BOT_HEARTBEAT_INTERVAL_SECONDS)
    
    # –ñ–¥—ë–º –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ (polling —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ñ–æ–Ω–µ)
    # Advisory lock –±—É–¥–µ—Ç –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω —á–µ—Ä–µ–∑ atexit handler –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞
    try:
        await asyncio.Event().wait()  # –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ
    except asyncio.CancelledError:
        logger.info("üõë Bot main cancelled; shutting down cleanly.")
    except KeyboardInterrupt:
        logger.info("üõë Shutting down bot (KeyboardInterrupt)...")
    finally:
        if heartbeat_task is not None:
            heartbeat_stop_event.set()
            try:
                await asyncio.wait_for(heartbeat_task, timeout=5)
            except asyncio.TimeoutError:
                heartbeat_task.cancel()
                try:
                    await heartbeat_task
                except asyncio.CancelledError:
                    pass
            except Exception as e:
                logger.warning("üíì BOT_HEARTBEAT stop_failed error=%s", e)

        try:
            await stop_reconcilers(timeout_s=5.0)
        except Exception as exc:
            logger.warning("RECONCILER_STOP_FAILED error=%s", exc)
        try:
            from app.utils.healthcheck import stop_health_server

            await stop_health_server()
        except Exception as exc:
            logger.warning("[BOOT] health_server_stop_failed=%s", exc)

        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º application
        try:
            await application.stop()
            await application.shutdown()
        except Exception as e:
            logger.error(f"Error stopping application: {e}")

        await cleanup_storage()
        await cleanup_http_client()
        
        # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º single instance lock –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –∫ atexit)
        try:
            from app.locking.single_instance import release_single_instance_lock
            release_single_instance_lock()
            logger.info("‚úÖ Single instance lock released in finally block")
        except Exception as e:
            logger.error(f"Error releasing lock in finally: {e}")


# ==================== HEALTH HTTP SERVER FOR RENDER ====================
# –ü—Ä–æ—Å—Ç–æ–π HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è health check (—á—Ç–æ–±—ã Render –Ω–µ –∂–∞–ª–æ–≤–∞–ª—Å—è –Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø–æ—Ä—Ç–∞)
class HealthHandler(BaseHTTPRequestHandler):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è health check endpoints"""
    def do_GET(self):
        if self.path in ("/", "/health", "/healthz"):
            self.send_response(200)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(b"ok")
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        # –û—Ç–∫–ª—é—á–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ HTTP –∑–∞–ø—Ä–æ—Å–æ–≤ (—á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å –ª–æ–≥–∏)
        return  # silence

def start_health_server():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Å—Ç–æ–π HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è health check"""
    try:
        port = int(os.getenv("PORT", "10000"))
        server = HTTPServer(("0.0.0.0", port), HealthHandler)
        logger.info(f"‚úÖ Health server started on 0.0.0.0:{port}")
        logger.info(f"   Health check endpoints: /, /health, /healthz")
        server.serve_forever()
    except OSError as e:
        if "Address already in use" in str(e):
            logger.warning(f"‚ö†Ô∏è Port {port} already in use, health server may already be running")
        else:
            logger.error(f"‚ùå Failed to start health server: {e}")
    except Exception as e:
        logger.error(f"‚ùå Failed to start health server: {e}")
        # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É –±–æ—Ç–∞

if __name__ == '__main__':
    # Legacy health server is disabled by default to avoid port conflicts.
    ENABLE_HEALTH_SERVER = os.getenv("ENABLE_HEALTH_SERVER", "1") == "1"
    USE_LEGACY_HEALTH_SERVER = os.getenv("USE_LEGACY_HEALTH_SERVER", "0") == "1"

    if ENABLE_HEALTH_SERVER and USE_LEGACY_HEALTH_SERVER:
        port = int(os.getenv("PORT", "10000"))
        logger.info("üöÄ Starting legacy health server on port %s...", port)
        health_thread = threading.Thread(target=start_health_server, daemon=True)
        health_thread.start()
        time.sleep(1)
        logger.info("‚úÖ Legacy health server listening on 0.0.0.0:%s", port)
    elif ENABLE_HEALTH_SERVER:
        logger.info("‚ÑπÔ∏è Legacy health server disabled (USE_LEGACY_HEALTH_SERVER=0)")
    else:
        logger.info("‚ÑπÔ∏è Health server disabled (ENABLE_HEALTH_SERVER=0) - running as Worker")

    # –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–∞—Ö - —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—Ä—è–º–æ–º –≤—ã–∑–æ–≤–µ
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("üõë Bot stopped by user (KeyboardInterrupt)")
        sys.exit(0)
    except asyncio.CancelledError:
        logger.info("üõë Bot shutdown requested (CancelledError)")
        sys.exit(0)
    except Exception as e:
        logger.error(f"‚ùå Fatal error in main(): {e}", exc_info=True)
        logger.error("‚ùå Bot failed to start. Check logs above for details.")
        sys.exit(1)


async def handle_gen_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏."""
    query = update.callback_query
    if not query:
        return ConversationHandler.END
    
    user_id = query.from_user.id if query.from_user else None
    user_lang = get_user_language(user_id) if user_id else "ru"
    
    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑ callback_data
    gen_type = query.data.split(":", 1)[1] if ":" in query.data else ""
    
    if not gen_type:
        logger.warning(f"Invalid gen_type callback data: {query.data}")
        return ConversationHandler.END
    
    logger.info(f"User {user_id} selected gen_type: {gen_type}")
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ—Å—Å–∏–∏
    set_session_context(
        user_id,
        to_context="MODEL_MENU",
        reason=f"gen_type:{gen_type}",
        correlation_id=ensure_correlation_id(update, context),
        update_id=update.update_id,
        chat_id=query.message.chat_id if query.message else None,
    )
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    session = get_session_cached(context, get_session_store(context), user_id, update.update_id, default={})
    if isinstance(session, dict):
        session["active_gen_type"] = gen_type
        session["gen_type"] = gen_type
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é –º–æ–¥–µ–ª–µ–π –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    try:
        from app.helpers.models_menu import build_models_menu_for_type
        from app.models.registry import _gen_type_to_model_type
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º gen_type –≤ model_type
        model_type = _gen_type_to_model_type(gen_type)
        
        keyboard_markup, models_count = build_models_menu_for_type(user_lang, model_type)
        
        if user_lang == "ru":
            header_text = (
                f"üéØ <b>–í—ã–±—Ä–∞–Ω —Ç–∏–ø:</b> {gen_type}\n\n"
                f"–î–æ—Å—Ç—É–ø–Ω–æ –º–æ–¥–µ–ª–µ–π: <b>{models_count}</b>\n\n"
                "–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –Ω–∏–∂–µ:"
            )
        else:
            header_text = (
                f"üéØ <b>Selected type:</b> {gen_type}\n\n"
                f"Available models: <b>{models_count}</b>\n\n"
                "Select a model below:"
            )
        
        await query.edit_message_text(
            header_text,
            reply_markup=keyboard_markup,
            parse_mode="HTML",
        )
        
    except Exception as e:
        logger.error(f"Error building models menu for gen_type {gen_type}: {e}")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º fallback –º–µ–Ω—é
        from helpers import build_back_to_menu_keyboard
        
        fallback_text = (
            "‚ö†Ô∏è <b>–í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞</b>\n\n"
            "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            if user_lang == "ru" else
            "‚ö†Ô∏è <b>Temporary error</b>\n\n"
            "Failed to load models. Please try again later."
        )
        
        await query.edit_message_text(
            fallback_text,
            reply_markup=build_back_to_menu_keyboard(user_lang),
            parse_mode="HTML",
        )
    
    return ConversationHandler.END


def run_webhook_sync(application):
    """
    Sync —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ webhook —Å–µ—Ä–≤–µ—Ä–∞.
    –î–∞—ë—Ç PTB –ø–æ–ª–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ event loop lifecycle.
    """
    import os
    from telegram import Update
    
    webhook_url = _resolve_webhook_url_from_env()
    if not webhook_url:
        raise RuntimeError("WEBHOOK_URL not set for webhook mode!")
    
    logger.info(f"üöÄ Starting webhook server in sync mode: {webhook_url}")
    
    # –î–æ–±–∞–≤–ª—è–µ–º post_shutdown —Ö—É–∫ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ singleton_lock
    async def cleanup_on_shutdown():
        try:
            from app.utils.singleton_lock import release_singleton_lock
            await release_singleton_lock()
            logger.info("‚úÖ Singleton lock released on shutdown")
        except Exception as exc:
            logger.warning("‚ö†Ô∏è Failed to release singleton lock on shutdown: %s", exc)
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º cleanup —Ö—É–∫
    application.add_post_shutdown_hook(cleanup_on_shutdown)
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º webhook –≤ sync —Ä–µ–∂–∏–º–µ - PTB —Å–∞–º —É–ø—Ä–∞–≤–ª—è–µ—Ç loop
    application.run_webhook(
        listen="0.0.0.0",
        port=int(os.getenv("PORT", "10000")),
        url_path="webhook",
        webhook_url=f"{webhook_url}",
        drop_pending_updates=True,
        secret_token=os.getenv("WEBHOOK_SECRET_TOKEN"),
        allowed_updates=Update.ALL_TYPES,
    )


if __name__ == "__main__":
    # –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —á–µ—Ä–µ–∑ asyncio.run
    # –ù–ï –∑–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–∞—Ö - —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—Ä—è–º–æ–º –≤—ã–∑–æ–≤–µ
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("üõë Bot stopped by user (KeyboardInterrupt)")
        sys.exit(0)
    except asyncio.CancelledError:
        logger.info("üõë Bot shutdown requested (CancelledError)")
        sys.exit(0)
    except Exception as e:
        logger.error(f"‚ùå Fatal error in main(): {e}", exc_info=True)
        logger.error("‚ùå Bot failed to start. Check logs above for details.")
        sys.exit(1)
