#!/usr/bin/env python3















"""















Render-first entrypoint ????????????????? Telegram Bot















?????????????????????????????????? ???????????????????????????? ????????????????????????????? ????????????????? ???????????????????????????????????????? ???????????? Render.com (Web Service ?????????????????? Worker)















"""































import sys















import os















import logging















import asyncio















import time















from pathlib import Path















from typing import Optional































# ???????????????????????????????????????????????????? ????????????????????????????????????????????? ???????????????????????????????????????????????????????? ?????? ????????????????????? (???????????????????????????????????????? ????????????????? Render)















project_root = Path(__file__).parent.absolute()















if str(project_root) not in sys.path:















    sys.path.insert(0, str(project_root))































# ?????????????????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????? ????????????????????????? ?????????????????????????????????????????????? ????????????????????????????????? ?????????????????????????????????????????















from app.utils.logging_config import setup_logging, get_logger































setup_logging(level=logging.INFO)















logger = get_logger(__name__)

_bot_ready = False
_handler_ready = False
_dynamic_webhook_handler = None































# ????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????















_start_time = time.time()















_application: Optional[object] = None















































def log_env_snapshot():















    """???????????????????????????????????????????? snapshot ENV ????????????????????????????????????????????????????????? ?????????????????? ?????????????????????????????????????????????"""















    env_vars = {















        "PORT": os.getenv("PORT", "not set"),















        "RENDER": os.getenv("RENDER", "not set"),















        "ENV": os.getenv("ENV", "not set"),















        "BOT_MODE": os.getenv("BOT_MODE", "not set"),















        "STORAGE_MODE": os.getenv("STORAGE_MODE", "not set"),















        "DATABASE_URL": "[SET]" if os.getenv("DATABASE_URL") else "[NOT SET]",















        "TELEGRAM_BOT_TOKEN": "[SET]" if os.getenv("TELEGRAM_BOT_TOKEN") else "[NOT SET]",















        "KIE_API_KEY": "[SET]" if os.getenv("KIE_API_KEY") else "[NOT SET]",















        "KIE_API_URL": os.getenv("KIE_API_URL", "not set"),















        "TEST_MODE": os.getenv("TEST_MODE", "not set"),















        "DRY_RUN": os.getenv("DRY_RUN", "not set"),















        "ALLOW_REAL_GENERATION": os.getenv("ALLOW_REAL_GENERATION", "not set"),















    }















    















    logger.info("=" * 60)















    logger.info("ENVIRONMENT VARIABLES SNAPSHOT")















    logger.info("=" * 60)















    for key, value in sorted(env_vars.items()):















        logger.info(f"{key}={value}")















    logger.info("=" * 60)















































def ensure_data_directory(data_dir: str) -> bool:















    """???????????????????????????????????????????????????????????? ??????????????????????????????????????????????? data ????????????????????????????????????????????????????????? ?????? ?????????????????????????????????????????????????? ????????????????????????????? ???????????????????????????????????"""















    try:















        data_path = Path(data_dir)















        data_path.mkdir(parents=True, exist_ok=True)















        















        # ?????????????????????????????????????????????????? ????????????????????????????? ???????????????????????????????????















        test_file = data_path / ".write_test"















        try:















            test_file.write_text("test")















            test_file.unlink()















            logger.info(f"[OK] Data directory writable: {data_dir}")















            return True















        except Exception as e:















            logger.error(f"[FAIL] Cannot write to data directory {data_dir}: {e}")















            return False















    except Exception as e:















        logger.error(f"[FAIL] Cannot create data directory {data_dir}: {e}")















        return False















































def build_webhook_handler(application, settings):
    """Build aiohttp webhook handler for Telegram updates."""
    from aiohttp import web
    from telegram import Update
    import uuid
    from app.observability.trace import set_correlation_id, reset_correlation_id
    from app.observability.structured_logs import log_structured_event

    secret_token = os.getenv("WEBHOOK_SECRET_TOKEN", "").strip()

    async def webhook_handler(request: web.Request) -> web.StreamResponse:
        correlation_id = (
            request.headers.get("X-Request-ID")
            or request.headers.get("X-Correlation-ID")
            or str(uuid.uuid4())
        )
        start_ts = time.monotonic()
        status = 500
        ack_status = 500
        method = request.method
        path = request.path
        content_length = request.content_length or 0
        try:
            if not _bot_ready:
                status = 503
                logger.warning(
                    "[WEBHOOK] handler_ready=%s bot_ready=%s status=%s correlation_id=%s",
                    str(_handler_ready).lower(),
                    str(_bot_ready).lower(),
                    status,
                    correlation_id,
                )
                return web.Response(status=status)

            if secret_token:
                incoming = request.headers.get("X-Telegram-Bot-Api-Secret-Token", "")
                if not incoming:
                    status = 401
                    logger.warning(
                        "[WEBHOOK] secret_ok=false reason=missing_token status=%s correlation_id=%s",
                        status,
                        correlation_id,
                    )
                    return web.Response(status=status)
                secret_ok = incoming == secret_token
                logger.info(
                    "[WEBHOOK] secret_ok=%s correlation_id=%s",
                    str(secret_ok).lower(),
                    correlation_id,
                )
                if not secret_ok:
                    status = 403
                    return web.Response(status=status)
            else:
                logger.info("[WEBHOOK] secret_ok=true correlation_id=%s", correlation_id)

            smoke_no_process = os.getenv("SMOKE_NO_PROCESS", "").lower() in ("1", "true", "yes")
            try:
                payload = await request.json()
            except Exception as exc:
                status = 400
                logger.warning(
                    "[WEBHOOK] update_received=false reason=json_parse_error error=%s correlation_id=%s",
                    exc,
                    correlation_id,
                )
                return web.Response(status=status)

            ack_status = 200
            if smoke_no_process:
                logger.info(
                    "[WEBHOOK] update_received=true smoke_no_process=true correlation_id=%s",
                    correlation_id,
                )
                status = ack_status
                return web.Response(status=status)

            logger.info("[WEBHOOK] update_received=true correlation_id=%s", correlation_id)
            try:
                update = Update.de_json(payload, application.bot)
            except Exception as exc:
                logger.warning(
                    "[WEBHOOK] update_received=true invalid_update=true error=%s correlation_id=%s",
                    exc,
                    correlation_id,
                )
                status = ack_status
                return web.Response(status=status)

            async def _send_fallback_message() -> None:
                chat_id = None
                try:
                    if update.effective_chat:
                        chat_id = update.effective_chat.id
                    elif update.message:
                        chat_id = update.message.chat_id
                    elif update.callback_query and update.callback_query.message:
                        chat_id = update.callback_query.message.chat_id
                except Exception:
                    chat_id = None

                if not chat_id:
                    return

                try:
                    if update.callback_query:
                        try:
                            await update.callback_query.answer()
                        except Exception:
                            pass
                    await application.bot.send_message(
                        chat_id=chat_id,
                        text=(
                            "❌ <b>Ошибка обработки запроса</b>\n\n"
                            "Мы уже знаем о проблеме и работаем над ней.\n"
                            f"ID: {correlation_id}"
                        ),
                        parse_mode="HTML",
                    )
                except Exception as send_exc:  # pragma: no cover - best effort
                    logger.warning(
                        "[WEBHOOK] fallback_send_failed error=%s correlation_id=%s",
                        send_exc,
                        correlation_id,
                    )

            async def _process() -> None:
                token = set_correlation_id(correlation_id)
                try:
                    await application.process_update(update)
                    logger.info(
                        "[WEBHOOK] handler_outcome=success correlation_id=%s",
                        correlation_id,
                    )
                except Exception as exc:  # pragma: no cover - logging path
                    logger.exception(
                        "[WEBHOOK] handler_outcome=failed error=%s correlation_id=%s",
                        exc,
                        correlation_id,
                    )
                    log_structured_event(
                        correlation_id=correlation_id,
                        action="WEBHOOK_PROCESS",
                        action_path="webhook_handler.process_update",
                        outcome="failed",
                        error_code="INTERNAL_EXCEPTION",
                        fix_hint="Проверьте stacktrace и логи.",
                    )
                    await _send_fallback_message()
                finally:
                    reset_correlation_id(token)

            token = set_correlation_id(correlation_id)
            asyncio.create_task(_process())
            logger.info(
                "[WEBHOOK] forwarded_to_ptb=true outcome=queued correlation_id=%s",
                correlation_id,
            )
            status = ack_status
            reset_correlation_id(token)
            return web.Response(status=status)
        except Exception as exc:
            if ack_status == 200:
                logger.exception(
                    "[WEBHOOK] handler_error=exception_acked error=%s correlation_id=%s",
                    exc,
                    correlation_id,
                )
                log_structured_event(
                    correlation_id=correlation_id,
                    action="WEBHOOK_ERROR",
                    action_path="webhook_handler",
                    outcome="exception_acked",
                    error_code="INTERNAL_EXCEPTION",
                    fix_hint="Проверьте stacktrace и логи.",
                )
                status = ack_status
                return web.Response(status=status)
            logger.exception(
                "[WEBHOOK] handler_error=exception_unacked error=%s correlation_id=%s",
                exc,
                correlation_id,
            )
            log_structured_event(
                correlation_id=correlation_id,
                action="WEBHOOK_ERROR",
                action_path="webhook_handler",
                outcome="exception_unacked",
                error_code="INTERNAL_EXCEPTION",
                fix_hint="Проверьте stacktrace и логи.",
            )
            status = 500
            return web.Response(status=status)
        finally:
            latency_ms = int((time.monotonic() - start_ts) * 1000)
            logger.info(
                "[WEBHOOK] request method=%s path=%s status=%s latency_ms=%s content_length=%s correlation_id=%s",
                method,
                path,
                status,
                latency_ms,
                content_length,
                correlation_id,
            )

    return webhook_handler


def build_dynamic_webhook_handler():
    from aiohttp import web

    async def dynamic_webhook_handler(request: web.Request) -> web.StreamResponse:
        if _dynamic_webhook_handler is None:
            logger.warning(
                "[WEBHOOK] handler_ready=false reason=handler_not_bound bot_ready=%s",
                str(_bot_ready).lower(),
            )
            return web.Response(status=503)
        return await _dynamic_webhook_handler(request)

    return dynamic_webhook_handler


def load_and_validate_settings():















    """?????????????????????????????????????????????????? ?????? ????????????????????????????????????????????????????????? ??????????????????????????????????????????????????? ???????????? ENV"""















    from app.config import get_settings















    















    logger.info("=" * 60)















    logger.info("BOT STARTING")















    logger.info("=" * 60)















    















    try:















        # ????????????????????????????????????????????? ENV snapshot















        log_env_snapshot()















        















        # ??????????????????????????????????????????????????? ??????????????????????????????????????????????????? ????? ???????????????????????????????????????????????????????????















        settings = get_settings(validate=True)















        















        # Startup banner















        logger.info("=" * 60)















        logger.info("STARTUP BANNER")















        logger.info("=" * 60)















        logger.info(f"Python version: {sys.version.split()[0]}")















        logger.info(f"Working directory: {os.getcwd()}")















        logger.info(f"Process ID: {os.getpid()}")















        logger.info(f"Render environment: {os.getenv('RENDER', 'not detected')}")















        logger.info(f"Storage mode: {settings.get_storage_mode()}")















        logger.info(f"KIE mode: {'stub' if os.getenv('KIE_STUB') else ('real' if settings.kie_api_key else 'disabled')}")















        logger.info(f"Bot mode: {settings.bot_mode}")
        logger.info(
            "[WEBHOOK] computed_webhook_url=%s",
            settings.webhook_url if settings.webhook_url else "missing",
        )















        logger.info(f"Port: {settings.port if settings.port > 0 else 'disabled (Worker mode)'}")















        logger.info(f"Data directory: {settings.data_dir}")















        logger.info("=" * 60)















        















        # ?????????????????????????????????????????????????? data directory















        if not ensure_data_directory(settings.data_dir):















            logger.error("[FAIL] Data directory not writable, exiting")















            sys.exit(1)















        















        return settings















    except ValueError as e:















        logger.error("=" * 60)















        logger.error("CONFIGURATION VALIDATION FAILED")















        logger.error("=" * 60)















        logger.error(str(e))















        logger.error("=" * 60)















        logger.error("[FAIL] config_validation_failed=true action=check_required_envs")

        sys.exit(1)















    except SystemExit:















        raise















    except Exception as e:















        from app.utils.logging_config import log_error_with_stacktrace















        log_error_with_stacktrace(logger, e, "Failed to load settings")















        logger.error("[FAIL] settings_load_failed=true action=check_env_and_logs")

        sys.exit(1)















































async def build_application(settings):















    """???????????????????????????????????????? ?????? ?????????????????????????????????????????????????????????????? Telegram Application"""















    global _application















    















    try:















        # ????????????????????????????????????????: ????????????????????????????????? bot_kie ????? ???????????????????????????? ????????????????????????????????????????????????????? ??????????????????????















        create_bot_application = None















        try:















            from bot_kie import create_bot_application















        except ImportError as e1:















            logger.warning(f"[BUILD] Failed to import from bot_kie: {e1}, trying app.bot_kie")















            try:















                # ??????????????????????????????????????? ?????????????????????????????????? ???????????? app.bot_kie (??????????????????????? ????????????????? ????????????????????? ??????????????????????????????????????)















                from app.bootstrap import create_application as create_bot_application















                logger.info("[BUILD] Using app.bootstrap.create_application")















            except ImportError as e2:















                logger.error(f"[BUILD] Failed to import from app.bootstrap: {e2}")















                logger.error(f"[BUILD] sys.path: {sys.path}")















                logger.error(f"[BUILD] Current dir: {os.getcwd()}")















                logger.error(f"[BUILD] Script dir: {Path(__file__).parent}")















                # ??????????????????????????????????????? ?????????????????????????????????????????????? ????????????????????? ???????????????????????















                bot_kie_path = Path(__file__).parent / "bot_kie.py"















                if bot_kie_path.exists():















                    logger.info(f"[BUILD] bot_kie.py exists at {bot_kie_path}")















                    # ??????????????????????????????????????? ?????????????????????????????????? ?????????????????????????????????? ???????????????????????????? importlib















                    import importlib.util















                    spec = importlib.util.spec_from_file_location("bot_kie", bot_kie_path)















                    if spec and spec.loader:















                        bot_kie_module = importlib.util.module_from_spec(spec)















                        spec.loader.exec_module(bot_kie_module)















                        create_bot_application = getattr(bot_kie_module, "create_bot_application", None)















                        if create_bot_application:















                            logger.info("[BUILD] Successfully loaded create_bot_application via importlib")















                else:















                    logger.error(f"[BUILD] bot_kie.py NOT found at {bot_kie_path}")















                if not create_bot_application:















                    raise ImportError(f"Could not import create_bot_application: {e1}, {e2}")















        















        if not create_bot_application:















            raise ImportError("create_bot_application is None after import attempts")















        















        logger.info("[BUILD] Creating Telegram Application...")















        _application = await create_bot_application(settings)















        logger.info("[BUILD] Application created successfully")















        















        return _application















    except (AttributeError, NameError) as e:















        logger.warning(f"[BUILD] create_bot_application not found: {e}, using legacy initialization")















        return None















    except ImportError as e:















        logger.error(f"[BUILD] Import error: {e}")















        logger.warning("[BUILD] Using legacy bot_kie.main() initialization")















        return None















    except Exception as e:















        from app.utils.logging_config import log_error_with_stacktrace















        log_error_with_stacktrace(logger, e, "Failed to build application")















        raise















































async def start_health_server(
    port: int,
    webhook_handler=None,
    **kwargs,
) -> bool:















    """?????????????????????????????????????????????????? healthcheck ????????????????????????????????? ?????? ????????????????? ???????????? event loop"""















    if port == 0:















        logger.info("[HEALTH] PORT not set, skipping healthcheck server (Worker mode)")















        return False















    















    try:















        from app.utils.healthcheck import start_health_server















        return await start_health_server(
            port=port,
            webhook_handler=webhook_handler,
            **kwargs,
        )















    except Exception as e:















        logger.warning(f"[HEALTH] Failed to start health server: {e}")















        return False















































async def run(settings, application):















    """?????????????????????????????????????????????????? ??????????????????????? (polling ?????????????????? webhook)"""















    global _application, _bot_ready, _handler_ready, _dynamic_webhook_handler















    















    # Singleton lock ???????????????????????????????????? ????????????????????? ???????????????????????????????????????? ?????????? ??????????????????????????? async ??????????????????????????????????????????????















    from app.utils.singleton_lock import acquire_singleton_lock, release_singleton_lock















    















    lock_attempted = False
    if not os.getenv("DATABASE_URL"):
        if settings.bot_mode == "webhook":
            logger.error(
                "[LOCK] error_code=CONFIG_DB_REQUIRED fix_hint=set_DATABASE_URL_or_use_BOT_MODE=polling "
                "message=DATABASE_URL_required_for_webhook_mode"
            )
            raise RuntimeError("CONFIG_DB_REQUIRED: DATABASE_URL is required for webhook mode")
        logger.info("[LOCK] DATABASE_URL not set - skipping singleton lock")
    else:
        try:
            lock_attempted = True
            lock_acquired = await acquire_singleton_lock()
            if not lock_acquired:
                logger.warning("[LOCK] Singleton lock not acquired - continuing in passive mode (database may be unavailable)")
        except Exception as e:
            logger.warning(f"[LOCK] Failed to acquire singleton lock (database may be unavailable): {e} - continuing anyway")















    















    try:















        if application is None:
            if settings.port > 0:
                logger.info("[HEALTH] Starting healthcheck server on port %s (legacy mode)", settings.port)
                health_started = await start_health_server(port=settings.port)
                logger.info("[HEALTH] server_listening=%s port=%s", str(health_started).lower(), settings.port)
            else:
                logger.info("[HEALTH] Port not set, running in Worker mode (no healthcheck)")
                logger.info("[HEALTH] server_listening=false reason=port_not_set")
















            # ???????????????????????????????????????????????????????? ???????????????????????????????? ?????????????????????????????????? ???????????????????????????? bot_kie.main()















            logger.info("[RUN] Using legacy bot_kie.main() initialization")















            try:















                from bot_kie import main as bot_main















                await bot_main()















            except ImportError as e:















                logger.error(f"[RUN] Failed to import bot_kie.main: {e}")















                logger.error("[RUN] Falling back to app.main")















                from app.main import main as app_main















                await app_main()















        else:















            # ???????????????????????????????????????????????????????? ????????????????????????????? ??????????????????????????????????















            logger.info("[RUN] Initializing application...")















            smoke_no_process = os.getenv("SMOKE_NO_PROCESS", "").lower() in ("1", "true", "yes")
            if smoke_no_process:
                logger.warning("[RUN] bot_ready=true telegram_init_skipped=true reason=smoke_no_process")
                _bot_ready = True
            else:
                await application.initialize()















                await application.start()
                _bot_ready = True
                logger.info("[RUN] bot_ready=true")

            if settings.port > 0:
                webhook_handler = None
                if settings.bot_mode == "webhook":
                    _dynamic_webhook_handler = build_webhook_handler(application, settings)
                    webhook_handler = build_dynamic_webhook_handler()
                    _handler_ready = True
                    logger.info("[WEBHOOK] handler_ready=true")
                else:
                    _handler_ready = False
                    logger.info("[WEBHOOK] handler_ready=false reason=mode_%s", settings.bot_mode)
                logger.info("[HEALTH] Starting healthcheck server on port %s (web service mode)", settings.port)
                health_started = await start_health_server(
                    port=settings.port,
                    webhook_handler=webhook_handler,
                )
                logger.info("[HEALTH] server_listening=%s port=%s", str(health_started).lower(), settings.port)
                try:
                    from app.utils.healthcheck import get_health_status

                    health_status = get_health_status()
                    logger.info(
                        "[WEBHOOK] route_registered=%s",
                        str(bool(health_status.get("webhook_route_registered"))).lower(),
                    )
                except Exception as exc:
                    logger.warning("[WEBHOOK] route_registered=unknown error=%s", exc)
            else:
                logger.info("[HEALTH] Port not set, running in Worker mode (no healthcheck)")
                logger.info("[HEALTH] server_listening=false reason=port_not_set")

            storage_ok = None
            try:
                from app.storage import get_storage

                storage = get_storage()
                if hasattr(storage, "test_connection"):
                    storage_ok = storage.test_connection()
            except Exception as exc:
                logger.warning("[STORAGE] test_connection_ok=false error=%s", exc)
                storage_ok = False

            try:
                from app.utils.healthcheck import get_health_status

                health_status = get_health_status()
            except Exception:
                health_status = {}

            logger.info(
                "[RUN] readiness bot_ready=%s handler_ready=%s storage_ok=%s webhook_route=%s",
                str(_bot_ready).lower(),
                str(_handler_ready).lower(),
                str(storage_ok).lower() if storage_ok is not None else "unknown",
                str(bool(health_status.get("webhook_route_registered"))).lower(),
            )
            if settings.bot_mode == "webhook" and not health_status.get("webhook_route_registered"):
                logger.error(
                    "[FAIL] webhook_route_not_registered=true action=check_health_server_handler"
                )














            















            logger.info("=" * 60)















            logger.info("BOT READY")















            logger.info("=" * 60)















            logger.info("Handlers registered and application started")















            















            # ??????????????????????????????????????????????????? polling ?????????????????? webhook
            effective_mode = settings.bot_mode
            if effective_mode == "webhook" and not settings.webhook_url:
                logger.warning("[WEBHOOK] WEBHOOK_URL not set for webhook mode - falling back to polling")
                logger.warning(
                    "[WEBHOOK] fallback_to_polling=true reason=missing_webhook_url requested_mode=webhook"
                )
                effective_mode = "polling"
                settings.bot_mode = "polling"















            if effective_mode == "webhook":















                if not settings.webhook_url:















                    logger.warning("[WEBHOOK] WEBHOOK_URL not set for webhook mode - falling back to polling")
                    settings.bot_mode = "polling"
                skip_set = os.getenv("WEBHOOK_SKIP_SET", "").lower() in ("1", "true", "yes")
                if skip_set:
                    logger.info("[WEBHOOK] set_webhook_skipped=true reason=env_override")
                else:
                    await application.bot.set_webhook(settings.webhook_url)
                    logger.info(f"[RUN] Webhook set to {settings.webhook_url}")
                    logger.info("[RUN] webhook_set_ok=true")

                logger.info("[RUN] Webhook mode - bot is ready")















            else:















                # Polling mode - ?????????????????????????????????????????????????????????? ?????????????????????????????????? ????? ?????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????















                logger.info("[RUN] Starting polling...")
                logger.info("[RUN] polling_started=true mode=polling")















                















                # ????????????????????????????????????????: ?????????????????????????????????????????????? ????????????????????????????? ?????????????????????????????????????????????? polling ????????????????? ??????????????????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????















                logger.info("[RUN] Waiting 15 seconds to avoid conflicts with previous instance...")















                await asyncio.sleep(15)















                















                # ????????????????????????????????????????: ???????????????????????????????????????? webhook ????????????????????????? ?????????????????????????????????????????????? polling















                try:















                    await application.bot.delete_webhook(drop_pending_updates=True)















                    webhook_info = await application.bot.get_webhook_info()















                    if webhook_info.url:















                        logger.warning(f"[RUN] Webhook still present: {webhook_info.url}")















                    else:















                        logger.info("[RUN] Webhook removed successfully")















                except Exception as e:















                    logger.warning(f"[RUN] Error removing webhook: {e}")















                    # ?????????????????????????????????????????????????? ???????????? ??????????????????????????????????????????????















                    from telegram.error import Conflict















                    if isinstance(e, Conflict) or "Conflict" in str(e) or "409" in str(e):















                        logger.error("[RUN] Conflict detected while removing webhook - exiting")















                        from app.bot_mode import handle_conflict_gracefully















                        handle_conflict_gracefully(e if isinstance(e, Conflict) else Conflict(str(e)), "polling")















                        return















                















                # ????????????????????????????????????????: ???????????????????????????????????????????????????? ????????????????????????????????????????????????????????? ??????????????????????????????????? ????????????????? updater















                async def handle_updater_error(update, context):















                    """???????????????????????????????????????????????????????? ??????????????????????????????????? ????????????????? updater polling loop"""















                    error = context.error















                    error_msg = str(error) if error else ""















                    















                    from telegram.error import Conflict















                    if isinstance(error, Conflict) or "Conflict" in error_msg or "terminated by other getUpdates" in error_msg or "409" in error_msg:















                        logger.error(f"[UPDATER] 409 CONFLICT in updater loop: {error_msg}")















                        logger.error("[UPDATER] Stopping updater and exiting...")















                        















                        # ??????????????????????????????????????????????????????????????????????????? updater ????????????????????????????????????????????????????????????















                        try:















                            if application.updater and application.updater.running:















                                await application.updater.stop()















                                logger.info("[UPDATER] Updater stopped")















                        except Exception as e:















                            logger.warning(f"[UPDATER] Error stopping updater: {e}")















                        















                        # ??????????????????????????????????????????????????????????????????????????? application















                        try:















                            await application.stop()















                            await application.shutdown()















                        except:















                            pass















                        















                        # ???????????????????????????????????????????????????????????????? lock ?????? ????????????????????????????????????????















                        try:















                            from app.locking.single_instance import release_single_instance_lock















                            release_single_instance_lock()















                        except:















                            pass















                        















                        from app.bot_mode import handle_conflict_gracefully















                        handle_conflict_gracefully(error if isinstance(error, Conflict) else Conflict(error_msg), "polling")






























                        os._exit(0)















                















                # ???????????????????????????????????????????????????? ????????????????????????????????????????????????????????? ??????????????????????????????????? ????????????????? updater















                application.add_error_handler(handle_updater_error)















                















                # ????????????????????????????????????????: ?????????????????????????????????????????????????? ?????????????????????????????????????????????? ????????????????????????? ?????????????????????????????????????????????? polling















                logger.info("[RUN] Checking for conflicts before polling start...")















                try:















                    # ??????????????????????????????????????????? ??????????????????????????????????????? ???????????????????????????????????????????? getUpdates ????????????????? ?????????????????????????????????????????????? ????????????????????????????????????????????????????















                    test_updates = await application.bot.get_updates(limit=1, timeout=1)















                    logger.info("[RUN] Pre-flight check passed: no conflicts detected")















                except Exception as test_e:















                    from telegram.error import Conflict















                    error_msg = str(test_e)















                    if isinstance(test_e, Conflict) or "Conflict" in error_msg or "409" in error_msg or "terminated by other getUpdates" in error_msg:















                        logger.error(f"[RUN] ?????????????????? CONFLICT DETECTED in pre-flight check: {error_msg}")















                        logger.error("[RUN] Another bot instance is already polling - exiting")















                        try:















                            await application.stop()















                            await application.shutdown()















                        except:















                            pass















                        from app.bot_mode import handle_conflict_gracefully















                        handle_conflict_gracefully(test_e if isinstance(test_e, Conflict) else Conflict(error_msg), "polling")















                        return















                    else:















                        logger.warning(f"[RUN] Pre-flight check warning (non-conflict): {test_e}")















                















                # ????????????????????????????????????????: ??????????????????????????????????????????????????? polling ????? ?????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????















                try:















                    await application.updater.start_polling(drop_pending_updates=True)















                    logger.info("[RUN] Polling started successfully")















                except Exception as e:















                    from telegram.error import Conflict















                    error_msg = str(e)















                    if isinstance(e, Conflict) or "Conflict" in error_msg or "409" in error_msg or "terminated by other getUpdates" in error_msg:















                        logger.error(f"[RUN] ?????????????????? CONFLICT DETECTED during polling start: {error_msg}")















                        logger.error("[RUN] Stopping updater and exiting immediately...")















                        















                        # ??????????????????????????????????????????????????????????????????????????? updater ????????????????????????????????????????????????????????????















                        try:















                            if application.updater and application.updater.running:















                                await application.updater.stop()















                                logger.info("[RUN] Updater stopped")















                        except Exception as stop_e:















                            logger.warning(f"[RUN] Error stopping updater: {stop_e}")















                        















                        # ??????????????????????????????????????????????????????????????????????????? application















                        try:















                            await application.stop()















                            await application.shutdown()















                        except:















                            pass















                        















                        # ???????????????????????????????????????????????????????????????? lock















                        try:















                            from app.locking.single_instance import release_single_instance_lock















                            release_single_instance_lock()















                        except:















                            pass















                        















                        from app.bot_mode import handle_conflict_gracefully















                        handle_conflict_gracefully(e if isinstance(e, Conflict) else Conflict(error_msg), "polling")






























                        os._exit(0)  # ???????????????????????????????????????????????????????????????? ????????????????????????????















                    else:















                        raise  # Re-raise non-Conflict errors















            















            # ??????????????????????? ????????????????????????????????????????????????????















            try:















                await asyncio.Event().wait()  # ??????????????????????? ??????????????????????????????????????????????????????????















            except KeyboardInterrupt:















                logger.info("[STOP] Bot stopped by user")















            finally:















                await application.stop()















                await application.shutdown()















    except KeyboardInterrupt:















        logger.info("[STOP] Bot stopped by user")















        sys.exit(0)















    except SystemExit:















        raise















    except Exception as e:















        from app.utils.logging_config import log_error_with_stacktrace















        log_error_with_stacktrace(logger, e, "Fatal error during bot run")















        logger.error("[FAIL] Bot failed to run. Check logs above for details.")















        sys.exit(1)















    finally:















        # ??????????????????????????????????????????????????????????????????????????? healthcheck ?????????????????????????????????













































        















        # ???????????????????????????????????????????????????????????????? singleton lock















        if lock_attempted:
            await release_singleton_lock()
        else:
            logger.info("[LOCK] singleton_lock_release_skipped=true reason=not_attempted")















































async def initialize_and_run():
    settings = await asyncio.to_thread(load_and_validate_settings)

    if os.getenv("SMOKE_MODE", "0") in ("1", "true", "yes"):
        logger.info("[SMOKE] mode=github_storage enabled=true")
        try:
            from app.storage import get_storage

            storage = get_storage()
            if hasattr(storage, "initialize") and asyncio.iscoroutinefunction(storage.initialize):
                await storage.initialize()
        except Exception as e:
            logger.error("[SMOKE] storage_init_failed error=%s", e)

        if settings.port > 0:
            logger.info(f"[HEALTH] Starting healthcheck server on port {settings.port} (SMOKE mode)")
            health_started = await start_health_server(port=settings.port)
            logger.info(
                f"[HEALTH] server_listening={str(health_started).lower()} port={settings.port}"
            )
        else:
            logger.info("[HEALTH] Port not set, running in Worker mode (SMOKE)")
            logger.info("[HEALTH] server_listening=false reason=port_not_set")

        await asyncio.Event().wait()

    application = await build_application(settings)
    await run(settings, application)


async def main():
    """???????????????????????????????????????? async ??????????????????????????????????????"""

    try:
        port_env = os.getenv("PORT", "0")
        try:
            early_port = int(port_env)
        except ValueError:
            early_port = 0

        if early_port < 0:
            early_port = 0

        if early_port > 0:
            webhook_handler = build_dynamic_webhook_handler()
            logger.info("[HEALTH] Starting early healthcheck server on port %s", early_port)
            health_started = await start_health_server(
                port=early_port,
                webhook_handler=webhook_handler,
                self_check=True,
            )
            logger.info(
                "[HEALTH] server_listening=%s port=%s stage=early",
                str(health_started).lower(),
                early_port,
            )

        init_task = asyncio.create_task(initialize_and_run())
        await init_task
    except SystemExit:
        raise
    except Exception as e:
        from app.utils.logging_config import log_error_with_stacktrace

        log_error_with_stacktrace(logger, e, "Fatal error in main")
        sys.exit(1)


if __name__ == "__main__":















    # ??????????????????????????????????????????????????? async main















    try:















        asyncio.run(main())















    except KeyboardInterrupt:















        logger.info("[STOP] Bot stopped by user")















        sys.exit(0)















    except SystemExit:















        raise















    except Exception as e:















        from app.utils.logging_config import log_error_with_stacktrace















        log_error_with_stacktrace(logger, e, "Fatal error in asyncio.run")















        sys.exit(1)
